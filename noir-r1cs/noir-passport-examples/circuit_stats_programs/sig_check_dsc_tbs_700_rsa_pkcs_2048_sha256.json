{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":15171226022470751607,"abi":{"parameters":[{"name":"certificate_registry_root","type":{"kind":"field"},"visibility":"public"},{"name":"certificate_registry_index","type":{"kind":"field"},"visibility":"private"},{"name":"certificate_registry_hash_path","type":{"kind":"array","length":14,"type":{"kind":"field"}},"visibility":"private"},{"name":"certificate_registry_id","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"country","type":{"kind":"string","length":3},"visibility":"private"},{"name":"tbs_certificate","type":{"kind":"array","length":700,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"tbs_certificate_len","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"csc_pubkey","type":{"kind":"array","length":256,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"csc_pubkey_redc_param","type":{"kind":"array","length":257,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"dsc_signature","type":{"kind":"array","length":256,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"exponent","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13325255011231028596":{"error_kind":"string","string":"Exponent must be 65537 or 3"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+y9BZjV1bfGzznUzJkhRLq769Dd3d01M3SHtHQjWICUSiiNEioYgAEYYGGggoHdYheI//le99zvufuuP////fGu7XlHeR6uPK+/Zz3vrHd/1l5zmO0NpPnr15+b06Qp3/WvPweSf6c1/8yW/DvG0q4XtOyClkPQcgpaLkHLLWh5BC2voOUTtPyCVkDQCgpaIUErLGhFBK2ooBUTtOKCVkLQSgpaKUErLWhlBK2soJUTtPKCVkHQKgpaJUGrLGhhQasiaFUFrZqgVRe0GoJWU9BqCVptQasjaHUFrZ6g1Re0BoLWUNAaCVpjQWsiaE0FrZmgNRe0FoLWUtBaCVprQWsjaG0FrZ2gtRe0DoLWUdA6CVpnQesiaF0FrZugdRe0HoLWU9B6CVpvQesjaH0FrZ+g9Re0AYI2UNAGCVqCoCUKWpKgDRa0IYI2VNCGCdpwQRshaCMFbZSgjRa0MYI2VtDGCdp4QZsgaBMFbZKg3SBokwVtiqBNFbRpgjZd0GYI2kxBu1HQZgnabEGbI2hzBW2eoM0XtAWCtlDQFgnaYkFbImhLBW2ZoC0XtJsEbYWgrRS0mwXtFkG7VdBuE7TbBW2VoK0WtDWCdoegrRW0dYK2XtA2CNpGQbtT0O4StLsFbZOgbRa0LYK2VdDuEbR7BW2boG0XtB2CtlPQdgnabkHbI2h7Be0+Qbtf0PYJ2n5BOyBoBwXtAUF7UNAeErRDgnZY0B4WtEcE7VFBe0zQjgjaUUE7JmiPC9oTgvakoD0laMcF7YSgnRS0pwXtGUF7VtCeE7RTgnZa0J4XtBcE7UVBe0nQXha0M4L2iqC9KmivCdrrgnZW0N4QtDcF7S1BOydo5wXtbUF7R9DeFbT3BO2CoL0vaB8I2oeC9pGgfSxonwjap4L2maB9LmhfCNqXgvaVoH0taN8I2kVB+1bQvhO07wXtB0H7UdB+ErSfBe0XQftV0H4TtN8F7ZKgXRa0PwTtiqD9KWje/7G1gKAFBS2toKUTtPSClkHQMgpajKDFClpI0OIELV7QMglaZkHLImhZBe06QcsmaNcLWnZByyFoOQUtl6DlFrQ8gpZX0PIJWn5BKyBoBQWtkKAVFrQiglZU0IoJWnFBKyFoJQWtlKCVFrQyglZW0MoJWnlBqyBoFQWtkqBVFrSwoFURtKqCVk3QqgtaDUGrKWi1BK22oNURtLqCVk/Q6gtaA0FrKGiNBK2xoDURtKaC1kzQmgtaC0FrKWitBK21oLURtLaC1k7Q2gtaB0HrKGidBK2zoHURtK6C1k3QugtaD0HrKWi9BK23oPURtL6C1k/Q+gvaAEEbKGiDBC1B0BIFLUnQBgvaEEEbKmjDBG24oI0QtJGCNkrQRgvaGEEbK2jjBG28oE0QtImCNknQbhC0yYI2RdCmCto0QZsuaDMEbaag3ShoswRttqDNEbS5gjZP0OYL2gJBWyhoiwRtsaAtEbSlgrZM0JYL2k2CtkLQVgrazYJ2i6DdKmi3CdrtgrZK0FYL2hpBu0PQ1graOkFbL2gbBG2joN0paHcJ2t2CtknQNgvaFkHbKmj3CNq9grZN0LYL2g5B2ylouwRtt6DtEbS9gnafoN0vaPsEbb+gHRC0g4L2gKA9KGgPCdohQTssaA8L2iOC9qigPSZoRwTtqKAdE7THBe0JQXtS0J4StOOCdkLQTgra04L2jKA9K2jPCdopQTstaM8L2guC9qKgvSRoLwvaGUF7RdBeFbTXBO11QTsraG8I2puC9pagnRO084L2tqC9I2jvCtp7gnZB0N4XtA8E7UNB+0jQPha0TwTtU0H7TNA+F7QvBO1LQftK0L4WtG8E7aKgfSto3wna94L2g6D9KGg/CdrPgvaLoP0qaL8J2u+CdknQLgvaH4J2RdD+FLQ0wf+tBQQtKGhpBS2doKUXtAyCllHQYgQtVtBCghYnaPGClknQMgtaFkHLKmjXCVo2Qbte0LILWg5ByylouQQtt6DlEbS8gpZP0PILWgFBKyhohQStsKAVEbSiglZM0IoLWglBKylopQSttKCVEbSyglZO0MoLWgVBqyholQStsqCFBa2KoFUVtGqCVl3QaghaTUGrJWi1Ba2OoNUVtHqCVl/QGghaQ0FrJGiNBa2JoDUVtGaC1lzQWghaS0FrJWitBa2NoLUVtHaC1l7QOghaR0HrJGidBa2LoHUVtG6C1l3QeghaT0HrJWi9Ba2PoPUVtH6C1l/QBgjaQEEbJGgJgpYoaEmCNljQhgjaUEEbJmjDBW2EoI0UtFGCNlrQxgjaWEEbJ2jjBW2CoE0UtEmCdoOgTRa0KYI2VdCmCdp0QZshaDMF7UZBmyVoswVtjqDNFbR5gjZf0BYI2kJBWyRoiwVtiaAtFbRlgrZc0G4StBWCtlLQbha0WwTtVkG7TdBuF7RVgrZa0NYI2h2CtlbQ1gnaekHbIGgbBe1OQbtL0O4WtE2CtlnQtgjaVkG7R9DuFbRtgrZd0HYI2k5B2yVouwVtj6DtFbT7BO1+QdsnaPsF7YCgHRS0BwTtQUF7SNAOCdphQXtY0B4RtEcF7TFBOyJoRwXtmKA9LmhPCNqTgvaUoB0XtBOCdlLQnha0ZwTtWUF7TtBOCdppQXte0F4QtBcF7SVBe1nQzgT/elcTqb0i/O9eFbTXBO11QTsraG8I2puC9pagnRO084L2tqC9I2jvCtp7gnZB0N4XtA8E7UNB+0jQPha0TwTtU0H7TNA+F7QvBO1LQftK0L4WtG8E7aKgfSto3wna94L2g6D9KGg/CdrPgvaLoP0qaL8J2u+CdknQLgvaH4J2RdD+FDTvD7YWELSgoKUVtHSCll7QMghaRkGLEbRYQQsJWpygxQtaJkHLLGhZBC2roF0naNkE7XpByy5oOQQtp6DlErTcgpZH0PIKWj5Byy9oBQStoKAVErTCglZE0IoKWjFBKy5oJQStpKCVErTSglZG0MoKWjlBKy9oFQStoqBVErTKghYWtCqCVlXQqgladUGrIWg1Ba2WoNUWtDqCVlfQ6glafUFrIGgNBa2RoDUWtCaC1lTQmglac0FrIWgtBa2VoLUWtDaC1lbQ2glae0HrIGgdBa2ToHUWtC6C1lXQuglad0HrIWg9Ba2XoPUWtD6C1lfQ+glaf0EbIGgDBW2QoCUIWqKgJQnaYEEbImhDBW2YoA0XtBGCNlLQRgnaaEEbI2hjBW2coI0XtAmCNlHQJgnaDYI2WdCmCNpUQZsmaNMFbYagzRS0GwVtlqDNFrQ5gjZX0OYJ2nxBWyBoCwVtkaAtFrQlgrZU0JYJ2nJBu0nQVgjaSkG7WdBuEbRbBe02Qbtd0FYJ2mpBWyNodwjaWkFbJ2jrBW2DoG0UtDsF7S5Bu1vQNgnaZkHbImhbBe0eQbtX0LYJ2nZB2yFoOwVtl6DtFrQ9grZX0O4TtPsFbZ+g7Re0A4J2UNAeELQHBe0hQTskaIcF7WFBe0TQHhW0xwTtiKAdFbRjgva4oD0haE8K2lOCdlzQTgjaSUF7WtCeEbRnBe05QTslaKcF7XlBe0HQXhS0lwTtZUE7I2ivCNqrgvaaoL0uaGcF7Q1Be1PQ3hK0c4J2XtDeFrR3BO1dQXtP0C4I2vuC9oGgfShoHwnax4L2iaB9KmifCdrngvaFoH0paF8J2teC9o2gXRS0bwXtO0H7XtB+ELQfBe0nQftZ0H4RtF8F7TdB+13QLgnaZUH7Q9CuCNqfgpYm3f/WAoIWFLS0gpZO0NILWgZByyhoMYIWK2ghQYsTtHhByyRomQUti6BlFbTrBC2boF0vaNkFLYeg5RS0XIKWW9DyCFpeQcsnaPkFrYCgFRS0QoJWWNCKCFpRQSsmaMUFrYSglRS0UoJWWtDKCFpZQSsnaOUFrYKgVRS0SoJWWdDCglZF0KoKWjVBqy5oNQStpqDVErTaglZH0OoKWj1Bqy9oDQStoaA1ErTGgtZE0JoKWjNBay5oLQStpaC1ErTWgtZG0NoKWjtBay9oHQSto6B1ErTOgtZF0LoKWjdB6y5oPQStp6D1ErTegtZH0PoKWj9B6y9oAwRtoKANErQEQUsUtCRBGyxoQwRtqKANE7ThgjZC0EYK2ihBGy1oYwRtrKCNE7TxgjZB0CYK2iRBu0HQJgvaFEGbKmjTBG26oM0QtJmCdqOgzRK02YI2R9DmCto8QZsvaAsEbaGgLRK0xYK2RNCWCtoyQVsuaDcJ2gpBWyloNwvaLYJ2q6DdJmi3C9oqQVstaGsE7Q5BWyto6wRtvaBtELSNgnanoN0laHcL2iZB2yxoWwRtq6DdI2j3Cto2QdsuaDsEbaeg7RK03YK2R9D2Ctp9gna/oO0TtP2CdkDQDgraA4L2oKA9JGiHBO2woD0saI8I2qOC9pigHRG0o4J2TNAeF7QnBO1JQXtK0I4L2glBOyloTwvaM4L2rKA9J2inBO20oD0vaC8I2ouC9pKgvSxoZwTtFUF7VdBeE7TXBe2soL0haG8K2luCdk7Qzgva24L2jqC9K2jvCdoFQXtf0D4QtA8F7SNB+1jQPhG0TwXtM0H7XNC+ELQvBe0rQfta0L4RtIuC9q2gfSdo3wvaD4L2o6D9JGg/C9ovgvaroP0maL8L2iVBuyxofwjaFUH7U9DSpP/fWkDQgoKWVtDSCVp6QcsgaBkFLUbQYgUtJGhxghYvaJkELbOgZRG0rIJ2naBlE7TrBS27oOUQtJyClkvQcgtaHkHLK2j5BC2/oBUQtIKCVkjQCgtaEUErKmjFBK24oJUQtJKCVkrQSgtaGUErK2jlBK28oFUQtIqCVknQKgtaWNCqCFpVQasmaNUFrYag1RS0WoJWW9DqCFpdQasnaPUFrYGgNRS0RoLWWNCaCFpTQWsmaM0FrYWgtRS0VoLWWtDaCFpbQWsnaO0FrYOgdRS0ToLWWdC6CFpXQesmaN0FrYeg9RS0XoLWW9D6CFpfQesnaP0FbYCgDRS0QYKWIGiJgpYkaIMFbYigDRW0YYI2XNBGCNpIQRslaKMFbYygjRW0cYI2XtAmCNpEQZskaDcI2mRBmyJoUwVtmqBNF7QZgjZT0G4UtFmCNlvQ5gjaXEGbJ2jzBW2BoC0UtEWCtljQlgjaUkFbJmjLBe0mQVshaCsF7WZBu0XQbhW02wTtdkFbJWirBW2NoN0haGsFbZ2grRe0DYK2UdDuFLS7BO1uQdskaJsFbYugbRW0ewTtXkHbJmjbBW2HoO0UtF2CtlvQ9gjaXkG7T9DuF7R9grZf0A4I2kFBe0DQHhS0hwTtkKAdFrSHBe0RQXtU0B4TtCOCdlTQjgna44L2hKA9KWhPCdpxQTshaCcF7WlBe0bQnhW05wTtlKCdFrTnBe0FQXtR0F4StJcF7YygvSJoryZrhdP8z19ZzT8bmX9W/v/+Fb7av3w1+H+qddVqr/1fa12l2uv/91r/r9XO/ie1/l+qvfGf1RKrvfmf1hKqvfWf1/pf1c5dSy2r2vlrq/U/qr19rbUiqr1z7bX+u9q7iFqm2nuYWv9V7QKqVnK19yNqVa1co1q1ITWrDAlXDSdUrlI7sVb1ytWqJ9aoFa4Vrl6r+uAqtapWHVKrWq2atRNr16xcO1yt6pDw0Oq1qw41xV5PD/NVOY3ibPwAOBs/BM7Gj4Cz8WPgbPwEOBs/Bc7Gz4Cz8XPgbPwCOBu/BM7Gr4Cz8WvgbPwGOBsvAmfjt8DZeJZkNn4HnI3fA2fjD8DZ+CNwNv4EnI0/A2fjL8DZ+CtwNv4GnI2/A2fjJeBsvAycjX8AZ+MV4Gz8Ezgb3yCZjd438P8nn1epFkiLm43BtLjZmDYtbjamS4ubjenT4mZjhrS42ZgxLW42xqRNA5uNsWnTwGZjKG0a2GyMQ9Qy1eIxtf6rWiZUreRqmdPiZuObJLMxC3A2ZgXOxuuAszEbcDZeD5yN2YGzMQdwNuYEzsZcwNmYGzgb8wBnY17gbMwHnI35gbOxAHA2vkUyGwsCZ2Mh4GwsDJyNRYCzsShwNhYDzsbiwNlYAjgbSwJnYyngbCwNnI1lgLOxLHA2lgPOxvLA2XiOZDZWAM7GisDZWAk4GysDZ2MYOBurAGdjVeBsrAacjdWBs7EGcDbWBM7GWsDZWBs4G+sAZ2Nd4Gw8TzIb6wFnY33gbGwAnI0NgbOxEXA2NgbOxibA2dgUOBubAWdjc+BsbAGcjS2Bs7EVcDa2Bs7GNsDZ+DbJbGwLnI3tgLOxPXA2dgDOxo7A2dgJOBs7A2djF+Bs7Aqcjd2As7E7cDb2AM7GnsDZ2As4G3sDZ+M7JLOxD3A29gXOxn7A2dgfOBsHAGfjQOBsHAScjQnA2ZgInI1JwNk4GDgbhwBn41DgbBwGnI3DgbPxXZLZOAI4G0cCZ+Mo4GwcDZyNY4CzcSxwNo4DzsbxwNk4ATgbJwJn4yTgbLwBOBsnA2fjFOBsnAqcje+RzMZpwNk4HTgbZwBn40zgbLwROBtnAWfjbOBsnAOcjXOBs3EecDbOB87GBcDZuBA4GxcBZ+Ni4Gy8QDIblwBn41LgbFwGnI3LgbPxJuBsXAGcjSuBs/Fm4Gy8BTgbbwXOxtuAs/F24GxcBZyNq4GzcQ1wNr5PMhvvAM7GtcDZuA44G9cDZ+MG4GzcCJyNdwJn413A2Xg3cDZuAs7GzcDZuAU4G7cCZ+M9wNl4L3A2fkAyG7cBZ+N24GzcAZyNO4GzcRdwNu4GzsY9wNm4Fzgb7wPOxvuBs3EfcDbuB87GA8DZeBA4Gx8AzsYPSWbjg8DZ+BBwNh4CzsbDwNn4MHA2PgKcjY8CZ+NjwNl4BDgbjwJn4zHgbHwcOBufAM7GJ4Gz8SngbPyIZDYeB87GE8DZeBI4G58GzsZngLPxWeBsfA44G08BZ+Np4Gx8HjgbXwDOxheBs/El4Gx8GTgbzwBn48dKszHt/302XuUrrlz5FWD/XgX27xOSu+U14N3yOvBuOQu8W94A3i1vAu+Wt4B3yzng3XIeeLe8Dbxb3gHeLe8C75b3gHfLBeDd8j5wNn4AnI2fkszGD4Gz8SPgbPwYOBs/Ac7GT4Gz8TPgbPwcOBu/AM7GL4Gz8SvgbPwaOBu/Ac7Gi8DZ+C1wNn4HnI2fkczG74Gz8QfgbPwROBt/As7Gn4Gz8RfgbPwVOBt/A87G34Gz8RJwNl4GzsY/gLPxCnA2/gmcjWnS4Wbj5ySzMZAONxuD6XCzMW063GxMlw43G9Onw83GDOlwszFjOtxsjEmHm42x6dLAZmMoXRrYbIxLlwY2G+MRtUy1TJha/1UtM6pWcrUswNn4BclszAqcjdcBZ2M24Gy8HjgbswNnYw7gbMwJnI25gLMxN3A25gHOxrzA2ZgPOBvzA2djAeBsLAicjV+SzMZCwNlYGDgbiwBnY1HgbCwGnI3FgbOxBHA2lgTOxlLA2VgaOBvLAGdjWeBsLAecjeWBs7ECcDZ+RTIbKwJnYyXgbKwMnI1h4GysApyNVYGzsRpwNlYHzsYawNlYEzgbawFnY23gbKwDnI11gbOxHnA2fk0yG+sDZ2MD4GxsCJyNjYCzsTFwNjYBzsamwNnYDDgbmwNnYwvgbGwJnI2tgLOxNXA2tgHOxrbA2fgNyWxsB5yN7YGzsQNwNnYEzsZOwNnYGTgbuwBnY1fgbOwGnI3dgbOxB3A29gTOxl7A2dgbOBv7AGfjRZLZ2Bc4G/sBZ2N/4GwcAJyNA4GzcRBwNiYAZ2MicDYmAWfjYOBsHAKcjUOBs3EYcDYOB87GEcDZ+C3JbBwJnI2jgLNxNHA2jgHOxrHA2TgOOBvHA2fjBOBsnAicjZOAs/EG4GycDJyNU4CzcSpwNk4DzsbvSGbjdOBsnAGcjTOBs/FG4GycBZyNs4GzcQ5wNs4FzsZ5wNk4HzgbFwBn40LgbFwEnI2LgbNxCXA2fk8yG5cCZ+My4GxcDpyNNwFn4wrgbFwJnI03A2fjLcDZeCtwNt4GnI23A2fjKuBsXA2cjWuAs/EO4Gz8gWQ2rgXOxnXA2bgeOBs3AGfjRuBsvBM4G+8Czsa7gbNxE3A2bgbOxi3A2bgVOBvvAc7Ge4GzcRtwNv5IMhu3A2fjDuBs3AmcjbuAs3E3cDbuAc7GvcDZeB9wNt4PnI37gLNxP3A2HgDOxoPA2fgAcDY+CJyNP5HMxoeAs/EQcDYeBs7Gh4Gz8RHgbHwUOBsfA87GI8DZeBQ4G48BZ+PjwNn4BHA2PgmcjU8BZ+Nx4Gz8mWQ2ngDOxpPA2fg0cDY+A5yNzwJn43PA2XgKOBtPA2fj88DZ+AJwNr4InI0vAWfjy8DZeAY4G18BzsZfgLMxnakTSPO/fwX+77Pyar/CyP+mcTDC56/p//rnb+mN6bTmn96/qGdpvxkt8pf9H0WOov94c/jXa6hlT7nfSA/OR0oH53dzcC7ZB+d34eBccnBwgF9o+HfgwblEenA+VDo4l83B+cM+OJeFg/OHg4MD/ELDl4EH5w/Sg/OB0sG5Yg7On/bBuSIcnD8dHBzgFxq+Ajw4f5IenPeVDk6aDMZvBuuQeP/CPjiBDPoHB/iFhr2vAXVwAhk4D84FpYMTNAcnrX1wgsLBSevg4AC/0HAQeHDSkh6c95QOTjpzcNLbByedcHDSOzg4wC80nA54cNKTHpx3lQ5OBnNwMtoHJ4NwcDI6ODjALzScAXhwMpIenHeUDk6MOTix9sGJEQ5OrIODA/xCwzHAgxNLenDeVjo4IXNw4uyDExIOTpyDgwP8QsMh4MGJIz0455UOTrw5OJnsgxMvHJxMDg4O8AsNxwMPTibSg3NO6eBkNgcni31wMgsHJ4uDgwP8QsOZgQcnC+nBeUvp4GQ1B+c6++BkFQ7OdQ4ODvALDWcFHpzrSA/Om0oHJ5s5ONfbByebcHCud3BwgF9oOBvw4FxPenDeUDo42c3ByWEfnOzCwcnh4OAAv9BwduDByUF6cM4qHZyc5uDksg9OTuHg5HJwcIBfaDgn8ODkIj04rysdnNzm4OSxD05u4eDkcXBwgF9oODfw4OQhPTivBHUOTl5zcPLZByevcHDyOTg4wC80nBd4cPIBD05k/4LYg1Il8ofXrjWL/MCvOfIcpdT1AEof0YPIX2iA8ivll+YafdrnLLIXBQycBW04vX+RztIK/v+As/K1/fofTfy/Hq6q//NwhQtkwB3UguCprnUo7bALROeh/F8/qh/Zi0LmUBa2D2Uh4cYoHPEFog7l1Zr4fzxIla2DFC4EPJSFlcKNJqiv9jVfa60iSrdPEeFMom/h34C3cFGlPhRVYNP6FQYOuHBR4NkqptTTYn/DZlMsOi+Rq242xc0lUsK+RIoLm00JB5tNMeBmUxx4UEuQbjbFCTebkuZQlrIPZUlhsynlYLMpDtxsSgIPZSmSzaaY0td8rbVKK90+pR1sNr8DN5sySn0o42CzAQ64cBng2Sqr1NOyf8NmUzY6L5GrbjblzCVS3r5EygmbTXkHm01Z4GZTDnhQy5NuNuUIN5sK5lBWtA9lBWGzqehgsykH3GwqAA9lRZLNpqzS13yttSop3T6VHGw2l4CbTWWlPlR2sNkAB1y4MvBshZV6Gv4bNptwdF4iV91sqphLpKp9iVQRNpuqDjabMHCzqQI8qFVJN5sqhJtNNXMoq9uHspqw2VR3sNlUAW421YCHsjrJZhNW+pqvtVYNpdunhoPN5jJws6mp1IeaDjYb4IAL1wSerVpKPa31N2w2taLzErnqZlPbXCJ17EuktrDZ1HGw2dQCbja1gQe1DulmU5tws6lrDmU9+1DWFTabeg42m9rAzaYu8FDWI9lsail9zddaq77S7VPfwWbzB3CzaaDUhwYONhvggAs3AJ6thko9bfg3bDYNo/MSuepm08hcIo3tS6SRsNk0drDZNARuNo2AB7Ux6WbTiHCzaWIOZVP7UDYRNpumDjabRsDNpgnwUDYl2WwaKn3N11qrmdLt08zBZnMFuNk0V+pDcwebDXDAhZsDz1YLpZ62+Bs2mxbReYlcdbNpaS6RVvYl0lLYbFo52GxaADeblsCD2op0s2lJuNm0NoeyjX0oWwubTRsHm01L4GbTGngo25BsNi2UvuZrrdVW6fZp62Cz+RO42bRT6kM7B5sNcMCF2wHPVnulnrb/Gzab9tF5iVx1s+lgLpGO9iXSQdhsOjrYbNoDN5sOwIPakXSz6UC42XQyh7KzfSg7CZtNZwebTQfgZtMJeCg7k2w27ZW+5mut1UXp9uniYLNJA+xDV6U+dHWw2QAHXLgrsKfdlHra7W/YbLpF5yVy1c2mu7lEetiXSHdhs+nhYLPpBtxsugMPag/SzaY74WbT0xzKXvah7ClsNr0cbDbdgZtNT+Ch7EWy2XRT+pqvtVZvpdunt4PNJgDsQx+lPvRxsNkAB1y4D7CnfZV62vdv2Gz6RuclctXNpp+5RPrbl0g/YbPp72Cz6QvcbPoBD2p/0s2mH+FmM8AcyoH2oRwgbDYDHWw2/YCbzQDgoRxIstn0Vfqar7XWIKXbZ5CDzSYI7EOCUh8SHGw2wAEXTgD2NFGpp4l/w2aTGJ2XyFU3myRziQy2L5EkYbMZ7GCzSQRuNknAgzqYdLNJItxshphDOdQ+lEOEzWaog80mCbjZDAEeyqEkm02i0td8rbWGKd0+wxxsNmmBfRiu1IfhDjYb4IALDwf2dIRST0f8DZvNiOi8RK662Yw0l8go+xIZKWw2oxxsNiOAm81I4EEdRbrZjCTcbEabQznGPpSjhc1mjIPNZiRwsxkNPJRjSDabEUpf87XWGqt0+4x1sNmkA/ZhnFIfxjnYbIADLjwO2NPxSj0d/zdsNuOj8xK56mYzwVwiE+1LZIKw2Ux0sNmMB242E4AHdSLpZjOBcLOZZA7lDfahnCRsNjc42GwmADebScBDeQPJZjNe6Wu+1lqTlW6fyQ42m/TAPkxR6sMUB5sNcMCFpwB7OlWpp1P/hs1manReIlfdbKaZS2S6fYlMEzab6Q42m6nAzWYa8KBOJ91sphFuNjPMoZxpH8oZwmYz08FmMw242cwAHsqZJJvNVKWv+Vpr3ah0+9zoYLPJAOzDLKU+zHKw2QAHXHgWsKezlXo6+2/YbGZH5yVy1c1mjrlE5tqXyBxhs5nrYLOZDdxs5gAP6lzSzWYO4WYzzxzK+fahnCdsNvMdbDZzgJvNPOChnE+y2cxW+pqvtdYCpdtngYPNJiOwDwuV+rDQwWYDHHDhhcCeLlLq6aK/YbNZFJ2XyFU3m8XmElliXyKLhc1miYPNZhFws1kMPKhLSDebxYSbzVJzKJfZh3KpsNksc7DZLAZuNkuBh3IZyWazSOlrvtZay5Vun+UONpsYYB9uUurDTQ42G+CAC98E7OkKpZ6u+Bs2mxXReYlcdbNZaS6Rm+1LZKWw2dzsYLNZAdxsVgIP6s2km81Kws3mFnMob7UP5S3CZnOrg81mJXCzuQV4KG8l2WxWKH3N11rrNqXb5zYHm00ssA+3K/XhdgebDXDAhW8H9nSVUk9X/Q2bzarovESuutmsNpfIGvsSWS1sNmscbDargJvNauBBXUO62awm3GzuMIdyrX0o7xA2m7UONpvVwM3mDuChXEuy2axS+pqvtdY6pdtnnYPNJgTsw3qlPqx3sNkAB1x4PbCnG5R6uuFv2Gw2ROclctXNZqO5RO60L5GNwmZzp4PNZgNws9kIPKh3km42Gwk3m7vMobzbPpR3CZvN3Q42m43AzeYu4KG8m2Sz2aD0NV9rrU1Kt88mB5tNHLAPm5X6sNnBZgMccOHNwJ5uUerplr9hs9kSnZfIVTebreYSuce+RLYKm809DjabLcDNZivwoN5DutlsJdxs7jWHcpt9KO8VNpttDjabrcDN5l7godxGstlsUfqar7XWdqXbZ7uDzSYe2IcdSn3Y4WCzAQ648A5gT3cq9XTn37DZ7IzOS+Sqm80uc4nsti+RXcJms9vBZrMTuNnsAh7U3aSbzS7CzWaPOZR77UO5R9hs9jrYbHYBN5s9wEO5l2Sz2an0NV9rrfuUbp/7HGw2mYB9uF+pD/c72GyAAy58P7Cn+5R6uu9v2Gz2ReclctXNZr+5RA7Yl8h+YbM54GCz2QfcbPYDD+oB0s1mP+Fmc9AcygfsQ3lQ2GwecLDZ7AduNgeBh/IBks1mn9LXfK21HlS6fR50sNlkBvbhIaU+PORgswEOuPBDwJ4eUurpob9hszkUnZfIVTebw+YSedi+RA4Lm83DDjabQ8DN5jDwoD5MutkcJtxsHjGH8lH7UD4ibDaPOthsDgM3m0eAh/JRks3mkNLXfK21HlO6fR5zsNlkAfbhiFIfjjjYbIADLnwE2NOjSj09+jdsNkej8xK56mZzzFwij9uXyDFhs3ncwWZzFLjZHAMe1MdJN5tjhJvNE+ZQPmkfyieEzeZJB5vNMeBm8wTwUD5JstkcVfqar7XWU0q3z1MONpuswD4cV+rDcQebDXDAhY8De3pCqacn/obN5kR0XiJX3WxOmkvkafsSOSlsNk872GxOADebk8CD+jTpZnOScLN5xhzKZ+1D+Yyw2TzrYLM5CdxsngEeymdJNpsTSl/ztdZ6Tun2ec7BZnMdsA+nlPpwysFmAxxw4VPAnp5W6unpv2GzOR2dl8hVN5vnzSXygn2JPC9sNi842GxOAzeb54EH9QXSzeZ5ws3mRXMoX7IP5YvCZvOSg83meeBm8yLwUL5EstmcVvqar7XWy0q3z8sONptswD6cUerDGQebDXDAhc8Ae/qKUk9f+Rs2m1ei8xK56mbzqrlEXrMvkVeFzeY1B5vNK8DN5lXgQX2NdLN5lXCzed0cyrP2oXxd2GzOOthsXgVuNq8DD+VZks3mFaWv+VprvaF0+7zhYLO5HtiHN5X68KaDzQY44MJvAnv6llJP3/obNpu3ovMSuepmc85cIuftS+ScsNmcd7DZvAXcbM4BD+p50s3mHOFm87Y5lO/Yh/JtYbN5x8Fmcw642bwNPJTvkGw2byl9zdda612l2+ddB5tNdmAf3lPqw3sONhvggAu/B+zpBaWeXvgbNpsL0XmJXHWzed9cIh/Yl8j7wmbzgYPN5gJws3kfeFA/IN1s3ifcbD40h/Ij+1B+KGw2HznYbN4HbjYfAg/lRySbzQWlr/laa32sdPt87GCzyQHswydKffjEwWYDHHDhT4A9/VSpp5/+DZvNp9F5iVx1s/nMXCKf25fIZ8Jm87mDzeZT4GbzGfCgfk662XxGuNl8YQ7ll/ah/ELYbL50sNl8BtxsvgAeyi9JNptPlb7ma631ldLt85WDzSYnsA9fK/XhawebDXDAhb8G9vQbpZ5+8zdsNt9E5yVy1c3morlEvrUvkYvCZvOtg83mG+BmcxF4UL8l3WwuEm4235lD+b19KL8TNpvvHWw2F4GbzXfAQ/k9yWbzjdLXfK21flC6fX5wsNnkAvbhR6U+/OhgswEOuPCPwJ7+pNTTn/6Gzean6LxErrrZ/GwukV/sS+RnYbP5xcFm8xNws/kZeFB/Id1sfibcbH41h/I3+1D+Kmw2vznYbH4Gbja/Ag/lbySbzU9KX/O11vpd6fb53cFmkxvYh0tKfbjkYLMBDrjwJWBPLyv19PLfsNlcjs5L5KqbzR/mErliXyJ/CJvNFQebzWXgZvMH8KBeId1s/iDcbP40hzJNRusA/ilsNt7/qFEa7KG8WhOvdbP5E3goI7/2ytf4C9k/69c1QX21r/laawUy6tw+gYz6m00eYE+DSn0IKrBp/QoDB1w4CDxbaZV6mlLX5WaTNmNUXiJX3WzSZfzrn+ntS8T7F/Zm4/2PtDebtBlxm0064EFNn5Fzs0kXnYfyqptNBnMoM9qHMkPG/73ZZHSw2VzDQfpfm00G4KHMSLLZpFX6mq+1VozS7RPjYLPJC9xsYpX6EOtgswEOuHAs8GyFlHoa+hs2m1B0XiJX3WzizCUSb18iccJmE+9gswkBN5s44EGNJ91s4gg3m0zmUGa2D2UmYbPJ7GCziQNuNpmAhzIzyWYTUvqar7VWFqXbJ4uDzSYfcLPJqtSHrA42G+CAC2cFnq3rlHp63d+w2VwXnZfIVTebbOYSud6+RLIJm831Djab64CbTTbgQb2edLPJRrjZZDeHMod9KLMLm00OB5tNNuBmkx14KHOQbDbXKX3N11orp9Ltk/NvuH3OBKPz9knxl/KHyF7kMqDntkH3/kVhS8tttMhf6IMa2cT/8HBVSQE9F/Cg5v6bbp8o8P3fByeNo0OZxxzKvPah9P5FwNLy/v84lMgmXuuhzAM8lHnB4aInYo6IMIF1WQEKC3ZVAMpnep7fBiifAFB+MoDyAQHKDw4XDVDOiDCBdVkBqiLYVQGogOl5QRugAgJABckAKgAEqCA4XDRAuSLCBNZlBaiqYFcFoEKm54VtgAoJABUmA6gQEKDC4HDRAOWOCBNYlxWgaoJdFYCKmJ4XtQEqIgBUlAygIkCAioLDRQOUJyJMYF1WgKoLdlUAKmZ6XtwGqJgAUHEygIoBASoODhcNUN6IMIF1WQGqIdhVAaiE6XlJG6ASAkAlyQAqAQSoJDhcNED5IsIE1mUFqKZgVwWgUqbnpW2ASgkAlSYDqBQQoNLgcNEA5Y8IE1iXFaBagl0VgMqYnpe1ASojAFSWDKAyQIDKgsNFA1QgIkxgXVaAagt2VQAqZ3pe3gaonABQeTKAygEBKg8OFw1QwYgwgXVZAUoQ7KoAVMH0vKINUAUBoIpkAFUAAlQRHC4aoEIRYQLrsgKUKNhVAaiS6XllG6BKAkCVyQCqBASoMjhcNECFI8IE1mUFKEmwqwJQ2PS8ig1QWACoChlAYSBAVcDhogEqEhEmsC4rQIMFuyoAVTU9r2YDVFUAqBoZQFWBAFUDh4sGqGhEmMC6rAANEeyqAFTd9LyGDVB1AaAaZABVBwJUAxwuGqBiEWEC67ICNFSwqwJQTdPzWjZANQWAapEBVBMIUC1wuGiAikeECaxLClDY2Xug2qbndWyAagsA1SEDqDYQoDrgcNEAlYgIE1iXFSBn74Hqmp7XswGqKwBUjwygukCA6oHDRQNUMiJMYF1WgJy9B6pvet7ABqi+AFADMoDqAwFqAA4XDVCpiDCBdVkBcvYeqKHpeSMboIYCQI3IAGoIBKgROFw0QKUjwgTWZQXI2XugxqbnTWyAGgsANSEDqDEQoCbgcNEAlYkIE1iXFSBn74Gamp43swFqKgDUjAygpkCAmoHDRQNUNiJMYF1WgJy9B2puet7CBqi5AFALMoCaAwFqAQ4XDVC5iDCBdVkBcvYeqKXpeSsboJYCQK3IAGoJBKgVOFw0QOUjwgTWZQXI2Xug1qbnbWyAWgsAtSEDqDUQoDbgcNEAVYgIE1iXFSBn74Hamp63swFqKwDUjgygtkCA2oHDRQNUMSJMYF1WgBIEuyoAtTc972AD1F4AqAMZQO2BAHUAh4sGqFJEmMC6rAAlCnZVAOpoet7JBqijAFAnMoA6AgHqBA4XDVDliDCBdVkBShLsqgDU2fS8iw1QZwGgLmQAdQYC1AUcLhqgcESYwLqsADl7D9TV9LybDVBXAaBuZAB1BQLUDRwuGqAqEWEC67IC5Ow9UHfT8x42QN0FgHqQAdQdCFAPcLhogKpGhAmsywqQs/dAPU3Pe9kA9RQA6kUGUE8gQL3A4aIBqhYRJrAuKUBVnL0H6m163scGqLcAUB8ygHoDAeoDDhcNUPWIMIF1WQFy9h6or+l5PxugvgJA/cgA6gsEqB84XDRANSLCBNZlBcjZe6D+pucDbID6CwANIAOoPxCgAeBw0QDVjAgTWJcVIGfvgQaang+yARooADSIDKCBQIAGgcNFA1QrIkxgXVaAnL0HSjA9T7QBShAASiQDKAEIUCI4XDRAtSPCBNZlBcjZe6Ak0/PBNkBJAkCDyQBKAgI0GBwuGqA6EWEC67IC5Ow90BDT86E2QEMEgIaSATQECNBQcLhogOpGhAmsywqQs/dAw0zPh9sADRMAGk4G0DAgQMPB4aIBqhcRJrAuK0DO3gONMD0faQM0QgBoJBlAI4AAjQSHiwaofkSYwLqsADl7DzTK9Hy0DdAoAaDRZACNAgI0GhwuGqAGEWEC67IClCDYVQFojOn5WBugMQJAY8kAGgMEaCw4XDRADSPCBNZlBShRsKsC0DjT8/E2QOMEgMaTATQOCNB4cLhogBpFhAmsywpQkmBXBaAJpucTbYAmCABNJANoAhCgieBw0QA1jggTWJcVIGfvgSaZnt9gAzRJAOgGMoAmAQG6ARwuGqAmEWEC67IC5Ow90GTT8yk2QJMFgKaQATQZCNAUcLhogJpGhAmsywqQs/dAU03Pp9kATRUAmkYG0FQgQNPA4aIBahYRJrAuKUBVnb0Hmm56PsMGaLoA0AwygKYDAZoBDhcNUPOIMIF1WQFy9h5opun5jTZAMwWAbiQDaCYQoBvB4aIBahERJrAuK0DO3gPNMj2fbQM0SwBoNhlAs4AAzQaHiwaoZUSYwLqsADl7DzTH9HyuDdAcAaC5ZADNAQI0FxwuGqBWEWEC67IC5Ow90DzT8/k2QPMEgOaTATQPCNB8cLhogFpHhAmsywqQs/dAC0zPF9oALRAAWkgG0AIgQAvB4aIBahMRJrAuK0DO3gMtMj1fbAO0SABoMRlAi4AALQaHiwaobUSYwLqsADl7D7TE9HypDdASAaClZAAtAQK0FBwuGqB2EWEC67IC5Ow90DLT8+U2QMsEgJaTAbQMCNBycLhogNpHhAmsywqQs/dAN5mer7ABukkAaAUZQDcBAVoBDhcNUIeIMIF1WQFKEOyqALTS9PxmG6CVAkA3kwG0EgjQzeBw0QB1jAgTWJcVoETBrgpAt5ie32oDdIsA0K1kAN0CBOhWcLhogDpFhAmsywpQkmBXBaDbTM9vtwG6TQDodjKAbgMCdDs4XDRAnSPCBNZlBcjZe6BVpuerbYBWCQCtJgNoFRCg1eBw0QB1iQgTWJcVIGfvgdaYnt9hA7RGAOgOMoDWAAG6AxwuGqCuEWEC67IC5Ow90FrT83U2QGsFgNaRAbQWCNA6cLhogLpFhAmsSwpQNWfvgdabnm+wAVovALSBDKD1QIA2gMNFA9Q9IkxgXVaAnL0H2mh6fqcN0EYBoDvJANoIBOhOcLhogHpEhAmsywqQs/dAd5me320DdJcA0N1kAN0FBOhucLhogHpGhAmsywqQs/dAm0zPN9sAbRIA2kwG0CYgQJvB4aIB6hURJrAuK0DO3gNtMT3fagO0RQBoKxlAW4AAbQWHiwaod0SYwLqsADl7D3SP6fm9NkD3CADdSwbQPUCA7gWHiwaoT0SYwLqsADl7D7TN9Hy7DdA2AaDtZABtAwK0HRwuGqC+EWEC67IC5Ow90A7T8502QDsEgHaSAbQDCNBOcLhogPpFhAmsywqQs/dAu0zPd9sA7RIA2k0G0C4gQLvB4aIB6h8RJrAuK0DO3gPtMT3fawO0RwBoLxlAe4AA7QWHiwZoQESYwLqsACUIdlUAus/0/H4boPsEgO4nA+g+IED3g8NFAzQwIkxgXVaAEgW7KgDtMz3fbwO0TwBoPxlA+4AA7QeHiwZoUESYwLqsACUJdlUAOmB6ftAG6IAA0EEygA4AAToIDhcNUEJEmMC6rAA5ew/0gOn5gzZADwgAPUgG0ANAgB4Eh4sGKDEiTGBdVoCcvQd6yPT8kA3QQwJAh8gAeggI0CFwuGiAkiLCBNZlBcjZe6DDpucP2wAdFgB6mAygw0CAHgaHiwZocESYwLqkAFV39h7oEdPzR22AHhEAepQMoEeAAD0KDhcN0JCIMIF1WQFy9h7oMdPzIzZAjwkAHSED6DEgQEfA4aIBGhoRJrAuK0DO3gMdNT0/ZgN0VADoGBlAR4EAHQOHiwZoWESYwLqsADl7D/S46fkTNkCPCwA9QQbQ40CAngCHiwZoeESYwLqsADl7D/Sk6flTNkBPCgA9RQbQk0CAngKHiwZoRESYwLqsADl7D3Tc9PyEDdBxAaATZAAdBwJ0AhwuGqCREWEC67IC5Ow90EnT86dtgE4KAD1NBtBJIEBPg8NFAzQqIkxgXVaAnL0Hesb0/FkboGcEgJ4lA+gZIEDPgsNFAzQ6IkxgXVaAnL0Hes70/JQN0HMCQKfIAHoOCNApcLhogMZEhAmsywqQs/dAp03Pn7cBOi0A9DwZQKeBAD0PDhcN0NiIMIF1WQFKEOyqAPSC6fmLNkAvCAC9SAbQC0CAXgSHiwZoXESYwLqsACUKdlUAesn0/GUboJcEgF4mA+glIEAvg8NFAzQ+IkxgXVaAkgS7KgCdMT1/xQbojADQK2QAnQEC9Ao4XDRAEyLCBNZlBcjZe6BXTc9fswF6VQDoNTKAXgUC9Bo4XDRAEyPCBNZlBcjZe6DXTc/P2gC9LgB0lgyg14EAnQWHiwZoUkSYwLqsADl7D/SG6fmbNkBvCAC9SQbQG0CA3gSHiwbohogwgXVJAarh7D3QW6bn52yA3hIAOkcG0FtAgM6Bw0UDNDkiTGBdVoCcvQc6b3r+tg3QeQGgt8kAOg8E6G1wuGiApkSECazLCpCz90DvmJ6/awP0jgDQu2QAvQME6F1wuGiApkaECazLCpCz90DvmZ5fsAF6TwDoAhlA7wEBugAOFw3QtIgwgXVZAXL2Huh90/MPbIDeFwD6gAyg94EAfQAOFw3Q9IgwgXVZAXL2HuhD0/OPbIA+FAD6iAygD4EAfQQOFw3QjIgwgXVZAXL2Huhj0/NPbIA+FgD6hAygj4EAfQIOFw3QzIgwgXVZAXL2HuhT0/PPbIA+FQD6jAygT4EAfQYOFw3QjRFhAuuyAuTsPdDnpudf2AB9LgD0BRlAnwMB+gIcLhqgWRFhAuuyAuTsPdCXpudf2QB9KQD0FRlAXwIB+gocLhqg2RFhAuuyApQg2FUB6GvT829sgL4WAPqGDKCvgQB9Aw4XDdCciDCBdVkBShTsqgB00fT8WxugiwJA35IBdBEI0LfgcNEAzY0IE1iXFaAkwa4KQN+Znn9vA/SdAND3ZAB9BwToe3C4aIDmRYQJrMsKkLP3QD+Ynv9oA/SDANCPZAD9AAToR3C4aIDmR4QJrMsKkLP3QD+Znv9sA/STANDPZAD9BAToZ3C4aIAWRIQJrMsKkLP3QL+Ynv9qA/SLANCvZAD9AgToV3C4aIAWRoQJrEsKUE1n74F+Mz3/3QboNwGg38kA+g0I0O/gcNEALYoIE1iXFSBn74EumZ5ftgG6JAB0mQygS0CALoPDRQO0OCJMYF1WgJy9B/rD9PyKDdAfAkBXyAD6AwjQFXC4aICWRITp/Wpk/ln5Gn+RAuTsPdCfKT2PSfM/YflTAMj7HxW2TEUzQH8CAfK+dmS4aICWRoaZ5h8PkLP3QIGYv/4ZtAHy/oUNUJAMoEAMzlcwBhsuGqBlEWEC67IC5Ow9UFrT83Q2QGkFgNKRAZQWCFC6GGy4aICWR4QJrMsKkLP3QOlNzzPYAKUXAMpABlB6IEAZYrDhogG6KSJMYF1WgJy9B8poeh5jA5RRACiGDKCMQIBiYrDhogFaEREmsC4rQM7eA8WanodsgGIFgEJkAMUCAQrFYMNFA7QyIkxgXVaAnL0HijM9j7cBihMAiicDKA4IUHwMNlw0QDdHhAmsywpQgmBXBaBMpueZbYAyCQBlJgMoExCgzDHYcNEA3RIRJrAuK0CJgl0VgLKYnme1AcoiAJSVDKAsQICyxmDDRQN0a0SYwLqsACUJdlUAus70PJsN0HUCQNnIALoOCFC2GGy4aIBuiwgTWJcVIGfvga43Pc9uA3S9AFB2MoCuBwKUPQYbLhqg2yPCBNZlBcjZe6Acpuc5bYByCADlJAMoBxCgnDHYcNEArYoIE1iXFSBn74FymZ7ntgHKJQCUmwygXECAcsdgw0UDtDoiTGBdUoBqOXsPlMf0PK8NUB4BoLxkAOUBApQ3BhsuGqA1EWEC67IC5Ow9UD7T8/w2QPkEgPKTAZQPCFD+GGy4aIDuiAgTWJcVIGfvgQqYnhe0ASogAFSQDKACQIAKxmDDRQO0NiJMYF1WgJy9Bypkel7YBqiQAFBhMoAKAQEqHIMNFw3QuogwgXVZAXL2HqiI6XlRG6AiAkBFyQAqAgSoaAw2XDRA6yPCBNZlBcjZe6BipufFbYCKCQAVJwOoGBCg4jHYcNEAbYgIE1iXFSBn74FKmJ6XtAEqIQBUkgygEkCASsZgw0UDtDEiTGBdVoCcvQcqZXpe2gaolABQaTKASgEBKh2DDRcN0J0RYQLrsgLk7D1QGdPzsjZAZQSAypIBVAYIUNkYbLhogO6KCBNYlxUgZ++Bypmel7cBKicAVJ4MoHJAgMrHYMNFA3R3RJjAuqwAJQh2VQCqYHpe0QaoggBQRTKAKgABqhiDDRcN0KaIMIF1WQFKFOyqAFTJ9LyyDVAlAaDKZABVAgJUOQYbLhqgzRFhAuuyApQk2FUBKGx6XsUGKCwAVIUMoDAQoCox2HDRAG2JCBNYlxUgZ++BqpqeV7MBqioAVI0MoKpAgKrFYMNFA7Q1IkxgXVaAnL0Hqm56XsMGqLoAUA0ygKoDAaoRgw0XDdA9EWEC67IC5Ow9UE3T81o2QDUFgGqRAVQTCFCtGGy4aIDujQgTWJcUoNrO3gPVNj2vYwNUWwCoDhlAtYEA1YnBhosGaFtEmMC6rAA5ew9U1/S8ng1QXQGgemQA1QUCVC8GGy4aoO0RYQLrsgLk7D1QfdPzBjZA9QWAGpABVB8IUIMYbLhogHZEhAmsywqQs/dADU3PG9kANRQAakQGUEMgQI1isOGiAdoZESawLitAzt4DNTY9b2ID1FgAqAkZQI2BADWJwYaLBmhXRJjAuqwAOXsP1NT0vJkNUFMBoGZkADUFAtQsBhsuGqDdEWEC67IC5Ow9UHPT8xY2QM0FgFqQAdQcCFCLGGy4aID2RIQJrMsKkLP3QC1Nz1vZALUUAGpFBlBLIECtYrDhogHaGxEmsC4rQM7eA7U2PW9jA9RaAKgNGUCtgQC1icGGiwbovogwgXVZAXL2Hqit6Xk7G6C2AkDtyABqCwSoXQw2XDRA90eECazLClCCYFcFoPam5x1sgNoLAHUgA6g9EKAOMdhw0QDtiwgTWJcVoETBrgpAHU3PO9kAdRQA6kQGUEcgQJ1isOGiAdofESawLitASYJdFYA6m553sQHqLADUhQygzkCAusRgw0UDdCAiTGBdVoCcvQfqanrezQaoqwBQNzKAugIB6haDDRcN0MGIMIF1WQFy9h6ou+l5Dxug7gJAPcgA6g4EqEcMNlw0QA9EhAmsywqQs/dAPU3Pe9kA9RQA6kUGUE8gQL1isOGiAXowIkxgXVKAEpy9B+ptet7HBqi3AFAfMoB6AwHqE4MNFw3QQxFhAuuyAuTsPVBf0/N+NkB9BYD6kQHUFwhQvxhsuGiADkWECazLCpCz90D9Tc8H2AD1FwAaQAZQfyBAA2Kw4aIBOhwRJrAuK0DO3gMNND0fZAM0UABoEBlAA4EADYrBhosG6OGIMIF1WQFy9h4owfQ80QYoQQAokQygBCBAiTHYcNEAPRIRJrAuK0DO3gMlmZ4PtgFKEgAaTAZQEhCgwTHYcNEAPRoRJrAuK0DO3gMNMT0fagM0RABoKBlAQ4AADY3BhosG6LGIMIF1WQFy9h5omOn5cBugYQJAw8kAGgYEaHgMNlw0QEciwgTWZQXI2XugEabnI22ARggAjSQDaAQQoJEx2HDRAB2NCBNYlxUgZ++BRpmej7YBGiUANJoMoFFAgEbHYMNFA3QsIkxgXVaAEgS7KgCNMT0fawM0RgBoLBlAY4AAjY3BhosG6PGIMIF1WQFKFOyqADTO9Hy8DdA4AaDxZACNAwI0PgYbLhqgJyLCBNZlBShJsKsC0ATT84k2QBMEgCaSATQBCNDEGGy4aICejAgTWJcVIGfvgSaZnt9gAzRJAOgGMoAmAQG6IQYbLhqgpyLCBNZlBcjZe6DJpudTbIAmCwBNIQNoMhCgKTHYcNEAHY8IE1iXFSBn74Gmmp5PswGaKgA0jQygqUCApsVgw0UDdCIiTGBdUoASnb0Hmm56PsMGaLoA0AwygKYDAZoRgw0XDdDJiDCBdVkBcvYeaKbp+Y02QDMFgG4kA2gmEKAbY7DhogF6OiJMYF1WgJy9B5plej7bBmiWANBsMoBmAQGaHYMNFw3QMxFhAuuyAuTsPdAc0/O5NkBzBIDmkgE0BwjQ3BhsuGiAno0IE1iXFSBn74HmmZ7PtwGaJwA0nwygeUCA5sdgw0UD9FxEmMC6rAA5ew+0wPR8oQ3QAgGghWQALQACtDAGGy4aoFMRYQLrsgLk7D3QItPzxTZAiwSAFpMBtAgI0OIYbLhogE5HhAmsywqQs/dAS0zPl9oALREAWkoG0BIgQEtjsOGiAXo+IkxgXVaAnL0HWmZ6vtwGaJkA0HIygJYBAVoegw0XDdALEWEC67IC5Ow90E2m5ytsgG4SAFpBBtBNQIBWxGDDRQP0YkSYwLqsACUIdlUAWml6frMN0EoBoJvJAFoJBOjmGGy4aIBeiggTWJcVoETBrgpAt5ie32oDdIsA0K1kAN0CBOjWGGy4aIBejggTWJcVoCTBrgpAt5me324DdJsA0O1kAN0GBOj2GGy4aIDORIQJrMsKkLP3QKtMz1fbAK0SAFpNBtAqIECrY7DhogF6JSJMYF1WgJy9B1pjen6HDdAaAaA7yABaAwTojhhsuGiAXo0IE1iXFSBn74HWmp6vswFaKwC0jgygtUCA1sVgw0UD9FpEmMC6pAAlOXsPtN70fIMN0HoBoA1kAK0HArQhBhsuGqDXI8IE1mUFyNl7oI2m53faAG0UALqTDKCNQIDujMGGiwbobESYwLqsADl7D3SX6fndNkB3CQDdTQbQXUCA7o7BhosG6I2IMIF1WQFy9h5ok+n5ZhugTQJAm8kA2gQEaHMMNlw0QG9GhAmsywqQs/dAW0zPt9oAbREA2koG0BYgQFtjsOGiAXorIkxgXVaAnL0Husf0/F4boHsEgO4lA+geIED3xmDDRQN0LiJMYF1WgJy9B9pmer7dBmibANB2MoC2AQHaHoMNFw3Q+YgwgXVZAXL2HmiH6flOG6AdAkA7yQDaAQRoZww2XDRAb0eECazLCpCz90C7TM932wDtEgDaTQbQLiBAu2Ow4aIBeiciTGBdVoCcvQfaY3q+1wZojwDQXjKA9gAB2huDDRcN0LsRYQLrsgKUINhVAeg+0/P7bYDuEwC6nwyg+4AA3R+DDRcN0HsRYQLrsgKUKNhVAWif6fl+G6B9AkD7yQDaBwRofww2XDRAFyLCBNZlBShJsKsC0AHT84M2QAcEgA6SAXQACNDBGGy4aIDejwgTWJcVIGfvgR4wPX/QBugBAaAHyQB6AAjQgzHYcNEAfRARJrAuK0DO3gM9ZHp+yAboIQGgQ2QAPQQE6FAMNlw0QB9GhAmsywqQs/dAh03PH7YBOiwA9DAZQIeBAD0cgw0XDdBHEWEC65ICNNjZe6BHTM8ftQF6RADoUTKAHgEC9GgMNlw0QB9HhAmsywqQs/dAj5meH7EBekwA6AgZQI8BAToSgw0XDdAnEWEC67IC5Ow90FHT82M2QEcFgI6RAXQUCNCxGGy4aIA+jQgTWJcVIGfvgR43PX/CBuhxAaAnyAB6HAjQEzHYcNEAfRYRJrAuK0DO3gM9aXr+lA3QkwJAT5EB9CQQoKdisOGiAfo8IkxgXVaAnL0HOm56fsIG6LgA0AkygI4DAToRgw0XDdAXEWEC67IC5Ow90EnT86dtgE4KAD1NBtBJIEBPx2DDRQP0ZUSYwLqsADl7D/SM6fmzNkDPCAA9SwbQM0CAno3BhosG6KuIMIF1WQFy9h7oOdPzUzZAzwkAnSID6DkgQKdisOGiAfo6IkxgXVaAnL0HOm16/rwN0GkBoOfJADoNBOj5GGy4aIC+iQgTWJcVoATBrgpAL5iev2gD9IIA0ItkAL0ABOjFGGy4aIAuRoQJrMsKUKJgVwWgl0zPX7YBekkA6GUygF4CAvRyDDZcNEDfRoQJrMsKUJJgVwWgM6bnr9gAnREAeoUMoDNAgF6JwYaLBui7iDCBdVkBcvYe6FXT89dsgF4VAHqNDKBXgQC9FoMNFw3Q9xFhAuuyAuTsPdDrpudnbYBeFwA6SwbQ60CAzsZgw0UD9ENEmMC6rAA5ew/0hun5mzZAbwgAvUkG0BtAgN6MwYaLBujHiDCBdUkBGuLsPdBbpufnbIDeEgA6RwbQW0CAzsVgw0UD9FNEmMC6rAA5ew903vT8bRug8wJAb5MBdB4I0Nsx2HDRAP0cESawLitAzt4DvWN6/q4N0DsCQO+SAfQOEKB3Y7DhogH6JSJMYF1WgJy9B3rP9PyCDdB7AkAXyAB6DwjQhRhsuGiAfo0IE1iXFSBn74HeNz3/wAbofQGgD8gAeh8I0Acx2HDRAP0WESawLitAzt4DfWh6/pEN0IcCQB+RAfQhEKCPYrDhogH6PSJMYF1WgJy9B/rY9PwTG6CPBYA+IQPoYyBAn8Rgw0UDdCkiTGBdVoCcvQf61PT8MxugTwWAPiMD6FMgQJ/FYMNFA3Q5IkxgXVaAnL0H+tz0/AsboM8FgL4gA+hzIEBfxGDDRQP0R0SYwLqsADl7D/Sl6flXNkBfCgB9RQbQl0CAvorBhosG6EpEmMC6rAAlCHZVAPra9PwbG6CvBYC+IQPoayBA38Rgw0UD9GdEmMC6rAAlCnZVALpoev6tDdBFAaBvyQC6CATo2xhsuGiAvIIX/wUopcdJgl0VgL4zPf/eBug7AaDvyQD6DgjQ9zHYcNEABQJ+mMC6rAA5ew/0g+n5jzZAPwgA/UgG0A9AgH6MwYaLBigY8MME1mUFyNl7oJ9Mz3+2AfpJAOhnMoB+AgL0cww2XDRAaQN+mMC6rAA5ew/0i+n5rzZAvwgA/UoG0C9AgH6NwYaLBihdwA8TWJcUoKHO3gP9Znr+uw3QbwJAv5MB9BsQoN9jsOGiAUof8MME1mUFyNl7oEum55dtgC4JAF0mA+gSEKDLMdhw0QBlCPhhAuuyAuTsPdAfpudXbID+EAC6QgbQH0CArsRgw0UDlDHghwmsywqQs/dAf6b0PDbN/4TlTwEg739U2DIVzQD9CQTI+9qR4aIBiglEhJnmHw+Qs/dAgdi//hm0AfL+hQ1QkAygQCzOVzAWGy4aoNiAHyawLitAzt4DpTU9T2cDlFYAKB0ZQGmBAKWLxYaLBigU8MME1mUFyNl7oPSm5xlsgNILAGUgAyg9EKAMsdhw0QDFBfwwgXVZAXL2Hiij6XmMDVBGAaAYMoAyAgGKicWGiwYoPuCHCazLCpCz90CxpuchG6BYAaAQGUCxQIBCsdhw0QBlCvhhAuuyAuTsPVCc6Xm8DVCcAFA8GUBxQIDiY7HhogHKHPDDBNZlBShBsKsCUCbT88w2QJkEgDKTAZQJCFDmWGy4aICyBPwwgXVZAUoU7KoAlMX0PKsNUBYBoKxkAGUBApQ1FhsuGqCsAT9MYF1WgJIEuyoAXWd6ns0G6DoBoGxkAF0HBChbLDZcNEDXBfwwgXVZAXL2Huh60/PsNkDXCwBlJwPoeiBA2WOx4aIByhbwwwTWZQXI2XugHKbnOW2AcggA5SQDKAcQoJyx2HDRAF0f8MME1mUFyNl7oFym57ltgHIJAOUmAygXEKDcsdhw0QBlD/hhAutyApT8fwW7KgDlMT3PawOURwAoLxlAeYAA5Y3FhosGKEfADxNYlxUgZ++B8pme57cByicAlJ8MoHxAgPLHYsNFA5Qz4IcJrMsKkLP3QAVMzwvaABUQACpIBlABIEAFY7HhogHKFfDDBNZlBcjZe6BCpueFbYAKCQAVJgOoEBCgwrHYcNEA5Q74YQLrsgLk7D1QEdPzojZARQSAipIBVAQIUNFYbLhogPIE/DCBdVkBcvYeqJjpeXEboGICQMXJACoGBKh4LDZcNEB5A36YwLqsADl7D1TC9LykDVAJAaCSZACVAAJUMhYbLhqgfAE/TGBdVoCcvQcqZXpe2gaolABQaTKASgEBKh2LDRcNUP6AHyawLitAzt4DlTE9L2sDVEYAqCwZQGWAAJWNxYaLBqhAwA8TWJcVIGfvgcqZnpe3ASonAFSeDKByQIDKx2LDRQNUMOCHCazLClCCYFcFoAqm5xVtgCoIAFUkA6gCEKCKsdhw0QAVCvhhAuuyApQo2FUBqJLpeWUboEoCQJXJAKoEBKhyLDZcNECFA36YwLqsACUJdlUACpueV7EBCgsAVSEDKAwEqEosNlw0QEUCfpjAuqwAOXsPVNX0vJoNUFUBoGpkAFUFAlQtFhsuGqCiAT9MYF1WgJy9B6puel7DBqi6AFANMoCqAwGqEYsNFw1QsYAfJrAuK0DO3gPVND2vZQNUUwCoFhlANYEA1YrFhosGqHjADxNYlxSgsLP3QLVNz+vYANUWAKpDBlBtIEB1YrHhogEqEfDDBNZlBcjZe6C6puf1bIDqCgDVIwOoLhCgerHYcNEAlQz4YQLrsgLk7D1QfdPzBjZA9QWAGpABVB8IUINYbLhogEoF/DCBdVkBcvYeqKHpeSMboIYCQI3IAGoIBKhRLDZcNEClA36YwLqsADl7D9TY9LyJDVBjAaAmZAA1BgLUJBYbLhqgMgE/TGBdVoCcvQdqanrezAaoqQBQMzKAmgIBahaLDRcNUNmAHyawLitAzt4DNTc9b2ED1FwAqAUZQM2BALWIxYaLBqhcwA8TWJcVIGfvgVqanreyAWopANSKDKCWQIBaxWLDRQNUPuCHCazLCpCz90CtTc/b2AC1FgBqQwZQayBAbWKx4aIBqhDwwwTWZQXI2Xugtqbn7WyA2goAtSMDqC0QoHax2HDRAFUM+GEC67IClCDYVQGovel5Bxug9gJAHcgAag8EqEMsNlw0QJUCfpjAuqwAJQp2VQDqaHreyQaoowBQJzKAOgIB6hSLDRcNUOWAHyawLitASYJdFYA6m553sQHqLADUhQygzkCAusRiw0UDFA74YQLrsgLk7D1QV9PzbjZAXQWAupEB1BUIULdYbLhogKoE/DCBdVkBcvYeqLvpeQ8boO4CQD3IAOoOBKhHLDZcNEBVA36YwLqsADl7D9TT9LyXDVBPAaBeZAD1BALUKxYbLhqgagE/TGBdUoCqOHsP1Nv0vI8NUG8BoD5kAPUGAtQnFhsuGqDqAT9MYF1WgJy9B+pret7PBqivAFA/MoD6AgHqF4sNFw1QjYAfJrAuK0DO3gP1Nz0fYAPUXwBoABlA/YEADYjFhosGqGbADxNYlxUgZ++BBpqeD7IBGigANIgMoIFAgAbFYsNFA1Qr4IcJrMsKkLP3QAmm54k2QAkCQIlkACUAAUqMxYaLBqh2wA8TWJcVIGfvgZJMzwfbACUJAA0mAygJCNDgWGy4aIDqBPwwgXVZAXL2HmiI6flQG6AhAkBDyQAaAgRoaCw2XDRAdQN+mMC6rAA5ew80zPR8uA3QMAGg4WQADQMCNDwWGy4aoHoBP0xgXVaAnL0HGmF6PtIGaIQA0EgygEYAARoZiw0XDVD9gB8msC4rQM7eA40yPR9tAzRKAGg0GUCjgACNjsWGiwaoQcAPE1iXFaAEwa4KQGNMz8faAI0RABpLBtAYIEBjY7HhogFqGPDDBNZlBShRsKsC0DjT8/E2QOMEgMaTATQOCND4WGy4aIAaBfwwgXVZAUoS7KoANMH0fKIN0AQBoIlkAE0AAjQxFhsuGqDGAT9MYF1WgJy9B5pken6DDdAkAaAbyACaBATohlhsuGiAmgT8MIF1WQFy9h5osun5FBugyQJAU8gAmgwEaEosNlw0QE0DfpjAuqwAOXsPNNX0fJoN0FQBoGlkAE0FAjQtFhsuGqBmAT9MYF1SgKo6ew803fR8hg3QdAGgGWQATQcCNCMWGy4aoOYBP0xgXVaAnL0Hmml6fqMN0EwBoBvJAJoJBOjGWGy4aIBaBPwwgXVZAXL2HmiW6flsG6BZAkCzyQCaBQRodiw2XDRALQN+mMC6rAA5ew80x/R8rg3QHAGguWQAzQECNDcWGy4aoFYBP0xgXVaAnL0Hmmd6Pt8GaJ4A0HwygOYBAZofiw0XDVDrgB8msC4rQM7eAy0wPV9oA7RAAGghGUALgAAtjMWGiwaoTcAPE1iXFSBn74EWmZ4vtgFaJAC0mAygRUCAFsdiw0UD1DbghwmsywqQs/dAS0zPl9oALREAWkoG0BIgQEtjseGiAWoX8MME1mUFyNl7oGWm58ttgJYJAC0nA2gZEKDlsdhw0QC1D/hhAuuyAuTsPdBNpucrbIBuEgBaQQbQTUCAVsRiw0UD1CHghwmsywpQgmBXBaCVpuc32wCtFAC6mQyglUCAbo7FhosGqGPADxNYlxWgRMGuCkC3mJ7fagN0iwDQrWQA3QIE6NZYbLhogDoF/DCBdVkBShLsqgB0m+n57TZAtwkA3U4G0G1AgG6PxYaLBqhzwA8TWJcVIGfvgVaZnq+2AVolALSaDKBVQIBWx2LDRQPUJeCHCazLCpCz90BrTM/vsAFaIwB0BxlAa4AA3RGLDRcNUNeAHyawLitAzt4DrTU9X2cDtFYAaB0ZQGuBAK2LxYaLBqhbwA8TWJcUoGrO3gOtNz3fYAO0XgBoAxlA64EAbYjFhosGqHvADxNYlxUgZ++BNpqe32kDtFEA6E4ygDYCAbozFhsuGqAeAT9MYF1WgJy9B7rL9PxuG6C7BIDuJgPoLiBAd8diw0UD1DPghwmsywqQs/dAm0zPN9sAbRIA2kwG0CYgQJtjseGiAeoV8MME1mUFyNl7oC2m51ttgLYIAG0lA2gLEKCtsdhw0QD1DvhhAuuyAuTsPdA9puf32gDdIwB0LxlA9wABujcWGy4aoD4BP0xgXVaAnL0H2mZ6vt0GaJsA0HYygLYBAdoeiw0XDVDfgB8msC4rQM7eA+0wPd9pA7RDAGgnGUA7gADtjMWGiwaoX8APE1iXFSBn74F2mZ7vtgHaJQC0mwygXUCAdsdiw0UD1D/ghwmsywqQs/dAe0zP99oA7REA2ksG0B4gQHtjseGiARoQ8MME1mUFKEGwqwLQfabn99sA3ScAdD8ZQPcBAbo/FhsuGqCBAT9MYF1WgBIFuyoA7TM9328DtE8AaD8ZQPuAAO2PxYaLBmhQwA8TWJcVoCTBrgpAB0zPD9oAHRAAOkgG0AEgQAdjseGiAUoI+GEC67IC5Ow90AOm5w/aAD0gAPQgGUAPAAF6MBYbLhqgxIAfJrAuK0DO3gM9ZHp+yAboIQGgQ2QAPQQE6FAsNlw0QEkBP0xgXVaAnL0HOmx6/rAN0GEBoIfJADoMBOjhWGy4aIAGB/wwgXVJAaru7D3QI6bnj9oAPSIA9CgZQI8AAXo0FhsuGqAhAT9MYF1WgJy9B3rM9PyIDdBjAkBHyAB6DAjQkVhsuGiAhgb8MIF1WQFy9h7oqOn5MRugowJAx8gAOgoE6FgsNlw0QMMCfpjAuqwAOXsP9Ljp+RM2QI8LAD1BBtDjQICeiMWGiwZoeMAPE1iXFSBn74GeND1/ygboSQGgp8gAehII0FOx2HDRAI0I+GEC67IC5Ow90HHT8xM2QMcFgE6QAXQcCNCJWGy4aIBGBvwwgXVZAXL2Huik6fnTNkAnBYCeJgPoJBCgp2Ox4aIBGhXwwwTWZQXI2XugZ0zPn7UBekYA6FkygJ4BAvRsLDZcNECjA36YwLqsADl7D/Sc6fkpG6DnBIBOkQH0HBCgU7HYcNEAjQn4YQLrsgLk7D3QadPz522ATgsAPU8G0GkgQM/HYsNFAzQ24IcJrMsKUIJgVwWgF0zPX7QBekEA6EUygF4AAvRiLDZcNEDjAn6YwLqsACUKdlUAesn0/GUboJcEgF4mA+glIEAvx2LDRQM0PuCHCazLClCSYFcFoDOm56/YAJ0RAHqFDKAzQIBeicWGiwZoQsAPE1iXFSBn74FeNT1/zQboVQGg18gAehUI0Gux2HDRAE0M+GEC67IC5Ow90Oum52dtgF4XADpLBtDrQIDOxmLDRQM0KeCHCazLCpCz90BvmJ6/aQP0hgDQm2QAvQEE6M1YbLhogG4I+GEC65ICVMPZe6C3TM/P2QC9JQB0jgygt4AAnYvFhosGaHLADxNYlxUgZ++Bzpuev20DdF4A6G0ygM4DAXo7FhsuGqApAT9MYF1WgJy9B3rH9PxdG6B3BIDeJQPoHSBA78Ziw0UDNDXghwmsywqQs/dA75meX7ABek8A6AIZQO8BAboQiw0XDdC0gB8msC4rQM7eA71vev6BDdD7AkAfkAH0PhCgD2Kx4aIBmh7wwwTWZQXI2XugD03PP7IB+lAA6CMygD4EAvRRLDZcNEAzAn6YwLqsADl7D/Sx6fknNkAfCwB9QgbQx0CAPonFhosGaGbADxNYlxUgZ++BPjU9/8wG6FMBoM/IAPoUCNBnsdhw0QDdGPDDBNZlBcjZe6DPTc+/sAH6XADoCzKAPgcC9EUsNlw0QLMCfpjAuqwAOXsP9KXp+Vc2QF8KAH1FBtCXQIC+isWGiwZodsAPE1iXFaAEwa4KQF+bnn9jA/S1ANA3ZAB9DQTom1hsuGiA5gT8MIF1WQFKFOyqAHTR9PxbG6CLAkDfkgF0EQjQt7HYcNEAzQ34YQLrsgKUJNhVAeg70/PvbYC+EwD6ngyg74AAfR+LDRcN0LyAHyawLitAzt4D/WB6/qMN0A8CQD+SAfQDEKAfY7HhogGaH/DDBNZlBcjZe6CfTM9/tgH6SQDoZzKAfgIC9HMsNlw0QAsCfpjAuqwAOXsP9Ivp+a82QL8IAP1KBtAvQIB+jcWGiwZoYcAPE1iXFKCazt4D/WZ6/rsN0G8CQL+TAfQbEKDfY7HhogFaFPDDBNZlBcjZe6BLpueXbYAuCQBdJgPoEhCgy7HYcNEALQ74YQLrsgLk7D3QH6bnV2yA/hAAukIG0B9AgK7EYsNFA7Qk4IcJrMsKkLP3QH+m9DyU5n/C8qcAkPc/KmyZimaA/gQC5H3tyHDRAC0NRISZ5h8PkLP3QIHQX/8M2gB5/8IGKEgGUCCE8xUMYcNFA7Qs4IcJrMsKkLP3QGlNz9PZAKUVAEpHBlBaIEDpQthw0QAtD/hhAuuyAuTsPVB60/MMNkDpBYAykAGUHghQhhA2XDRANwX8MIF1WQFy9h4oo+l5jA1QRgGgGDKAMgIBiglhw0UDtCLghwmsywqQs/dAsabnIRugWAGgEBlAsUCAQiFsuGiAVgb8MIF1WQFy9h4ozvQ83gYoTgAongygOCBA8SFsuGiAbg74YQLrsgKUINhVASiT6XlmG6BMAkCZyQDKBAQocwgbLhqgWwJ+mMC6rAAlCnZVAMpiep7VBiiLAFBWMoCyAAHKGsKGiwbo1oAfJrAuK0BJgl0VgK4zPc9mA3SdAFA2MoCuAwKULYQNFw3QbQE/TGBdVoCcvQe63vQ8uw3Q9QJA2ckAuh4IUPYQNlw0QLcH/DCBdVkBcvYeKIfpeU4boBwCQDnJAMoBBChnCBsuGqBVAT9MYF1WgJy9B8plep7bBiiXAFBuMoByAQHKHcKGiwZodcAPE1iXFKBazt4D5TE9z2sDlEcAKC8ZQHmAAOUNYcNFA7Qm4IcJrMsKkLP3QPlMz/PbAOUTAMpPBlA+IED5Q9hw0QDdEfDDBNZlBcjZe6ACpucFbYAKCAAVJAOoABCggiFsuGiA1gb8MIF1WQFy9h6okOl5YRugQgJAhckAKgQEqHAIGy4aoHUBP0xgXVaAnL0HKmJ6XtQGqIgAUFEygIoAASoawoaLBmh9wA8TWJcVIGfvgYqZnhe3ASomAFScDKBiQICKh7DhogHaEPDDBNZlBcjZe6ASpuclbYBKCACVJAOoBBCgkiFsuGiANgb8MIF1WQFy9h6olOl5aRugUgJApckAKgUEqHQIGy4aoDsDfpjAuqwAOXsPVMb0vKwNUBkBoLJkAJUBAlQ2hA0XDdBdAT9MYF1WgJy9Bypnel7eBqicAFB5MoDKAQEqH8KGiwbo7oAfJrAuK0AJgl0VgCqYnle0AaogAFSRDKAKQIAqhrDhogHaFPDDBNZlBShRsKsCUCXT88o2QJUEgCqTAVQJCFDlEDZcNECbA36YwLqsACUJdlUACpueV7EBCgsAVSEDKAwEqEoIGy4aoC0BP0xgXVaAnL0Hqmp6Xs0GqKoAUDUygKoCAaoWwoaLBmhrwA8TWJcVIGfvgaqbntewAaouAFSDDKDqQIBqhLDhogG6J+CHCazLCpCz90A1Tc9r2QDVFACqRQZQTSBAtULYcNEA3RvwwwTWJQWotrP3QLVNz+vYANUWAKpDBlBtIEB1Qthw0QBtC/hhAuuyAuTsPVBd0/N6NkB1BYDqkQFUFwhQvRA2XDRA2wN+mMC6rAA5ew9U3/S8gQ1QfQGgBmQA1QcC1CCEDRcN0I6AHyawLitAzt4DNTQ9b2QD1FAAqBEZQA2BADUKYcNFA7Qz4IcJrMsKkLP3QI1Nz5vYADUWAGpCBlBjIEBNQthw0QDtCvhhAuuyAuTsPVBT0/NmNkBNBYCakQHUFAhQsxA2XDRAuwN+mMC6rAA5ew/U3PS8hQ1QcwGgFmQANQcC1CKEDRcN0J6AHyawLitAzt4DtTQ9b2UD1FIAqBUZQC2BALUKYcNFA7Q34IcJrMsKkLP3QK1Nz9vYALUWAGpDBlBrIEBtQthw0QDdF/DDBNZlBcjZe6C2puftbIDaCgC1IwOoLRCgdiFsuGiA7g/4YQLrsgKUINhVAai96XkHG6D2AkAdyABqDwSoQwgbLhqgfQE/TGBdVoASBbsqAHU0Pe9kA9RRAKgTGUAdgQB1CmHDRQO0P+CHCazLClCSYFcFoM6m511sgDoLAHUhA6gzEKAuIWy4aIAOBPwwgXVZAXL2Hqir6Xk3G6CuAkDdyADqCgSoWwgbLhqggwE/TGBdVoCcvQfqbnrewwaouwBQDzKAugMB6hHChosG6IGAHyawLitAzt4D9TQ972UD1FMAqBcZQD2BAPUKYcNFA/RgwA8TWJcUoARn74F6m573sQHqLQDUhwyg3kCA+oSw4aIBeijghwmsywqQs/dAfU3P+9kA9RUA6kcGUF8gQP1C2HDRAB0K+GEC67IC5Ow9UH/T8wE2QP0FgAaQAdQfCNCAEDZcNECHA36YwLqsADl7DzTQ9HyQDdBAAaBBZAANBAI0KIQNFw3QwwE/TGBdVoCcvQdKMD1PtAFKEABKJAMoAQhQYggbLhqgRwJ+mMC6rAA5ew+UZHo+2AYoSQBoMBlASUCABoew4aIBejTghwmsywqQs/dAQ0zPh9oADREAGkoG0BAgQEND2HDRAD0W8MME1mUFyNl7oGGm58NtgIYJAA0nA2gYEKDhIWy4aICOBPwwgXVZAXL2HmiE6flIG6ARAkAjyQAaAQRoZAgbLhqgowE/TGBdVoCcvQcaZXo+2gZolADQaDKARgEBGh3ChosG6FjADxNYlxWgBMGuCkBjTM/H2gCNEQAaSwbQGCBAY0PYcNEAPR7wwwTWZQUoUbCrAtA40/PxNkDjBIDGkwE0DgjQ+BA2XDRATwT8MIF1WQFKEuyqADTB9HyiDdAEAaCJZABNAAI0MYQNFw3QkwE/TGBdVoCcvQeaZHp+gw3QJAGgG8gAmgQE6IYQNlw0QE8F/DCBdVkBcvYeaLLp+RQboMkCQFPIAJoMBGhKCBsuGqDjAT9MYF1WgJy9B5pqej7NBmiqANA0MoCmAgGaFsKGiwboRMAPE1iXFKBEZ++Bppuez7ABmi4ANIMMoOlAgGaEsOGiAToZ8MME1mUFyNl7oJmm5zfaAM0UALqRDKCZQIBuDGHDRQP0dMAPE1iXFSBn74FmmZ7PtgGaJQA0mwygWUCAZoew4aIBeibghwmsywqQs/dAc0zP59oAzREAmksG0BwgQHND2HDRAD0b8MME1mUFyNl7oHmm5/NtgOYJAM0nA2geEKD5IWy4aICeC/hhAuuyAuTsPdAC0/OFNkALBIAWkgG0AAjQwhA2XDRApwJ+mMC6rAA5ew+0yPR8sQ3QIgGgxWQALQICtDiEDRcN0OmAHyawLitAzt4DLTE9X2oDtEQAaCkZQEuAAC0NYcNFA/R8wA8TWJcVIGfvgZaZni+3AVomALScDKBlQICWh7DhogF6IeCHCazLCpCz90A3mZ6vsAG6SQBoBRlANwEBWhHChosG6MWAHyawLitACYJdFYBWmp7fbAO0UgDoZjKAVgIBujmEDRcN0EsBP0xgXVaAEgW7KgDdYnp+qw3QLQJAt5IBdAsQoFtD2HDRAL0c8MME1mUFKEmwqwLQbabnt9sA3SYAdDsZQLcBAbo9hA0XDdCZgB8msC4rQM7eA60yPV9tA7RKAGg1GUCrgACtDmHDRQP0SsAPE1iXFSBn74HWmJ7fYQO0RgDoDjKA1gABuiOEDRcN0KsBP0xgXVaAnL0HWmt6vs4GaK0A0DoygNYCAVoXwoaLBui1gB8msC4pQEnO3gOtNz3fYAO0XgBoAxlA64EAbQhhw0UD9HrADxNYlxUgZ++BNpqe32kDtFEA6E4ygDYCAbozhA0XDdDZgB8msC4rQM7eA91len63DdBdAkB3kwF0FxCgu0PYcNEAvRHwwwTWZQXI2XugTabnm22ANgkAbSYDaBMQoM0hbLhogN4M+GEC67IC5Ow90BbT8602QFsEgLaSAbQFCNDWEDZcNEBvBfwwgXVZAXL2Huge0/N7bYDuEQC6lwyge4AA3RvChosG6FzADxNYlxUgZ++Btpmeb7cB2iYAtJ0MoG1AgLaHsOGiATof8MME1mUFyNl7oB2m5zttgHYIAO0kA2gHEKCdIWy4aIDeDvhhAuuyAuTsPdAu0/PdNkC7BIB2kwG0CwjQ7hA2XDRA7wT8MIF1WQFy9h5oj+n5XhugPQJAe8kA2gMEaG8IGy4aoHcDfpjAuqwAJQh2VQC6z/T8fhug+wSA7icD6D4gQPeHsOGiAXov4IcJrMsKUKJgVwWgfabn+22A9gkA7ScDaB8QoP0hbLhogC4E/DCBdVkBShLsqgB0wPT8oA3QAQGgg2QAHQACdDCEDRcN0PsBP0xgXVaAnL0HesD0/EEboAcEgB4kA+gBIEAPhrDhogH6IOCHCazLCpCz90APmZ4fsgF6SADoEBlADwEBOhTChosG6MOAHyawLitAzt4DHTY9f9gG6LAA0MNkAB0GAvRwCBsuGqCPAn6YwLqkAA129h7oEdPzR22AHhEAepQMoEeAAD0awoaLBujjgB8msC4rQM7eAz1men7EBugxAaAjZAA9BgToSAgbLhqgTwJ+mMC6rAA5ew901PT8mA3QUQGgY2QAHQUCdCyEDRcN0KcBP0xgXVaAnL0Hetz0/AkboMcFgJ4gA+hxIEBPhLDhogH6LOCHCazLCpCz90BPmp4/ZQP0pADQU2QAPQkE6KkQNlw0QJ8H/DCBdVkBcvYe6Ljp+QkboOMCQCfIADoOBOhECBsuGqAvAn6YwLqsADl7D3TS9PxpG6CTAkBPkwF0EgjQ0yFsuGiAvgz4YQLrsgLk7D3QM6bnz9oAPSMA9CwZQM8AAXo2hA0XDdBXAT9MYF1WgJy9B3rO9PyUDdBzAkCnyAB6DgjQqRA2XDRAXwf8MIF1WQFy9h7otOn58zZApwWAnicD6DQQoOdD2HDRAH0T8MME1mUFKEGwqwLQC6bnL9oAvSAA9CIZQC8AAXoxhA0XDdDFgB8msC4rQImCXRWAXjI9f9kG6CUBoJfJAHoJCNDLIWy4aIC+DfhhAuuyApQk2FUB6Izp+Ss2QGcEgF4hA+gMEKBXQthw0QB9F/DDBNZlBcjZe6BXTc9fswF6VQDoNTKAXgUC9FoIGy4aoO8DfpjAuqwAOXsP9Lrp+VkboNcFgM6SAfQ6EKCzIWy4aIB+CPhhAuuyAuTsPdAbpudv2gC9IQD0JhlAbwABejOEDRcN0I8BP0xgXVKAhjh7D/SW6fk5G6C3BIDOkQH0FhCgcyFsuGiAfgr4YQLrsgLk7D3QedPzt22AzgsAvU0G0HkgQG+HsOGiAfo54IcJrMsKkLP3QO+Ynr9rA/SOANC7ZAC9AwTo3RA2XDRAvwT8MIF1WQFy9h7oPdPzCzZA7wkAXSAD6D0gQBdC2HDRAP0a8MME1mUFyNl7oPdNzz+wAXpfAOgDMoDeBwL0QQgbLhqg3wJ+mMC6rAA5ew/0oen5RzZAHwoAfUQG0IdAgD4KYcNFA/R7wA8TWJcVIGfvgT42Pf/EBuhjAaBPyAD6GAjQJyFsuGiALgX8MIF1WQFy9h7oU9Pzz2yAPhUA+owMoE+BAH0WwoaLBuhywA8TWJcVIGfvgT43Pf/CBuhzAaAvyAD6HAjQFyFsuGiA/gj4YQLrsgLk7D3Ql6bnX9kAfSkA9BUZQF8CAfoqhA0XDdCVgB8msC4rQAmCXRWAvjY9/8YG6GsBoG/IAPoaCNA3IWy4aID+DPhhAuuyApQo2FUB6KLp+bc2QBcFgL4lA+giEKBvQ9hw0QB5J/zivwCl9DhJsKsC0Hem59/bAH0nAPQ9GUDfAQH6PoQNFw1QIOiHCazLCpCz90A/mJ7/aAP0gwDQj2QA/QAE6McQNlw0QMGgHyawLitAzt4D/WR6/rMN0E8CQD+TAfQTEKCfQ9hw0QClDfphAuuyAuTsPdAvpue/2gD9IgD0KxlAvwAB+jWEDRcNULqgHyawLilAQ529B/rN9Px3G6DfBIB+JwPoNyBAv4ew4aIBSh/0wwTWZQXI2XugS6bnl22ALgkAXSYD6BIQoMshbLhogDIE/TCBdVkBcvYe6A/T8ys2QH8IAF0hA+gPIEBXQthw0QBlDPphAuuyAuTsPdCfKT2PS/M/YflTAMj7HxW2TEUzQH8CAfK+dmS4aIBighFhpvnHA+TsPVAg7q9/Bm2AvH9hAxQkAygQh/MVjMOGiwYoNuiHCazLCpCz90BpTc/T2QClFQBKRwZQWiBA6eKw4aIBCgX9MIF1WQFy9h4ovel5Bhug9AJAGcgASg8EKEMcNlw0QHFBP0xgXVaAnL0Hymh6HmMDlFEAKIYMoIxAgGLisOGiAYoP+mEC67IC5Ow9UKzpecgGKFYAKEQGUCwQoFAcNlw0QJmCfpjAuqwAOXsPFGd6Hm8DFCcAFE8GUBwQoPg4bLhogDIH/TCBdVkBShDsqgCUyfQ8sw1QJgGgzGQAZQIClDkOGy4aoCxBP0xgXVaAEgW7KgBlMT3PagOURQAoKxlAWYAAZY3DhosGKGvQDxNYlxWgJMGuCkDXmZ5nswG6TgAoGxlA1wEByhaHDRcN0HVBP0xgXVaAnL0Hut70PLsN0PUCQNnJALoeCFD2OGy4aICyBf0wgXVZAXL2HiiH6XlOG6AcAkA5yQDKAQQoZxw2XDRA1wf9MIF1WQFy9h4ol+l5bhugXAJAuckAygUEKHccNlw0QNmDfpjAupwAVans7D1QHtPzvDZAeQSA8pIBlAcIUN44bLhogHIE/TCBdVkBcvYeKJ/peX4boHwCQPnJAMoHBCh/HDZcNEA5g36YwLqsADl7D1TA9LygDVABAaCCZAAVAAJUMA4bLhqgXEE/TGBdVoCcvQcqZHpe2AaokABQYTKACgEBKhyHDRcNUO6gHyawLitAzt4DFTE9L2oDVEQAqCgZQEWAABWNw4aLBihP0A8TWJcVIGfvgYqZnhe3ASomAFScDKBiQICKx2HDRQOUN+iHCazLCpCz90AlTM9L2gCVEAAqSQZQCSBAJeOw4aIByhf0wwTWZQXI2XugUqbnpW2ASgkAlSYDqBQQoNJx2HDRAOUP+mEC67IC5Ow9UBnT87I2QGUEgMqSAVQGCFDZOGy4aIAKBP0wgXVZAXL2Hqic6Xl5G6ByAkDlyQAqBwSofBw2XDRABYN+mMC6rAAlCHZVAKpgel7RBqiCAFBFMoAqAAGqGIcNFw1QoaAfJrAuK0CJgl0VgCqZnle2AaokAFSZDKBKQIAqx2HDRQNUOOiHCazLClCSYFcFoLDpeRUboLAAUBUygMJAgKrEYcNFA1Qk6IcJrMsKkLP3QFVNz6vZAFUVAKpGBlBVIEDV4rDhogEqGvTDBNZlBcjZe6Dqpuc1bICqCwDVIAOoOhCgGnHYcNEAFQv6YQLrsgLk7D1QTdPzWjZANQWAapEBVBMIUK04bLhogIoH/TCBdUkBCjt7D1Tb9LyODVBtAaA6ZADVBgJUJw4bLhqgEkE/TGBdVoCcvQeqa3pezwaorgBQPTKA6gIBqheHDRcNUMmgHyawLitAzt4D1Tc9b2ADVF8AqAEZQPWBADWIw4aLBqhU0A8TWJcVIGfvgRqanjeyAWooANSIDKCGQIAaxWHDRQNUOuiHCazLCpCz90CNTc+b2AA1FgBqQgZQYyBATeKw4aIBKhP0wwTWZQXI2XugpqbnzWyAmgoANSMDqCkQoGZx2HDRAJUN+mEC67IC5Ow9UHPT8xY2QM0FgFqQAdQcCFCLOGy4aIDKBf0wgXVZAXL2Hqil6XkrG6CWAkCtyABqCQSoVRw2XDRA5YN+mMC6rAA5ew/U2vS8jQ1QawGgNmQAtQYC1CYOGy4aoApBP0xgXVaAnL0Hamt63s4GqK0AUDsygNoCAWoXhw0XDVDFoB8msC4rQAmCXRWA2pued7ABai8A1IEMoPZAgDrEYcNFA1Qp6IcJrMsKUKJgVwWgjqbnnWyAOgoAdSIDqCMQoE5x2HDRAHmpdvwXoJQeJwl2VQDqbHrexQaoswBQFzKAOgMB6hKHDRcNUDjohwmsywqQs/dAXU3Pu9kAdRUA6kYGUFcgQN3isOGiAaoS9MME1mUFyNl7oO6m5z1sgLoLAPUgA6g7EKAecdhw0QBVDfphAuuyAuTsPVBP0/NeNkA9BYB6kQHUEwhQrzhsuGiAqgX9MIF1SQGq4uw9UG/T8z42QL0FgPqQAdQbCFCfOGy4aICqB/0wgXVZAXL2Hqiv6Xk/G6C+AkD9yADqCwSoXxw2XDRANYJ+mMC6rAA5ew/U3/R8gA1QfwGgAWQA9QcCNCAOGy4aoJpBP0xgXVaAnL0HGmh6PsgGaKAA0CAygAYCARoUhw0XDVCtoB8msC4rQM7eAyWYnifaACUIACWSAeR9DShfiXHYcNEA1Q76YQLrsgLk7D1Qkun5YBugJAGgwWQAJQEBGhyHDRcNUJ2gHyawLitAzt4DDTE9H2oDNEQAaCgZQEOAAA2Nw4aLBqhu0A8TWJcVIGfvgYaZng+3ARomADScDKBhQICGx2HDRQNUL+iHCazLCpCz90AjTM9H2gCNEAAaSQbQCCBAI+Ow4aIBqh/0wwTWZQXI2XugUabno22ARgkAjSYDaBQQoNFx2HDRADUI+mEC67IClCDYVQFojOn5WBugMQJAY8kAGgMEaGwcNlw0QA2DfpjAuqwAJQp2VQAaZ3o+3gZonADQeDKAxgEBGh+HDRcNUKOgHyawLitASYJdFYAmmJ5PtAGaIAA0kQygCUCAJsZhw0UD1DjohwmsywqQs/dAk0zPb7ABmiQAdAMZQJOAAN0Qhw0XDVCToB8msC4rQM7eA002PZ9iAzRZAGgKGUCTgQBNicOGiwaoadAPE1iXFSBn74Gmmp5PswGaKgA0jQygqUCApsVhw0UD1CzohwmsSwpQVWfvgaabns+wAZouADSDDKDpQIBmxGHDRQPUPOiHCazLCpCz90AzTc9vtAGaKQB0IxlAM4EA3RiHDRcNUIugHyawLitAzt4DzTI9n20DNEsAaDYZQLOAAM2Ow4aLBqhl0A8TWJcVIGfvgeaYns+1AZojADSXDKA5QIDmxmHDRQPUKuiHCazLCpCz90DzTM/n2wDNEwCaTwbQPCBA8+Ow4aIBah30wwTWZQXI2XugBabnC22AFggALSQDaAEQoIVx2HDRALUJ+mEC67IC5Ow90CLT88U2QIsEgBaTAbQICNDiOGy4aIDaBv0wgXVZAXL2HmiJ6flSG6AlAkBLyQBaAgRoaRw2XDRA7YJ+mMC6rAA5ew+0zPR8uQ3QMgGg5WQALQMCtDwOGy4aoPZBP0xgXVaAnL0Husn0fIUN0E0CQCvIALoJCNCKOGy4aIA6BP0wgXVZAUoQ7KoAtNL0/GYboJUCQDeTAbQSCNDNcdhw0QB1DPphAuuyApQo2FUB6BbT81ttgG4RALqVDKBbgADdGocNFw1Qp6AfJrAuK0BJgl0VgG4zPb/dBug2AaDbyQC6DQjQ7XHYcNEAdQ76YQLrsgLk7D3QKtPz1TZAqwSAVpMBtAoI0Oo4bLhogLoE/TCBdVkBcvYeaI3p+R02QGsEgO4gA2gNEKA74rDhogHqGvTDBNZlBcjZe6C1pufrbIDWCgCtIwNoLRCgdXHYcNEAdQv6YQLrkgJUzdl7oPWm5xtsgNYLAG0gA2g9EKANcdhw0QB1D/phAuuyAuTsPdBG0/M7bYA2CgDdSQbQRiBAd8Zhw0UD1CPohwmsywqQs/dAd5me320DdJcA0N1kAN0FBOjuOGy4aIB6Bv0wgXVZAXL2HmiT6flmG6BNAkCbyQDaBARocxw2XDRAvYJ+mMC6rAA5ew+0xfR8qw3QFgGgrWQAbQECtDUOGy4aoN5BP0xgXVaAnL0Husf0/F4boHsEgO4lA+geIED3xmHDRQPUJ+iHCazLCpCz90DbTM+32wBtEwDaTgbQNiBA2+Ow4aIB6hv0wwTWZQXI2XugHabnO22AdggA7SQDaAcQoJ1x2HDRAPUL+mEC67IC5Ow90C7T8902QLsEgHaTAbQLCNDuOGy4aID6B/0wgXVZAXL2HmiP6fleG6A9AkB7yQDaAwRobxw2XDRAA4J+mMC6rAAlCHZVALrP9Px+G6D7BIDuJwPoPiBA98dhw0UDNDDohwmsywpQomBXBaB9puf7bYD2CQDtJwNoHxCg/XHYcNEADQr6YQLrsgKUJNhVAeiA6flBG6ADAkAHyQA6AAToYBw2XDRACUE/TGBdVoCcvQd6wPT8QRugBwSAHiQD6AEgQA/GYcNFA5QY9MME1mUFyNl7oIdMzw/ZAD0kAHSIDKCHgAAdisOGiwYoKeiHCazLCpCz90CHTc8ftgE6LAD0MBlAh4EAPRyHDRcN0OCgHyawLilA1Z29B3rE9PxRG6BHBIAeJQPoESBAj8Zhw0UDNCTohwmsywqQs/dAj5meH7EBekwA6AgZQI8BAToShw0XDdDQoB8msC4rQM7eAx01PT9mA3RUAOgYGUBHgQAdi8OGiwZoWNAPE1iXFSBn74EeNz1/wgbocQGgJ8gAehwI0BNx2HDRAA0P+mEC67IC5Ow90JOm50/ZAD0pAPQUGUBPAgF6Kg4bLhqgEUE/TGBdVoCcvQc6bnp+wgbouADQCTKAjgMBOhGHDRcN0MigHyawLitAzt4DnTQ9f9oG6KQA0NNkAJ0EAvR0HDZcNECjgn6YwLqsADl7D/SM6fmzNkDPCAA9SwbQM0CAno3DhosGaHTQDxNYlxUgZ++BnjM9P2UD9JwA0CkygJ4DAnQqDhsuGqAxQT9MYF1WgJy9Bzptev68DdBpAaDnyQA6DQTo+ThsuGiAxgb9MIF1WQFKEOyqAPSC6fmLNkAvCAC9SAbQC0CAXozDhosGaFzQDxNYlxWgRMGuCkAvmZ6/bAP0kgDQy2QAvQQE6OU4bLhogMYH/TCBdVkBShLsqgB0xvT8FRugMwJAr5ABdAYI0Ctx2HDRAE0I+mEC67IC5Ow90Kum56/ZAL0qAPQaGUCvAgF6LQ4bLhqgiUE/TGBdVoCcvQd63fT8rA3Q6wJAZ8kAeh0I0Nk4bLhogCYF/TCBdVkBcvYe6A3T8zdtgN4QAHqTDKA3gAC9GYcNFw3QDUE/TGBdUoBqOHsP9Jbp+TkboLcEgM6RAfQWEKBzcdhw0QBNDvphAuuyAuTsPdB50/O3bYDOCwC9TQbQeSBAb8dhw0UDNCXohwmsywqQs/dA75iev2sD9I4A0LtkAL0DBOjdOGy4aICmBv0wgXVZAXL2Hug90/MLNkDvCQBdIAPoPSBAF+Kw4aIBmhb0wwTWZQXI2Xug903PP7ABel8A6AMygN4HAvRBHDZcNEDTg36YwLqsADl7D/Sh6flHNkAfCgB9RAbQh0CAPorDhosGaEbQDxNYlxUgZ++BPjY9/8QG6GMBoE/IAPoYCNAncdhw0QDNDPphAuuyAuTsPdCnpuef2QB9KgD0GRlAnwIB+iwOGy4aoBuDfpjAuqwAOXsP9Lnp+Rc2QJ8LAH1BBtDnQIC+iMOGiwZoVtAPE1iXFSBn74G+ND3/ygboSwGgr8gA+hII0Fdx2HDRAM0O+mEC67IClCDYVQHoa9Pzb2yAvhYA+oYMoK+BAH0Thw0XDdCcoB8msC4rQImCXRWALpqef2sDdFEA6FsygC4CAfo2DhsuGqC5QT9MYF1WgJIEuyoAfWd6/r0N0HcCQN+TAfQdEKDv47DhogGaF/TDBNZlBcjZe6AfTM9/tAH6QQDoRzKAfgAC9GMcNlw0QPODfpjAuqwAOXsP9JPp+c82QD8JAP1MBtBPQIB+jsOGiwZoQdAPE1iXFSBn74F+MT3/1QboFwGgX8kA+gUI0K9x2HDRAC0M+mEC65ICVNPZe6DfTM9/twH6TQDodzKAfgMC9HscNlw0QIuCfpjAuqwAOXsPdMn0/LIN0CUBoMtkAF0CAnQ5DhsuGqDFQT9MYF1WgJy9B/rD9PyKDdAfAkBXyAD6AwjQlThsuGiAlgT9MIF1WQFy9h7oz5Sex6f5n7D8KQDk/Y8KW6aiGaA/gQB5XzsyXDRAS4MRYab5xwPk7D1QIP6vfwZtgLx/YQMUJAMoEI/zFYzHhosGaFnQDxNYlxUgZ++B0pqep7MBSisAlI4MoLRAgNLFY8NFA7Q86IcJrMsKkLP3QOlNzzPYAKUXAMpABlB6IEAZ4rHhogG6KeiHCazLCpCz90AZTc9jbIAyCgDFkAGUEQhQTDw2XDRAK4J+mMC6rAA5ew8Ua3oesgGKFQAKkQEUCwQoFI8NFw3QyqAfJrAuK0DO3gPFmZ7H2wDFCQDFkwEUBwQoPh4bLhqgm4N+mMC6rAAlCHZVAMpkep7ZBiiTAFBmMoAyAQHKHI8NFw3QLUE/TGBdVoASBbsqAGUxPc9qA5RFACgrGUBZgABljceGiwbo1qAfJrAuK0BJgl0VgK4zPc9mA3SdAFA2MoCuAwKULR4bLhqg24J+mMC6rAA5ew90vel5dhug6wWAspMBdD0QoOzx2HDRAN0e9MME1mUFyNl7oBym5zltgHIIAOUkAygHEKCc8dhw0QCtCvphAuuyAuTsPVAu0/PcNkC5BIBykwGUCwhQ7nhsuGiAVgf9MIF1SQGq5ew9UB7T87w2QHkEgPKSAZQHCFDeeGy4aIDWBP0wgXVZAXL2Hiif6Xl+G6B8AkD5yQDKBwQofzw2XDRAdwT9MIF1WQFy9h6ogOl5QRugAgJABckAKgAEqGA8Nlw0QGuDfpjAuqwAOXsPVMj0vLANUCEBoMJkABUCAlQ4HhsuGqB1QT9MYF1WgJy9Bypiel7UBqiIAFBRMoCKAAEqGo8NFw3Q+qAfJrAuK0DO3gMVMz0vbgNUTACoOBlAxYAAFY/HhosGaEPQDxNYlxUgZ++BSpiel7QBKiEAVJIMoBJAgErGY8NFA7Qx6IcJrMsKkLP3QKVMz0vbAJUSACpNBlApIECl47HhogG6M+iHCazLCpCz90BlTM/L2gCVEQAqSwZQGSBAZeOx4aIBuivohwmsywqQs/dA5UzPy9sAlRMAKk8GUDkgQOXjseGiAbo76IcJrMsKUIJgVwWgCqbnFW2AKggAVSQDqAIQoIrx2HDRAG0K+mEC67IClCjYVQGokul5ZRugSgJAlckAqgQEqHI8Nlw0QJuDfpjAuqwAJQl2VQAKm55XsQEKCwBVIQMoDASoSjw2XDRAW4J+mMC6rAA5ew9U1fS8mg1QVQGgamQAVQUCVC0eGy4aoK1BP0xgXVaAnL0Hqm56XsMGqLoAUA0ygKoDAaoRjw0XDdA9QT9MYF1WgJy9B6ppel7LBqimAFAtMoBqAgGqFY8NFw3QvUE/TGBdUoBqO3sPVNv0vI4NUG0BoDpkANUGAlQnHhsuGqBtQT9MYF1WgJy9B6prel7PBqiuAFA9MoDqAgGqF48NFw3Q9qAfJrAuK0DO3gPVNz1vYANUXwCoARlA9YEANYjHhosGaEfQDxNYlxUgZ++BGpqeN7IBaigA1IgMoIZAgBrFY8NFA7Qz6IcJrMsKkLP3QI1Nz5vYADUWAGpCBlBjIEBN4rHhogHaFfTDBNZlBcjZe6CmpufNbICaCgA1IwOoKRCgZvHYcNEA7Q76YQLrsgLk7D1Qc9PzFjZAzQWAWpAB1BwIUIt4bLhogPYE/TCBdVkBcvYeqKXpeSsboJYCQK3IAGoJBKhVPDZcNEB7g36YwLqsADl7D9Ta9LyNDVBrAaA2ZAC1BgLUJh4bLhqg+4J+mMC6rAA5ew/U1vS8nQ1QWwGgdmQAtQUC1C4eGy4aoPuDfpjAuqwAJQh2VQBqb3rewQaovQBQBzKA2gMB6hCPDRcN0L6gHyawLitAiYJdFYA6mp53sgHqKADUiQygjkCAOsVjw0UDtD/ohwmsywpQkmBXBaDOpuddbIA6CwB1IQOoMxCgLvHYcNEAHQj6YQLrsgLk7D1QV9PzbjZAXQWAupEB1BUIULd4bLhogA4G/TCBdVkBcvYeqLvpeQ8boO4CQD3IAOoOBKhHPDZcNEAPBP0wgXVZAXL2Hqin6XkvG6CeAkC9yADqCQSoVzw2XDRADwb9MIF1SQFKcPYeqLfpeR8boN4CQH3IAOoNBKhPPDZcNEAPBf0wgXVZAXL2Hqiv6Xk/G6C+AkD9yADqCwSoXzw2XDRAh4J+mMC6rAA5ew/U3/R8gA1QfwGgAWQA9QcCNCAeGy4aoMNBP0xgXVaAnL0HGmh6PsgGaKAA0CAygAYCARoUjw0XDdDDQT9MYF1WgJy9B0owPU+0AUoQAEokAygBCFBiPDZcNECPBP0wgXVZAXL2HijJ9HywDVCSANBgMoCSgAANjseGiwbo0aAfJrAuK0DO3gMNMT0fagM0RABoKBlAQ4AADY3HhosG6LGgHyawLitAzt4DDTM9H24DNEwAaDgZQMOAAA2Px4aLBuhI0A8TWJcVIGfvgUaYno+0ARohADSSDKARQIBGxmPDRQN0NOiHCazLCpCz90CjTM9H2wCNEgAaTQbQKCBAo+Ox4aIBOhb0wwTWZQUoQbCrAtAY0/OxNkBjBIDGkgE0BgjQ2HhsuGiAHg/6YQLrsgKUKNhVAWic6fl4G6BxAkDjyQAaBwRofDw2XDRATwT9MIF1WQFKEuyqADTB9HyiDdAEAaCJZABNAAI0MR4bLhqgJ4N+mMC6rAA5ew80yfT8BhugSQJAN5ABNAkI0A3x2HDRAD0V9MME1mUFyNl7oMmm51NsgCYLAE0hA2gyEKAp8dhw0QAdD/phAuuyAuTsPdBU0/NpNkBTBYCmkQE0FQjQtHhsuGiATgT9MIF1SQFKdPYeaLrp+QwboOkCQDPIAJoOBGhGPDZcNEAng36YwLqsADl7DzTT9PxGG6CZAkA3kgE0EwjQjfHYcNEAPR30wwTWZQXI2XugWabns22AZgkAzSYDaBYQoNnx2HDRAD0T9MME1mUFyNl7oDmm53NtgOYIAM0lA2gOEKC58dhw0QA9G/TDBNZlBcjZe6B5pufzbYDmCQDNJwNoHhCg+fHYcNEAPRf0wwTWZQXI2XugBabnC22AFggALSQDaAEQoIXx2HDRAJ0K+mEC67IC5Ow90CLT88U2QIsEgBaTAbQICNDieGy4aIBOB/0wgXVZAXL2HmiJ6flSG6AlAkBLyQBaAgRoaTw2XDRAzwf9MIF1WQFy9h5omen5chugZQJAy8kAWgYEaHk8Nlw0QC8E/TCBdVkBcvYe6CbT8xU2QDcJAK0gA+gmIEAr4rHhogF6MeiHCazLClCCYFcFoJWm5zfbAK0UALqZDKCVQIBujseGiwbopaAfJrAuK0CJgl0VgG4xPb/VBugWAaBbyQC6BQjQrfHYcNEAvRz0wwTWZQUoSbCrAtBtpue32wDdTgbLbUBYbo/XCRJ94G6LxwGYLiL/FK9HLGrQ0OfA1aqs5TEngcdcBB5zE3jMQ+AxL4HHfAQe8xN4LEDgsSCBx0IEHgsTeCxC4LEogcdiBB6LE3gsQeCxJIHHUgQeSxN4LEPgsSyBx3IEHssTeKxA4LEigcdKBB4rE3gME3isQuCxKoHHagQeqxN4rEHgsSaBx1oEHmsTeKxD4LEugcd6BB7rE3hsQOCxIYHHRgQeGxN4bELgsSmBx2YEHpsTeGxB4LElgcdWBB5bE3hsQ+CxLYHHdgQe2xN47EDgsSOBx04EHjsTeOxC4LErgcduBB67E3jsQeCxJ4HHXgQeexN47EPgsS+Bx34EHvsTeBxA4HEggcdBBB4TCDwmEnhMIvA4mMDjEAKPQwk8DiPwOJzA4wgCjyMJPI4i8DiawOMYAo9jCTyOI/A4nsDjBAKPEwk8TiLweAOBx8kEHqcQeJxK4HEagcfpBB5nEHicSeDxRgKPswg8zibwOIfA41wCj/MIPM4n8LiAwONCAo+LCDwuJvC4hMDjUgKPywg8LifweBOBxxUEHlcSeLyZwOMtBB5vJfB4G4HH2wk8riLwuJrA4xoCj3cQeFxL4HEdgcf1BB43EHjcSODxTgKPdxF4vJvA4yYCj5sJPG4h8LiVwOM9BB7vJfC4jcDjdgKPOwg87iTwuIvA424Cj3sIPO4l8Hgfgcf7CTzuI/C4n8DjAQKPBwk8PkDg8UECjw8ReDxE4PEwgceHCTw+QuDxUQKPjxF4PELg8SiBx2MEHh8n8PgEgccnCTw+ReDxOIHHEwQeTxJ4fJrA4zMEHp8l8PgcgcdTBB5PE3h8nsDjCwQeXyTw+BKBx5cJPJ4h8PgKgcdXCTy+RuDxdQKPZwk8vkHg8U0Cj28ReDxH4PE8gce3CTy+Q+DxXQKP7xF4vEDg8X0Cjx8QePyQwONHBB4/JvD4CYHHTwk8fkbg8XMCj18QePySwONXBB6/JvD4DYHHiwQevyXw+B2Bx+8JPP5A4PFHAo8/EXj8mcDjLwQefyXw+BuBx98JPF4i8HiZwOMfBB6vEHj8k8CjVzDaPQYIPAYJPKYl8JiOwGN6Ao8ZCDxmJPAYQ+AxlsBjiMBjHIHHeAKPmQg8ZibwmIXAY1YCj9cReMxG4PF6Ao/ZCTzmIPCYk8BjLgKPuQk85iHwmJfAYz4Cj/kJPBYg8FiQwGMhAo+FCTwWIfBYlMBjMQKPxQk8liDwWJLAYykCj6UJPJYh8FiWwGM5Ao/lCTxWIPBYkcBjJQKPlQk8hgk8ViHwWJXAYzUCj9UJPNYg8FiTwGMtAo+1CTzWIfBYl8BjPQKP9Qk8NiDw2JDAYyMCj40JPDYh8NiUwGMzAo/NCTy2IPDYksBjKwKPrQk8tiHw2JbAYzsCj+0JPHYg8NiRwGMnAo+dCTx2IfDYlcBjNwKP3Qk89iDw2JPAYy8Cj70JPPYh8NiXwGM/Ao/9CTwOIPA4kMDjIAKPCQQeEwk8JhF4HEzgcQiBx6EEHocReBxO4HEEgceRBB5HEXgcTeBxDIHHsQQexxF4HE/gcQKBx4kEHicReLyBwONkAo9TCDxOJfA4jcDjdAKPMwg8ziTweCOBx1kEHmcTeJxD4HEugcd5BB7nE3hcQOBxIYHHRQQeFxN4XELgcSmBx2UEHpcTeLyJwOMKAo8rCTzeTODxFgKPtxJ4vI3A4+0EHlcReFxN4HENgcc7CDyuJfC4jsDjegKPGwg8biTweCeBx7sIPN5N4HETgcfNBB63EHjcSuDxHgKP9xJ43EbgcTuBxx0EHncSeNxF4HE3gcc9BB73Eni8j8Dj/QQe9xF43E/g8QCBx4MEHh8g8PgggceHCDweIvB4mMDjwwQeHyHw+CiBx8cIPB4h8HiUwOMxAo+PE3h8gsDjkwQenyLweJzA4wkCjycJPD5N4PEZAo/PEnh8jsDjKQKPpwk8Pk/g8QUCjy8SeHyJwOPLBB7PEHh8hcDjqwQeXyPw+DqBx7MEHt8g8Pgmgce3CDyeI/B4nsDj2wQe3yHw+C6Bx/cIPF4g8Pg+gccPCDx+SODxIwKPHxN4/ITA46cEHj8j8Pg5gccvCDx+SeDxKwKPXxN4/IbA40UCj98SePyOwOP3BB5/IPD4I4HHnwg8/kzg8RcCj78SePyNwOPvBB4vEXi8TODxDwKPVwg8/kngMU0w+j0GCDwGCTymJfCYjsBjegKPGQg8ZiTwGEPgMZbAY4jAYxyBx3gCj5kIPGYm8JiFwGNWAo/XEXjMRuDxegKP2Qk85iDwmJPAYy4Cj7kJPOYh8JiXwGM+Ao/5CTwWIPBYkMBjIQKPhQk8FiHwWJTAYzECj8UJPJYg8FiSwGMpAo+lCTyWIfBYlsBjOQKP5Qk8ViDwWJHAYyUCj5UJPIYJPFYh8FiVwGM1Ao/VCTzWIPBYk8BjLQKPtQk81iHwWJfAYz0Cj/UJPDYg8NiQwGMjAo+NCTw2IfDYlMBjMwKPzQk8tiDw2JLAYysCj60JPLYh8NiWwGM7Ao/tCTx2IPDYkcBjJwKPnQk8diHw2JXAYzcCj90JPPYg8NiTwGMvAo+9CTz2IfDYl8BjPwKP/Qk8DiDwOJDA4yACjwkEHhMJPCYReBxM4HEIgcehBB6HEXgcTuBxBIHHkQQeRxF4HE3gcQyBx7EEHscReBxP4HECgceJBB4nEXi8gcDjZAKPUwg8TiXwOI3A43QCjzMIPM4k8HgjgcdZBB5nE3icQ+BxLoHHeQQe5xN4XEDgcSGBx0UEHhcTeFxC4HEpgcdlBB6XE3i8icDjCgKPKwk83kzg8RYCj7cSeLyNwOPtBB5XEXhcTeBxDYHHOwg8riXwuI7A43oCjxsIPG4k8Hgngce7CDzeTeBxE4HHzQQetxB43Erg8R4Cj/cSeNxG4HE7gccdBB53EnjcReBxN4HHPQQe9xJ4vI/A4/0EHvcReNxP4PEAgceDBB4fIPD4IIHHhwg8HiLweJjA48MEHh8h8PgogcfHCDweIfB4lMDjMQKPjxN4fILA45MEHp8i8HicwOMJAo8nCTw+TeDxGQKPzxJ4fI7A4ykCj6cJPD5P4PEFAo8vEnh8icDjywoeNXzmzqjjMw3Wp/f/zue/v/6s5s+r4tOkWZ38e03y7zuSf69N/r0u+ff65N8bkn9vTP59Z/Lvu5J/3538e1Py783Jv7ck/94a/1eNe+JN0bTmn17Rwpa2WtDWCNodgrZW0NYJ2npB2yBoGwXtTkG7S9DuFrRNgrZZ0LYI2lZBu8doKWFFHoKqlWtUqzakZpUh4arhhMpVaifWql65WvXEGrXCtcLVa1UfXKVW1apDalWrVbN2Yu2alWuHq1UdEh5avXbVIUO9X5XDOZJr5Ek+sEHk4QpXrpwD4HGoKXdvPO7QR/b13oi+BkF9TfGcM7lGvoy4el4tz29aZE7JSeUE1orM6Vq/3m1KmW9TZCklc2hG4b/OEqoWMqPtShltV+QyV3KNAkAuvVrbFbjMBay1HZj5DqXMd0RknvIrLTj7POB5jKq1E9fTqpH9Q7OD5GYX7msOp0mj8MNgyf48j6g7IuXr3q3Ez+5/MD97cD2tIp2la90LUu4c9F6QC1gLeUfsVTrjexX3gtzJNQoBz6RXa6/CXpAbWGsvMPP7lDK/7yr7euVr+xX2mNyjMOOLd8V+AMRyt5UAf90pv9D32P3A3QOYdRjYv3Bk/9CzEjkn90X5HuidlX0KrOxXmpf7HeyBB1I/P+LcRe0Y/5Sd4GC8zn2AnmfI72seAM8zja91FTjjB+IV/gMY8bosV76WX+G/+nhQ4V54UOleeFDxe6c8yTWKABnyaj2o8L1THmCtB4EMPaSU+UOK3zt599gBhfNfLsq/d9LaB8uTfO90CHi/AbMOlyf53gk5Jw9H+fdO3lk5rMDKw0rz8mEH3zs9kvr5gX7vlPIZesqOgf4MPQ+wFnIneFTpjD+quAfmTa5RDDjfvFqPKuyBeYG1HgVm/phS5o8p7oEek48ozPjKUb4Hat1tYZI98AjwHgNmHQ6T7IHIOXk0yvdA76wcVWDlmNK8POZgD3w89fOjsgem7BjoPTAvsBZyJ3hC6Yw/obgH5kuuUQI437xaTyjsgfmAtZ4AZv6kUuZPKu6BHpOPK8z46lG+B2rdbTVI9sCngPcYMOtwDZI9EDknj0f5HuidleMKrJxQmpcnHOyBJ1M/Pyp7YMqOgd4D8wFrIXeCp5XO+NOKe2D+5BqlgPPNq/W0wh6YH1jraWDmzyhl/oziHugxeVJhxteJ8j1Q626rS7IHPgu8x4BZh+uS7IHIOflclO+B3ll5ToGVU0rz8pSDPfB06udH5WdqU36e0eax8rX9CiN/RvL5+Ojv4WqFHq4G9vAFgh6uUejhGmAPXyTo4R0KPbwD2MOXCHq4VqGHa4E9fJmgh+sUergO2MMzBD1cr9DD9cAevkLQww0KPdwA7OGrBD3cqNDDjcAevkbQwzsVengnsIevE/TwLoUe3gXs4VmCHt6t0MO7gT18g6CHmxR6uAnYwzcJerhZoYebgT18i6CHWxR6uAXYw3MEPdyq0MOtwB6eB/bQ+8w1+Uv+7/9Yrfe5mve5kPe5hvd9ufd9pfd9kbfXe3upt1d5e4F3r3lz2ZsrHhderp6vlF/oz7e999APKHy+/Tawl0HTS/sXqr5Wb9+Oj36P76A9og9Syl/M/1P+Iv1dcCDogesNi3eAX69X7914Hag1/kMK7yoMy/eU/jLwPcUfmCmQXKMM8C+CvVrvKfzATAFgrfeA5/6CUuYXFH9gxpvDpxXOf+Mo/4EZrR8CaELyAzPvA//CH5h1uAnJD8wg5+QHUf4DM95Z+UCBlQ+V5uWHDn5g5qPUz4/KD06n7BjoH5wuAKyF3Ak+VjrjHyvugQWTa5QDzjev1scKe2BBYK2PgZl/opT5J4p7oMfkRwozvkWU74Fad1tLkj3wU+A9Bsw63JJkD0TOyc+ifA/0zspnCqx8rjQvP3ewB36R+vlR2QNTdgz0HlgQWAu5E3ypdMa/VNwDCyXXqACcb16tLxX2wELAWl8CM/9KKfOvFPdAj8kvFGZ82yjfA7XutnYke+DXwHsMmHW4HckeiJyT30T5HuidlW8UWLmoNC8vOtgDv039/KjsgSk7BnoPLASshdwJvlM6498p7oFe3UrA+ebV+k5hDywMrPUdMPPvlTL/XnEP9Jj8VmHGd4ryPVDrbutMsgf+ALzHgFmHO5Psgcg5+WOU74HeWflRgZWflOblTw72wJ9TPz8qczflh5aDCnVR2XaJ8h56P8so9fBav+5fgGc62nvo9e8XhZn2678/PB9G9kDL42/R/sPzhdP89c3YP+Wbp98Jfnj+N/APz//O8MPzihfOpei8cFSWaK9/lxQunMtKS/RlxQ8dtM7TH/+UBcY8aPld4TxdUTpPVxQ/uCySXCMM/Ibcq3VF4YPLIsBaV4B30Z9Kmf+pOEO83ehnhfPfK8q/cdH6MKY3yQeXaTLhegnMOtyb5INL5JwMZMJ+zWhWvLPieUSzEsykMy+9uoXT/M9faH7Spn5+VP4CO2XHQP8FdhFgLeROkE7pjKfLpLcHFvVqAOebV8vzi94DiwJrReZ0rV9veqXM02fS2wP/i0mFGd8/yvdArbttAMkemAF4jwGzDg8g2QORczJjlO+B3lnJqMBKjNK8jHGwB8amfn5U9sCUHQO9BxYF1kLuBCGlMx5S3AOLJdeoDpxvXq2Qwh5YDFgrBMw8TinzOMU90GMyVmHGJ0b5Hqh1tyWR7IHxwHsMmHU4iWQPRM7JTFG+B3pnJZMCK5mV5mVmB3tgltTPj8oemLJjoPfAYsBayJ0gq9IZz6q4BxZPrlETON+8WlkV9sDiwFpZgZlfp5T5dYp7oMdkFoUZPyzK90Ctu204yR6YDXiPAbMODyfZA5Fz8voo3wO9s3K9AivZleZldgd7YI7Uz4/az8b+ofDzOCMIHlBo/DzrSJL7JieQF2DW4ZEE5yanwuzNBZy93t3K+PAG2QMtj7nRHtEHKeWbxn/KN3l5wIEEwX3zBkZu4Nfr1fO+Zi2ovV/oyyZv6r9s1B7d5FW4bPIpLfr5HCz6+f9dXP4Dd389uMmjcJYKKJ2lAoofrJZIrlEb+IGBV6uAwgerJYC1CgDvoIJKmRdU/GDV24lyKJz/8VH+DYvWh0UTSL7RLQS8L4BZhyeQfLCKnJOFo/yDVe+sFFZgpYjSvCziYN8qmvr5UfkL9pQdA/0X7CWAtZA7QTGlM15McQ8smVyjLnC+ebWKKeyBJYG1igEzL66UeXHFPdBjsqjCjJ8c5Xug1t02hWQPLAG8x4BZh6eQ7IHIOVkyyvdA76yUVGCllNK8LOVgDyyd+vlR2QNTdgz0HlgSWAu5E5RROuNlFPfAUsk16gPnm1erjMIeWApYqwww87JKmZdV3AM9JksrzPgZUb4Hat1tM0n2wHLAewyYdXgmyR6InJPlo3wP9M5KeQVWKijNywoO9sCKqZ8flT0wZcdA74GlgLWQO0ElpTNeSXEPLJ1coyFwvnm1KinsgaWBtSoBM6+slHllxT3QY7KiwoyfE+V7oNbdNpdkDwwD7zFg1uG5JHsgck5WifI90DsrVRRYqao0L6s62AOrpX5+1B7c5Fc4S/MIHk5o/CzrfJL7pjqQF2DW4fkE56a6wrmp8e+DmzCyB1oea0b7g5uUbxr/Kd/k1SJ4cFMT/OCmFtmDm9qp/7JRe3BTW+GyqaO06NdxsOjX/Xdx+Q/c/fXgppbCWaqndJbqKX6wWia5RmPgBwZerXoKH6yWAdaqB7yD6itlXl/xg1VvJ6qmcP6XRvk3LFofFi0j+Ua3AfC+AGYdXkbywSpyTjaM8g9WvbPSUIGVRkrzspGDfatx6udH5S/YU3YM9F+wlwHWQu4ETZTOeBPFPbBsco2mwPnm1WqisAeWBdZqAsy8qVLmTRX3QI/JxgozfmWU74Fad9vNJHtgM+A9Bsw6fDPJHoick82jfA/0zkpzBVZaKM3LFg72wJapnx+VPTBlx0DvgWWBtZA7QSulM95KcQ8sl1yjOXK+ZfzLL3oPLAes1QqYeWulzFsr7oEeky0VZvztUb4Hat1tq0j2wDbAewyYdXgVyR6InJNto3wP9M5KWwVW2inNy3YO9sD2qZ8flT0wZcdA74HlgLWQO0EHpTPeQXEPLJ9coyVwvnm1OijsgeWBtToAM++olHlHxT3QY7K9woxfG+V7oNbdto5kD+wEvMeAWYfXkeyByDnZOcr3QO+sdFZgpYvSvOziYA/smvr5UXtwU1fhLK0neDih8bOsG0jum25AXoBZhzcQnJtuCuem+78PbsLIHmh57BHtD25Svmn8p3yT15PgwU0P8IObnmQPbnql/stG7cFNL4XLprfSot/bwaLf59/F5T9w99eDm54KZ6mv0lnqq/jBaoXkGq2BHxh4tfoqfLBaAVirL/AO6qeUeT/FD1a9nairwvnfHOXfsGh9WLSF5Bvd/sD7Aph1eAvJB6vIOTkgyj9Y9c7KAAVWBirNy4EO9q1BqZ8flb9gT9kx0H/BXgFYC7kTJCid8QTFPbBico22yB8gyviXX/QeWBFYKwGYeaJS5omKe6DH5CCFGb8tyvdArbttO8kemAS8x4BZh7eT7IHIOTk4yvdA76wMVmBliNK8HOJgDxya+vlR2QNTdgz0HlgRWAu5EwxTOuPDFPfASsk12gPnm1drmMIeWAlYaxgw8+FKmQ9X3AM9JocqzPjdUb4Hat1te0j2wBHAewyYdXgPyR6InJMjo3wP9M7KSAVWRinNy1EO9sDRqZ8flT0wZcdA74GVgLWQO8EYpTM+RnEP9ILvCJxvXq0xCntgZWCtMcDMxyplPlZxD/SYHK0w4/dF+R6odbftJ9kDxwHvMWDW4f0keyByTo6P8j3QOyvjFViZoDQvJzjYAyemfn7UHtz0UThLBwgeTmj8LOtBkvtmEpAXYNbhgwTnZpLCubnh3wc3YWQPtDxOjvYHNynfNP5TvsmbQvDgZjL4wc0Usgc3U1P/ZaP24GaqwmUzTWnRn+Zg0Z/+7+LyH7j768HNFIWzNEPpLM1Q/GDVg7Uz8r/QkfEvv+g7NwysNQN4B81Uynym4ger3k40UeH8Pxzl37BofVj0CMk3ujcC7wtg1uFHSD5YRc7JWVH+wap3VmYpsDJbaV7OdrBvzUn9/Kj8BXvKjoH+C/YwsBZyJ5irdMbnKu6BVZJrdAXON6/WXIU9sAqw1lxg5vOUMp+nuAd6TM5RmPFHo3wP1LrbjpHsgfOB9xgw6/Axkj0QOScXRPke6J2VBQqsLFSalwsd7IGLUj8/Kntgyo6B3gOrAGshd4LFSmd8seIeWDW5RnfgfPNqLVbYA6sCay0GZr5EKfMlinugx+QihRn/VJTvgVp323GSPXAp8B4DZh0+TrIHIufksijfA72zskyBleVK83K5gz3wptTPj8oemLJjoPfAqsBayJ1ghdIZX6G4B1ZLrtETON+8WisU9sBqwForgJmvVMp8peIe6DF5k8KMfybK90Ctu+1Zkj3wZuA9Bsw6/CzJHoick7dE+R7onZVbFFi5VWle3upgD7wt9fOj9uBmusJZeo7g4YTGz7KeIrlvbgfyAsw6fIrg3NyucG5W/fvgJozsgZbH1dH+4Cblm8Z/yjd5awge3KwGP7hZQ/bg5o7Uf9moPbi5Q+GyWau06K91sOiv+3dx+Q/c/fXgZo3CWVqvdJbWK36wWj25Rm/gBwZerfUKH6xWB9ZaD7yDNihlvkHxg1VvJ7pN4fy/HOXfsGh9WHSG5BvdjcD7Aph1+AzJB6vIOXlnlH+w6p2VOxVYuUtpXt7lYN+6O/Xzo/IX7Ck7Bvov2KsDayF3gk1KZ3yT4h5YI7lGX+B882ptUtgDawBrbQJmvlkp882Ke6DH5N0KM/71KN8Dte62syR74BbgPQbMOnyWZA9EzsmtUb4HemdlqwIr9yjNy3sc7IH3pn5+VPbAlB0DvQfWANZC7gTblM74NsU9sGZyjf7A+ebV2qawB9YE1toGzHy7UubbFfdAj8l7FWb8uSjfA7XutvMke+AO4D0GzDp8nmQPRM7JnVG+B3pnZacCK7uU5uUuB3vg7tTPj8oemLJjoPfAmsBayJ1gj9IZ36O4B9ZKrjEQON+8WnsU9sBawFp7gJnvVcp8r+Ie6DG5W2HGvxfle6DW3XaBZA+8D3iPAbMOXyDZA5Fz8v4o3wO9s3K/Aiv7lOblPgd74P7Uz4/ag5t1CmfpfYKHExo/y/oByX1zAMgLMOvwBwTn5oDCuTn474ObMLIHWh4fiPYHNynfNP5Tvsl7kODBzQPgBzcPkj24eSj1XzZqD24eUrhsDikt+occLPqH/11c/gN3fz24eVDhLD2sdJYeVvxgtXZyjQTgBwZerYcVPlitDaz1MPAOekQp80cUP1j1dqL9Cuf/syj/hkXrw6LPSb7RfRR4XwCzDn9O8sEqck4+FuUfrHpn5TEFVo4ozcsjDvato6mfH5W/YE/ZMdB/wV4bWAu5ExxTOuPHFPfAOsk1koDzzat1TGEPrAOsdQyY+eNKmT+uuAd6TB5VmPFfR/keqHW3fUOyBz4BvMeAWYe/IdkDkXPyySjfA72z8qQCK08pzcunHOyBx1M/Pyp7YMqOgd4D6wBrIXeCE0pn/ITiHlg3ucYQ4Hzzap1Q2APrAmudAGZ+Uinzk4p7oMfkcYUZ/32U74Fad9sPJHvg08B7DJh1+AeSPRA5J5+J8j3QOyvPKLDyrNK8fNbBHvhc6udHZQ9M2THQe2BdYC3kTnBK6YyfUtwD6yXXGAacb16tUwp7YD1grVPAzE8rZX5acQ/0mHxOYcb/EuV7oNbd9ivJHvg88B4DZh3+lWQPRM7JF6J8D/TOygsKrLyoNC9fdLAHvpT6+VF7cHNY4Sz9RvBwQuNnWX8nuW9eBvICzDr8O8G5eVnh3Jz598FNGNkDLY+vRPuDm5RvGv8p3+S9SvDg5hXwg5tXyR7cvJb6Lxu1BzevKVw2ryst+q87WPTP/ru4/Afu/npw86rCWXpD6Sy9ofjBav3kGiOAHxh4td5Q+GC1PrDWG8A76E2lzN9U/GDV24leUjj/abpF9zcsWh8WBbpx7B5vIT/Mw33NYWD/VD9YRc7Jc1H+wap3Vs4psHJeaV6ed7BvvZ36+VH5C/aUHQP9F+z1gbWQO8E7Smf8HcU9sEFyjVHA+ebVekdhD2wArPUOMPN3lTJ/V3EP9Jh8W2HGp4/yPVDrbstAsge+B7zHgFmHM5Dsgcg5eSHK90DvrFxQYOV9pXn5voM98IPUz4/KHpiyY6D3wAbAWsid4EOlM/6h4h7YMLnGGOB882p9qLAHNgTW+hCY+UdKmX+kuAd6TH6gMONDUb4Hat1tcSR74MfAewyYdTiOZA9EzslPonwP9M7KJwqsfKo0Lz91sAd+lvr5UdkDU3YM9B7YEFgLuRN8rnTGP1fcA70644Dzzav1ucIe2AhY63Ng5l8oZf6F4h7oMfmZwozPEuV7oNbdlpVkD/wSeI8Bsw5nJdkDkXPyqyjfA72z8pXGf6RLaV5+7WAP/Cb186P24Oaswlm6Lsq/bq2fZc1Gct9cBPICzDqcjeDcXFQ4N9/+++AmjOyBlsfvov3BjVdnXMZ/zjd53xM8uPkO/ODme7IHNz+k/stG7cHNDwqXzY9Ki/6PDhb9n/5dXP4Dd389uPle4Sz9rHSWflb8YLVxco0JwA8MvFo/K3yw2hhY62fgHfSLUua/KH6w6u1E3yic/9xR/g2L1odFeUi+0f0VeF8Asw7nIflgFTknf4vyD1a9s/Kbxn+FRWle/u5g37qU+vlR+Qv2lB0D/RfsjYG1kDvBZaUzfllxD2ySXGMScL55tS4r7IFNgLUuAzP/QynzPxT3QI/JSwozvkCU74Fad1tBkj3wCvAeA2YdLkiyByLn5J9Rvgd6Z+VPjf84Q2adeenVLZzmf/5C8xPInOr5UdkDU3YM9B7YBFgLuRMElc54MLPeHtg0ucZk4Hzzanl+0XtgU2CtyJyu9etNq5R52sx6e6DHpDfT0DO+aJTvgVp3WzGSPTAd8B4DZh0uRrIHIudk+szYrxnNindW0ivMiAxK8zKDgz0wY+rnR2UPTNkx0HtgU2At5E4Qo3TGYxT3wGbJNaYC55tXK0ZhD2wGrBUDzDxWKfNYxT3QYzKjwowvFeV7oNbdVppkDwwB7zFg1uHSJHsgck7GRfke6J2VOAVW4pXmZbyDPTBT6udH7cHNTwrff5cheDih8bOsZUnum8xAXoBZh8sSnJvMCrM3C3D2encr44MbZA+0PGZFe0QfpJRvGv8p3+RdBw4kCO6bNzCyAr9er573NWtB7f1CXzbZUv9lo/bgJpvCZXO90qJ/vYNFP/u/i8t/4O6vBzfXKZylHEpnKYfiB6vNk2tMB35g4NXKofDBanNgrRzAOyinUuY5FT9Y9XaiTArnv3KUf8Oi9WFRmOQb3VzA+wKYdThM8sEqck7mjvIPVr2zkluBlTxK8zKPg30rb+rnR+Uv2FN2DPRfsDcH1kLuBPmUzng+xT2wRXKNmcD55tXKp7AHtgDWygfMPL9S5vkV90CPybwKM756lO+BWndbDZI9sADwHgNmHa5Bsgci52TBKN8DvbNSUIGVQkrzspCDPbBw6udHZQ9M2THQe2ALYC3kTlBE6YwXUdwDWybXmAWcb16tIgp7YEtgrSLAzIsqZV5UcQ/0mCysMOPrRPkeqHW31SXZA4sB7zFg1uG6JHsgck4Wj/I90DsrxRVYKaE0L0s42ANLpn5+VPbAlB0DvQe2BNZC7gSllM54KcU9sFVyjTnA+ebVKqWwB7YC1ioFzLy0UualFfdAj8mSCjO+YZTvgVp3WyOSPbAM8B4DZh1uRLIHIudk2SjfA72zUlaBlXJK87Kcgz2wfOrnR+3BTXaFs9SY4OGExs+yNiG5byoAeQFmHW5CcG4qKJybiv8+uAkje6DlsVK0P7hJ+abxn/JNXmWCBzeVwA9uKpM9uAmn/stG7cFNWOGyqaK06FdxsOhX/Xdx+Q/c/fXgprLCWaqmdJaqKX6w2jq5xjzgBwZerWoKH6y2BtaqBryDqitlXl3xg1VvJyqvcP5bRfk3LFofFrUm+Ua3BvC+AGYdbk3ywSpyTtaM8g9WvbNSU4GVWkrzspaDfat26udH5S/YU3YM9F+wtwbWQu4EdZTOeB3FPbBNco0FwPnm1aqjsAe2AdaqA8y8rlLmdRX3QI/J2gozvn2U74Fad1sHkj2wHvAeA2Yd7kCyByLnZP0o3wO9s1JfgZUGSvOygYM9sGHq50dlD0zZMdB7YBtgLeRO0EjpjDdS3APbJtdYBJxv/1VLYQ9sC6zVCJh5Y6XMGyvugR6TDRVmfJco3wO17rauJHtgE+A9Bsw63JVkD0TOyaZRvgd6Z6WpAivNlOZlMwd7YPPUz4/KHpiyY6D3wLbAWsidoIXSGW+huAe2S66xBDjfvFotFPbAdsBaLYCZt1TKvKXiHugx2VxhxveM8j1Q627rRbIHtgLeY8Csw71I9kDknGwd5Xugd1ZaK7DSRmletnGwB7ZN/fyoPbipqnCWehM8nND4WdY+JPdNOyAvwKzDfQjOTTuNv6/998FNGNkDLY8dov3BTco3jf+Ub/I6Ejy46QB+cNOR7MFNp9R/2ag9uOmkcNl0Vlr0OztY9Lv8u7j8B+7+enDTUeMv2pTOUlfFD1bbJ9dYBvzAwKvVVeGD1fbAWl2Bd1A3pcy7KX6w6u1EbRXO/6Ao/4ZF68OiBJJvdLsD7wtg1uEEkg9WkXOyR5R/sOqdlR4af/miNC97Oti3eqV+flT+gj1lx0D/BXt7YC3kTtBb6Yz3VtwDOyTXuAk437xavRX2wA7AWr2BmfdRyryP4h7oMdlLYcYPifI9UOtuG0qyB/YF3mPArMNDSfZA5JzsF+V7oHdW+imw0l9pXvZ3sAcOSP38qOyBKTsGeg/sAKyF3AkGKp3xgYp7YMfkGiuB882rNVBhD+wIrDUQmPkgpcwHKe6BHpMDFGb8yCjfA7XutlEke2AC8B4DZh0eRbIHIudkYpTvgd5ZSVRgJUlpXiY52AMHp35+VPbAlB0DvQd2BNZC7gRDlM74EMU9sFNyjVuA882rNURhD+wErDUEmPlQpcyHKu6BHpODFWb8uCjfA7XutvEke+Aw4D0GzDo8nmQPRM7J4VG+B3pnZbgCKyOU5uUIB3vgyNTPj9qDmy4KZ2kCwcMJjZ9lnUhy34wC8gLMOjyR4NyMUjg3o/99cBNG9kDL45hof3CT8k3jP+WbvLEED27GgB/cjCV7cDMu9V82ag9uxml8U6y06I93sOhP+Hdx+Q/c/fXgZqzGwqt0liYqfrDaObnGbcAPDLxaExU+WO0MrDUReAdNUsp8kuIHq95ONFLh/E+L8m9YtD4smk7yje4NwPsCmHV4OskHq8g5OTnKP1j1zspkBVamKM3LKQ72rampnx+Vv2BP2THQf8HeGVgLuRNMUzrj0xT3wC7JNVYB55tXa5rCHtgFWGsaMPPpSplPV9wDPSanKsz4WVG+B2rdbbNJ9sAZwHsMmHV4NskeiJyTM6N8D/TOykwFVm5Umpc3OtgDZ6V+flT2wJQdA70HdgHWQu4Es5XO+GzFPbBrco01wPnm1ZqtsAd2BdaaDcx8jlLmcxT3QI/JWQozfn6U74Fad9sCkj1wLvAeA2YdXkCyByLn5Lwo3wO9szJPY0Yozcv5DvbABamfH5U9MGXHQO+BXYG1kDvBQqUzvlBxD0w+QmnWAuebV2uhwh7YDVhrITDzRUqZL1LcAz0mFyjM+CVRvgdq3W1LSfbAxcB7DJh1eCnJHoick0uifA/0zsoSDVaU5uVSB3vgstTPj8rPA3s/h4f8GUatnxFdnjm67y/v616u8HXf9O9DjPBNmaPf44pof4iR8s3EP2X5X0nwEGMF+CHGSqWHGOiv3TuHyAtbayG6meDSuVnh674FcC7/+qApKZwuuUaGiK898hf8h6rBC2zKr1szKxq+NbPCTxUBB4vW132b8qsxNBS3Aw5XjYTKtYfUqFFT0+cqgM/ExBo1E4bUqq7pczXAZ9WkGkOGVq1ZRdPnGoDPhOrVhg6tXjVB0+cdAJ/Vw5WHVK9Sc6imz7UAn7UTK1evUatWkqbPdQCf4aG1qg6unZCo6XM9IvfEIZWTBodre96uNx6fj//rUxvvzy9E/PnFiD+/FPHnlyP+fCbiz69E/PnViD+/FvHn1yP+fDbiz29E/PnNiD+/FfHncxF/Ph/x59sz+39eFfHn1RF/XhPx5zsi/rw24s/rIv683vx5Q/I/Nyb/vjP5913Jv+9O/r0p+ffm5N9bMss5V762X/+17N2msOxtBS5N6czXnfJNpvfnIynfPaTR6UuONPj9Ae0xJ4HHXAQecxN4zEPgMS+Bx3wEHvMTeCxA4LEggcdCBB4LE3gsQuCxKIHHYgQeixN4LEHgsSSBx1IEHksTeCxD4LEsgcdyBB7LE3isQOCxIoHHSgQeKxN4DBN4rELgsSqBx2oEHqsTeKxB4LEmgcdaBB5rE3isQ+CxLoHHegQe6xN4bEDgsSGBx0YEHhsTeGxC4LEpgcdmBB6bE3hsQeCxJYHHVgQeWxN4bEPgsS2Bx3YEHtsTeOxA4LEjgcdOBB47E3jsQuCxK4HHbgQeuxN47EHgsSeBx14EHnsTeOxD4LEvgcd+BB77E3gcQOBxIIHHQQQeEwg8JhJ4TCLwOJjA4xACj0MJPA4j8DicwOMIAo8jCTyOIvA4msDjGAKPYwk8jiPwOJ7A4wQCjxMJPE4i8HgDgcfJBB6nEHicSuBxGoHH6QQeZxB4nEng8UYCj7MIPM4m8DiHwONcAo/zCDzOJ/C4gMDjQgKPiwg8LibwuITA41ICj8sIPC4n8HgTgccVBB5XEni8mcDjLQQebyXweBuBx9sJPK4i8LiawOMaAo93EHhcS+BxHYHH9QQeNxB43Ejg8U4Cj3cReLybwOMmAo+bCTxuIfC4lcDjPQQe7yXwuI3A43YCjzsIPO4k8LiLwONuAo97CDzuJfB4H4HH+wk87iPwuJ/A4wECjwcJPD5A4PFBAo8PEXg8RODxMIHHhwk8PkLg8VECj48ReDxC4PEogcdjBB4fJ/D4BIHHJwk8PkXg8TiBxxMEHk8SeHyawOMzBB6fJfD4HIHHUwQeTxN4fJ7A4wsEHl8k8PgSgceXCTyeIfD4CoHHVwk8vkbg8XUCj2cJPL5B4PFNAo9vEXg8R+DxPIHHtwk8vkPg8V0Cj+8ReLxA4PF9Ao8fEHj8kMDjRwQePybw+AmBx08JPH5G4PFzAo9fEHj8ksDjVwQevybw+A2Bx4sEHr8l8PgdgcfvCTz+QODxRwKPPxF4/JnA4y8EHn8l8PgbgcffCTxeIvB4mcDjHwQerxB4/JPAo1cw2j0GCDwGCTymJfCYjsBjegKPGQg8ZiTwGEPgMZbAY4jAYxyBx3gCj5kIPGYm8JiFwGNWAo/XEXjMRuDxegKP2Qk85iDwmJPAYy4Cj7kJPOYh8JiXwGM+Ao/5CTwWIPBYkMBjIQKPhQk8FiHwWJTAYzECj8UJPJYg8FiSwGMpAo+lCTyWIfBYlsBjOQKP5Qk8ViDwWJHAYyUCj5UJPIYJPFYh8FiVwGM1Ao/VCTzWIPBYk8BjLQKPtQk81iHwWJfAYz0Cj/UJPDYg8NiQwGMjAo+NCTw2IfDYlMBjMwKPzQk8tiDw2JLAYysCj60JPLYh8NiWwGM7Ao/tCTx2IPDYkcBjJwKPnQk8diHw2JXAYzcCj90JPPYg8NiTwGMvAo+9CTz2IfDYl8BjPwKP/Qk8DiDwOJDA4yACjwkEHhMJPCYReBxM4HEIgcehBB6HEXgcTuBxBIHHkQQeRxF4HE3gcQyBx7EEHscReBxP4HECgceJBB4nEXi8gcDjZAKPUwg8TiXwOI3A43QCjzMIPM4k8HgjgcdZBB5nE3icQ+BxLoHHeQQe5xN4XEDgcSGBx0UEHhcTeFxC4HEpgcdlBB6XE3i8icDjCgKPKwk83kzg8RYCj7cSeLyNwOPtBB5XEXhcTeBxDYHHOwg8riXwuI7A43oCjxsIPG4k8Hgngce7CDzeTeBxE4HHzQQetxB43Erg8R4Cj/cSeNxG4HE7gccdBB53EnjcReBxN4HHPQQe9xJ4vI/A4/0EHvcReNxP4PEAgceDBB4fIPD4IIHHhwg8HiLweJjA48MEHh8h8PgogcfHCDweIfB4lMDjMQKPjxN4fILA45MEHp8i8HicwOMJAo8nCTw+TeDxGQKPzxJ4fI7A4ykCj6cJPD5P4PEFAo8vEnh8icDjywQezxB4fIXA46sEHl8j8Pg6gcezBB7fIPD4JoHHtwg8niPweJ7A49sEHt8h8Pgugcf3CDxeIPD4PoHHDwg8fkjg8SMCjx8TePyEwOOnBB4/I/D4OYHHLwg8fkng8SsCj18TePyGwONFAo/fEnj8jsDj9wQefyDw+COBx58IPP5M4PEXAo+/Enj8jcDj7wQeLxF4vEzg8Q8Cj1cIPP5J4DFNMPo9Bgg8Bgk8piXwmI7AY3oCjxkIPGYk8BhD4DGWwGOIwGMcgcd4Ao+ZCDxmJvCYhcBjVgKP1xF4zEbg8XoCj9kJPOYg8JiTwGMuAo+5CTzmIfCYl8BjPgKP+Qk8FiDwWJDAYyECj4UJPBYh8FiUwGMxAo/FCTyWIPBYksBjKQKPpQk8liHwWJbAYzkCj+UJPFYg8FiRwGMlAo+VCTyGCTxWIfBYlcBjNQKP1Qk81iDwWJPAYy0Cj7UJPNYh8FiXwGM9Ao/1CTw2IPDYkMBjIwKPjQk8NiHw2JTAYzMCj80JPLYg8NiSwGMrAo+tCTy2IfDYlsBjOwKP7Qk8diDw2JHAYycCj50JPHYh8NiVwGM3Ao/dCTz2IPDYk8BjLwKPvQk89iHw2JfAYz8Cj/0JPA4g8DiQwOMgAo8JBB4TCTwmEXgcTOBxCIHHoQQehxF4HE7gcQSBx5EEHkcReBxN4HEMgcexBB7HEXgcT+BxAoHHiQQeJxF4vIHA42QCj1MIPE4l8DiNwON0Ao8zCDzOJPB4I4HHWQQeZxN4nEPgcS6Bx3kEHucTeFxA4HEhgcdFBB4XE3hcQuBxKYHHZQQelxN4vInA4woCjysJPN5M4PEWAo+3Eni8jcDj7QQeVxF4XE3gcQ2BxzsIPK4l8LiOwON6Ao8bCDxuJPB4J4HHuwg83k3gcROBx80EHrcQeNxK4PEeAo/3EnjcRuBxO4HHHQQedxJ43EXgcTeBxz0EHvcSeLyPwOP9BB73EXjcT+DxAIHHgwQeHyDw+CCBx4cIPB4i8HiYwOPDBB4fIfD4KIHHxwg8HiHweJTA4zECj48TeHyCwOOTBB6fIvB4nMDjCQKPJwk8Pk3g8RkCj88SeHyOwOMpAo+nCTw+T+DxBQKPLxJ4fInA48sKHjV85s6o4zMN1Gc17/+dz39//VnNn+/JnCbNvcm/tyX/3p78e0fy753Jv3cl/96d/HtP8u+9yb/vS/59f/Lvfcm/9yf/PpD8+2Dmv2o8kNkUTWv+6RUtbGn3Cto2QdsuaDsEbaeg7RK03YK2R9D2Ctp9gna/oO0TtP2CdkDQDgraA0ZLCSvyEFStXKNatSE1qwwJVw0nVK5SO7FW9crVqifWqBWuFa5eq/rgKrWqVh1Sq1qtmrUTa9esXDtcreqQ8NDqtasOGer9qhzunlxjffKBDSIPV7hy5e4Aj0NNuQcz44CK7OuDEX0Ngvqa4rlHco2NGXH1vFqe37TInLz/+CawVmRO1/r1PqSU+UOKLKVkDs0o/NdZQtVCZnRIKaNDilz2TK5xF5BLr9YhBS57AmsdAmZ+WCnzwxGZp/xKC85+PXgeo2o9jOtp1cj+odlBcvMI7msOp0mj8Jd5yf48j6g7IuXrflSJn0f/wfw8hutpFeksXetekHLnoPeCnsBayDviiNIZP6K4F/RKrrEJeCa9WkcU9oJewFpHgJkfVcr86FX29crX9ivsMfmYwoxf1w37ARDL3bYe/HWn/ELfY8eAuwcw6zCwf+HI/qFnJXJOPh7le6B3Vh5XYOUJpXn5hIM98MnUz09liZvK1/Yr7O3Pz8dj93Hvs3W0z3uAe8FTmXXuBPRMQ35vc1x5pqF23X/Kbnoic3TPBY+R45mx5+9E5v9GJXp30fBf3J1QuF9PKt2vJxW/B+2dXGMLcA55tU4qfA/aG1jrJPDcP62U+dOK34N6c/hJhfO/Jcq/B9Xaq7eSfA/6DHBHAGYd3kryPShyTj4b5d+DemflWQVWnlOal885+B70VOrnR5y71/p3ESk7BvrvInoDayF3gtNKZ/y04h7YJ7nGPcD55tU6rbAH9gHWOg3M/HmlzJ9X3AM9Jk8pzPjtUb4Hat1tO0j2wBeA9xgw6/AOkj0QOSdfjPI90DsrLyqw8pLSvHzJwR74curnR2UPTNkx0HtgH2At5E5wRumMn1HcA/sm19gGnG9erTMKe2BfYK0zwMxfUcr8FcU90GPyZYUZvyfK90Ctu20vyR74KvAeA2Yd3kuyByLn5GtRvgd6Z+U1BVZeV5qXrzvYA8+mfn5U9sCUHQO9B/YF1kLuBG8onfE3FPfAfsk1dgDnm1frDYU9sB+w1hvAzN9UyvxNxT3QY/KswozfH+V7oNbddoBkD3wLeI8Bsw4fINkDkXPyXJTvgd5ZOafAynmleXnewR74durnR+1nk18A/2zyvQo/m3wvcC94J8p/LtTr4YvgTLYpZLINmMm7BJm8BM5ku0Im24GZvEeQycvgTHYoZLIDmMkFgkzOgDPZqZDJTmAm7xNk8go4k10KmewCZvIBQSavgjPZrZDJbmAmHxJk8ho4kz0KmewBZvIRQSavgzPZq5DJXmAmHxNkchacyX0KmdwHzOQTgkzeAGdyv0Im9wMz+ZQgkzfBmexTyGQfMJPPCDJ5C5zJfoVM9gMz+Zwgk3PgTA4oZHIAmMkXBJmcB2dyUCGTg8BMvgRm4v39RiiN/x/Y9t76e587e59zep+reZ/jeJ8beN+net8XeXu4t/d5e4Z3r3lz1OPWOydfRrzpR/9dkvffDDiu8HdJXwF7GTS9tH+h6mv19qvM0e/xa7RH9EFK+SGYf8oPrXwT5ReDNyy+Bn69Xr1vMutArfEfLflGYVheVPqL94uKP5zWP7nGLuAPXXi1Lir8cFp/YK2LwHP/rVLm3yr+cJo3h9/W+AHkKP/hNK0fuDlL8sNp3wF/uAaYdfgsyQ+nIefk91H+w2neWflegZUflOblDw5+OO3H1M+PyiOFlB0D/UihP7AWcif4SemM/6S4Bw5IrrEHON+8Wj8p7IEDgLV+Amb+s1LmPyvugR6TPyrM+HNRvgdq3W3nSfbAX4D3GDDr8HmSPRA5J3+N8j3QOyu/KrDym9K8/M3BHvh76udHZQ9M2THQe+AAYC3kTnBJ6YxfUtwDBybXuA8437xalxT2wIHAWpeAmV9Wyvyy4h7oMfm7wox/L8r3QK277QLJHvgH8B4DZh2+QLIHIufklSjfA72zckWBlT+V5uWfDvbANFlSPT8qe2DKjoHeAwcCayF3gkAWnTPu1S1s6qJn26DkGvuA882r5flF74GDgLUic7rWrzeolHkwi94e6DHpzTT0jP8oyvdArbvtY5I9MC3wHgNmHf6YZA9Ezsl0WbBfM5oV76ykU5gR6ZXmZfos+ntghtTPj8rcTfmh5aBCXVS2n0R5D72fZZR6eK1fd0bgmY72Hnr9y6gw02KAM83Ll/GH55E90PIYi/aIPkiD0vz1zdg/5ZunEDgQjQsmFvj1evW8r1kDapYLJy46LxyVJdrrX5zChROvtETHK37ooHWeMv1TFhjzoCWkcJ4yK52nzIofXCYk1zgA/Ibcq5VZ4YPLBGCtzMC7KItS5lkUZ4i3G2VQOP9fRfk3LlofxnxN8sFlVuCMB2Yd/prkg0vknLwuyj+49M7KdQqsZFOal9kcfHB5fernR+UvsFN2DPRfYCcAayF3guxKZzy74h6YmFzjAeB882plV9gDE4G1sgMzz6GUeQ7FPdBj8nqFGf9dlO+BWnfb9yR7YE7gPQbMOvw9yR6InJO5onwP9M5KLgVWcivNy9wO9sA8qZ8flT0wZcdA74GJwFrInSCv0hnPq7gHJiXXeAg437xaeRX2wCRgrbzAzPMpZZ5PcQ/0mMyjMON/jvI9UOtu+4VkD8wPvMeAWYd/IdkDkXOyQJTvgd5ZKaDASkGleVnQwR5YKPXzo7IHpuwY6D0wCVgLuRMUVjrjhRX3wMHJNQ4D55tXq7DCHjgYWKswMPMiSpkXUdwDPSYLKcz4S1G+B2rdbZdJ9sCiwHsMmHX4MskeiJyTxaJ8D/TOSjEFVoorzcviDvbAEqmfH7Wfjc2kcJb+IHhAofHzrFdI7puSQF6AWYevEJybkgrnptS/D2/CyB5oeSwd7Q9vUr5p/Kd8k1eG4OFNafDDmzJKD29SfqEvm7Kp/7JRe3RTVuGyKae06JdzsOiX/3dx+Q/c/fXgpozCWaqgdJYqKH6wOiS5xiPADwy8WhUUPlgdAqxVAXgHVVTKvKLiB6veTlRC4fyn6x7d37BofViUvjvH7lEJeF8Asw4D+6f6wSpyTlaO8g9WvbNSWYGVsNK8DDvYt6qkfn5U/oI9ZcdA/wX7EGAt5E5QVemMV1XcA4cm13gMON+8WlUV9sChwFpVgZlXU8q8muIe6DFZRWHGx0b5Hqh1t4VI9sDqwHsMmHU4RLIHIudkjSjfA72zUkOBlZpK87Kmgz2wVurnR2UPTNkx0HvgUGAt5E5QW+mM11bcA4cl1zgKnG9erdoKe+AwYK3awMzrKGVeR3EP9JispfEfoIryPVDrbstCsgfWBd5jwKzDWUj2QOScrBfle6B3VuopsFJfaV7Wd7AHNkj9/KjsgSk7BnoPHAashdwJGiqd8YaKe+Dw5BqPA+ebV6uhwh44HFirITDzRkqZN1LcAz0mGyjM+OujfA/Uutuyk+yBjYH3GDDrcHaSPRA5J5tE+R7onZUmCqw0VZqXTR3sgc1SPz9qD27KK5ylHFH+dWv9LGtOkvumOZAXYNbhnATnprnCuWnx74ObMLIHWh5bRvuDm5RvGv8p3+S1Inhw0xL84KYV2YOb1qn/slF7cNNa4bJpo7Tot3Gw6Lf9d3H5D9z99eCmlcJZaqd0ltopfrA6IrnGk8APDLxa7RQ+WB0BrNUOeAe1V8q8veIHq95O1Ezh/OeP8m9YtD4sKkDyjW4H4H0BzDpcgOSDVeSc7BjlH6x6Z6WjAiudlOZlJwf7VufUz4/KX7Cn7Bjov2AfAayF3Am6KJ3xLop74MjkGseB882r1UVhDxwJrNUFmHlXpcy7Ku6BHpOdFWZ8kSjfA7XutqIke2A34D0GzDpclGQPRM7J7lG+B3pnpbsCKz2U5mUPB3tgz9TPj8oemLJjoPfAkcBayJ2gl9IZ76W4B45KrnESON+8Wr0U9sBRwFq9gJn3Vsq8t+Ie6DHZU2HGl4zyPVDrbitFsgf2Ad5jwKzDpUj2QOSc7Bvle6B3VvoqsNJPaV72c7AH9k/9/KjsgSk7BnoPHAWshdwJBiid8QGKe+Do5BrPAOebV2uAwh44GlhrADDzgUqZD1TcAz0m+yvM+HJRvgdq3W3lSfbAQcB7DJh1uDzJHoickwlRvgd6ZyVBgZVEpXmZ6GAPTEr9/Kg9uGmrcJYqEDyc0PhZ1ook981gIC/ArMMVCc7NYIVzM+TfBzdhZA+0PA6N9gc3Kd80/lO+yRtG8OBmKPjBzTCyBzfDU/9lo/bgZrjCZTNCadEf4WDRH/nv4vIfuPvrwc0whbM0SuksjVL8YHVMco3ngB8YeLVGKXywOgZYaxTwDhqtlPloxQ9WvZ0oSeH8V4vyb1i0PiyqTvKN7hjgfQHMOlyd5INV5JwcG+UfrHpnZawCK+OU5uU4B/vW+NTPj8pfsKfsGOi/YB8DrIXcCSYonfEJinvg2OQap4Hzzas1QWEPHAusNQGY+USlzCcq7oEek+MVZnztKN8Dte62OiR74CTgPQbMOlyHZA9EzskbonwP9M7KDQqsTFaal5Md7IFTUj8/Kntgyo6B3gPHAmshd4KpSmd8quIeOC65xgvA+ebVmqqwB44D1poKzHyaUubTFPdAj8kpCjO+QZTvgVp3W0OSPXA68B4DZh1uSLIHIufkjCjfA72zMkOBlZlK83Kmgz3wxtTPj8oemLJjoPfAccBayJ1gltIZn6W4B45PrvEScL55tWYp7IHjgbVmATOfrZT5bMU90GPyRoUZ3zTK90Ctu60ZyR44B3iPAbMONyPZA5Fzcm6U74HeWZmrwMo8pXk5z8EeOD/186P24GakwllqTvBwQuNnWVuQ3DcLgLwAsw63IDg3CxTOzcJ/H9yEkT3Q8rgo2h/cpHzT+E/5Jm8xwYObReAHN4vJHtwsSf2XjdqDmyUKl81SpUV/qYNFf9m/i8t/4O6vBzeLFc7ScqWztFzxg9UJyTXOAD8w8GotV/hgdcL/w96bh+tU9n//QqZSMgtRolDZaw/2FiqkQpIKGRoM21AoYyHzPM+Z5ylz5nmeZ1KJMhRCESoKxW+d97a+9+U+9u/5w36/13G+1977OPbR9eznec7rda3P9FrntU43cK0+wBnUlxTzvsSNVeNEXQj5/6rlNyyszaKKIje6/YDzAhhrp6LIxiqyT/a3fGPV5Ep/Qq0MIPXLAT741sDg1w/lC3bPMdBfsDcDroV0gkGkHB9E9MDm7hoHgf3NrDWI4IHNgWsNAsZ8MCnmg4keaGpyIKHHV7bcA1mz7Q0RDxwCnGPAWDtviHggsk8OtdwDTa4MJdTKMFK/HOaDBw4Pfv1QPNBzDLQHNgeuhXSCz0k5/jnRA1u4a3wD7G9mrc8JHtgCuNbnwJiPIMV8BNEDTU0OJ/T4qpZ7IGu2VRPxwJHAOQaMtVNNxAORfXKU5R5ocmUUoVZGk/rlaB88cEzw64figZ5joD2wBXAtpBOMJeX4WKIHtnTXOATsb2atsQQPbAlcayww5uNIMR9H9EBTk2MIPb6m5R7Imm21RDxwPHCOAWPt1BLxQGSfnGC5B5pcmUColYmkfjnRBw+cFPz6oR246U3IpXcEDk4wnmV9V2TeTAbWCzDWzrsCeTOZkDdTkg7cOMhrwGKcavuBG++mMbHc5E0TOHAzFXzgZprYgZvpwR82tAM30wnDZgZJ9Gf4IPpfJInLXdDFHbiZRsilmaRcmkncWG3lrnEYuGFg1ppJ2FhtBVxrJnAGzSLFfBZxY9U40SRC/tez/IaFtVkUK3KjOxs4L4CxdmJFNlaRfXKO5RurJlfmEGplLqlfzvXBt+YFv34oX7B7joH+gr0VcC2kE8wn5fh8oge2dtf4HtjfzFrzCR7YGrjWfGDMvyTF/EuiB5qanEfo8Y0s90DWbPtAxAMXAOcYMNbOByIeiOyTCy33QJMrCwm1sojULxf54IGLg18/FA/0HAPtga2BayGdYAkpx5cQPfATd42jwP5m1lpC8MBPgGstAcZ8KSnmS4keaGpyMaHHN7XcA1mz7SMRD1wGnGPAWDsfiXggsk8ut9wDTa4sJ9TKClK/XOGDB64Mfv1QPNBzDLQHfgJcC+kEq0g5vorogZ+6axwH9jez1iqCB34KXGsVMOarSTFfTfRAU5MrCT2+heUeyJptLUU8cA1wjgFj7bQU8UBkn1xruQeaXFlLqJV1pH65zgcPXB/8+qEduPmCkEutBA5OMJ5lbS0ybzYA6wUYa6e1QN5sIOTNxqQDNw7yGrAYN9l+4Ma7aUwsN3mbBQ7cbAIfuNksduBmS/CHDe3AzRbCsNlKEv2tPoj+tiRxuQu6uAM3mwm5tJ2US9uJG6tt3DV+BG4YmLW2EzZW2wDX2g6cQTtIMd9B3Fg1TrSekP+fWX7Dwtosai9yo7sTOC+AsXbai2ysIvvkLss3Vk2u7CLUym5Sv9ztg2/tCX79UL5g9xwD/QV7G+BaSCfYS8rxvUQPbOuucRLY38xaewke2Ba41l5gzPeRYr6P6IGmJvcQenxnyz2QNdu6iHjgfuAcA8ba6SLigcg+ecByDzS5coBQK1+R+uVXPnjgweDXD8UDPcdAe2Bb4FpIJ/ialONfEz2wnbvGaWB/M2t9TfDAdsC1vgbG/BtSzL8heqCpyYOEHt/Dcg9kzbaeIh74LXCOAWPt9BTxQGSfPGS5B5pcOUSole9I/fI7HzzwcPDrh+KBnmOgPbAdcC2kExwh5fgRogd+5q5xBtjfzFpHCB74GXCtI8CYf0+K+fdEDzQ1eZjQ4/ta7oGs2dZPxAN/AM4xYKydfiIeiOyTRy33QJMrRwm1cozUL4/54IHHg18/tAM32wi51F/g4ATjWdYBIvPmBLBegLF2BgjkzQlC3vyYdODGQV4DFuNPth+48W4aE8tN3kmBAzc/gQ/cnBQ7cHMq+MOGduDmFGHYnCaJ/mkfRP/nJHG5C7q4AzcnCbl0hpRLZ4gbq+3dNc4BNwzMWmcIG6vtgWudAc6gs6SYnyVurBonOk7I/2GW37CwNouGi9zongPOC2CsneEiG6vIPvmL5RurJld+IdTKr6R++asPvnU++PVD+YLdcwz0F+ztgWshneACKccvED2wg6khYH8za10geGAH4FoXgDH/jRTz34geaGryPKHHj7LcA1mzbbSIB14EzjFgrJ3RIh6I7JOXLPdAkyuXCLVymdQvL/vggb8Hv34oHug5BtoDOwDXQjrBH6Qc/4PogR3dNS4A+5tZ6w+CB3YErvUHMOZ/kmL+J9EDTU3+Tujx4y33QNZsmyDigVeAcwwYa2eCiAci++RVyz3Q5MpVQq38ReqXf/nggX8Hv34oHug5BtoDOwLXQjrBNVKOXyN6YCd3jYvA/mbWukbwwE7Ata4BY36dFPPrRA80Nfk3ocdPsdwDWbNtqogH3gDOMWCsnakiHojsk/9Y7oEmV/4h1Mq/pH75rw8eeDP49UM7cPMzIZemCRycYDzLOl1k3twC1gsw1s50gby5RcibZBlwn9vMVsUDN8hrwGK8B82ITqROyeJuGhPLTV5ycECSg6+baRihSYM4cGM+M6uozQ962KTIEPhhQztwY64dukekBNZMqOibdfMmu/MHnUv3Bj+XaAdukhNyKRUpl1Jl4G2sdnbXuAzcMDBrGV70zO0MXCsVcAalJsU8dQbexqpxopsEcZ9j+Q0La7NorsiNbhrgvADG2pkrsrGK7JNpM2A/M7pWTK6kJczIdKR+mc4H37ov+PVD+YLdcwz0F+ydgWshneB+Uo7fT/TALu4afwD7m1nrfoIHdgGudT8w5ulJMU9P9EBTk/cRevwCyz2QNdsWinjgA8A5Boy1s1DEA5F98kHLPdDkyoOEWslA6pcZfPDAh4JfPxQP9BwD7YFdgGshnSAjKcczEj2wq7vGFWB/M2tlJHhgV+BaGYExz0SKeSaiB5qafIjQ45da7oGs2bZMxAMzA+cYMNbOMhEPRPbJLJZ7oMmVLIRayUrql1l98MBswa8figd6joH2wK7AtZBOkJ2U49mJHtjNXeMvYH8za2UneGA34FrZgTHPQYp5DqIHmprMRujxqyz3QNZsWy3igQ8D5xgw1s5qEQ9E9smclnugyZWchFrJReqXuXzwwNzBrx/agZt7Cbm0RuDgBONZ1rUi8+YRYL0AY+2sFcibRwh5kyfpwI2DvAYsxry2H7jxbhoTy03eowIHbvKCD9w8Knbg5rHgDxvagZvHCMMmH0n08/kg+o8nictd0MUduHmUkEv5SbmUn7ix2t1d4xpww8CslZ+wsdoduFZ+4AwqQIp5AeLGqnGi3IT832z5DQtrs2iLyI3uE8B5AYy1s0VkYxXZJ5+0fGPV5MqThFopSOqXBX3wrULBrx/KF+yeY6C/YO8OXAvpBIVJOV6Y6IE93DVuAPubWaswwQN7ANcqDIz5U6SYP0X0QFOThQg9foflHsiabTtFPPBp4BwDxtrZKeKByD75jOUeaHLlGUKtFCH1yyI+eGBY8OuH4oGeY6A9sAdwLaQTOKQcd4ge2NNd419gfzNrOQQP7AlcywHGPJwU83CiB5qaDCP0+L2WeyBrtu0T8cAI4BwDxtrZJ+KByD4ZabkHmlyJJNRKFKlfRvnggUWDXz8UD/QcA+2BPYFrIZ0gmpTj0UQP7OWucQvY38xa0QQP7AVcKxoY8xhSzGOIHmhqsiihxx+03ANZs+1rEQ8sBpxjwFg7X4t4ILJPPmu5B5pceZZQK8VJ/bK4Dx5YIvj1Qztw8zghl74RODjBeJb1W5F5UxJYL8BYO98K5E1JQt48l3TgxkFeAxbj87YfuPFuGhPLTd4LAgdungcfuHlB7MBNqeAPG9qBm1KEYVOaJPqlfRD9Mknichd0cQduXiDk0oukXHqRuLHa27xHGtx6Zq0XCRurvYFrvQicQWVJMS9L3Fg1TlSCkP8/WH7DwtosOipyo/sScF4AY+0cFdlYRfbJly3fWDW58jKhVl4h9ctXfPCtcsGvH8oX7J5joL9g7w1cC+kE5Uk5Xp7ogX3M+wD7m1mrPMED+wDXKg+MeQVSzCsQPdDUZDlCj//Rcg9kzbafRDzwVeAcA8ba+UnEA5F9sqLlHmhypSKhVl4j9cvXfPDASsGvH4oHeo6B9sA+wLWQTvA6KcdfJ3pgX3eNe4H9zaz1OsED+wLXeh0Y88qkmFcmeqCpyUqEHv+z5R7Imm1nRDzwDeAcA8baOSPigcg++ablHmhy5U1CrbxF6pdv+eCBVYJfPxQP9BwD7YF9gWshnaAqKcerEj2wn7tGamB/M2tVJXhgP+BaVYExr0aKeTWiB5qarELo8b9a7oGs2XZexAPfBs4xYKyd8yIeiOyT1S33QJMr1Qm1UoPUL2v44IE1g18/tAM3ZQi5dEHg4ATjWdbfROZNLWC9AGPt/CaQN7UIefNO0oEbB3kNWIzv2n7gxrtpTCw3ee8JHLh5F3zg5j2xAzfvB3/Y0A7cvE8YNrVJol/bB9GvkyQud0EXd+DmPUIu1SXlUl3ixmp/d420wA0Ds1ZdwsZqf+BadYEzqB4p5vWIG6vGiWoS8v9Py29YWJtFV0RudGOB8wIYa+eKyMYqsk/Wt3xj1eRKfUKtNCD1ywY++FbD4NcP5Qt2zzHQX7D3B66FdIJGpBxvRPTAAe4a9wH7m1mrEcEDBwDXagSM+QekmH9A9EBTkw0JPf6a5R7Imm3XRTzwQ+AcA8bauS7igcg+2dhyDzS50phQK01I/bKJDx7YNPj1Q/FAzzHQHjgAuBbSCT4i5fhHRA8c6K6RHtjfzFofETxwIHCtj4Ax/5gU84+JHmhqsimhx9+03ANZs+2WiAc2A84xYKydWyIeiOyTzS33QJMrzQm10oLUL1v44IEtg18/FA/0HAPtgQOBayGdoBUpx1sRPXCQu8aDwP5m1mpF8MBBwLVaAWPemhTz1kQPNDXZktDjU1S12wNZsy0l+HN7P+g59glwjgFj7QCvH9UDkX3yU8s90OTKp4RaaUPql2188MC2wa8f2oGbOoRcutfyz816ljWVyLxpB6wXYKydVAJ5046QN58lHbhxkNeAxdje9gM33k1jYrnJ6yBw4KY9+MBNB7EDNx2DP2xoB246EoZNJ5Lod/JB9Dsnictd0MUduOlAyKUupFzqQtxYHeyu8RBww8Cs1YWwsToYuFYX4AzqSop5V+LGqnGitoT8v9/yGxbWZlF6kRvdbsB5AYy1k15kYxXZJ7tbvrFqcqU7oVZ6kPplDx98q2fw64fyBbvnGOgv2AcD10I6QS9SjvcieuAQd41MwP5m1upF8MAhwLV6AWPemxTz3kQPNDXZk9DjH7LcA1mzLaOIB/YBzjFgrJ2MIh6I7JN9LfdAkyt9CbXSj9Qv+/nggf2DXz8UD/QcA+2BQ4BrIZ1gACnHBxA9cKi7RhZgfzNrDSB44FDgWgOAMR9IivlAogeamuxP6PFZLfdA1mzLJuKBg4BzDBhrJ5uIByL75GDLPdDkymBCrQwh9cshPnjg0ODXD8UDPcdAe+BQ4FpIJxhGyvFhRA8c5q6RDdjfzFrDCB44DLkWMObDSTEfTvRAU5NDCT0+p+UeyJptuUQ88HPgHAPG2skl4oHIPjnCcg80uTKCUCsjSf1ypA8eOCr49UN5Htg8h4d8hpH1jOjoDHbPL/O5RxM+95ikgxjOmAz2M461/SCGdzORWOR/nMBBjLHggxjjSAcx0J/d5CFyYLOEaLzlQ2fR/e4XOw/gP/cEyz+3kZYJhHjnEzjtOZ7wuR8XuUmeCOwZwFg7odcvYRuzdZ2U7hqpQnIn9AedTxPBN3zez6QMROBJGfDrTgYOYtbnnkwa7qhmEhNVv6hTrFhtM5QGE4ZSfsub82j3M09+AL+zNQXY9BDXsGjtsGKxRYtGM67hGNI1nBpyDcMjomPCwqNqx8RGRtWtW6xoeERYbO2o+sViYqMdd9HoerUj6kSG1alTz13Sia4T7dSODK8X5f6/LxpWz6kXXRdxDevUKRpdOzYminENx5Ku4bSQa+iER8VEREfUc2Jq146sU79ujBPrVn50bFhkWETRSCfMiYyKcq+i44SHRxaNinIvXFSderFRMTGR0XUj6saGI65hRN2isfUjosMZ13Ac6RpOD63lusViI4pF146pW7R+dLhTLzYyon50WO2o6OgY94JGuekWEVG0Tt0op07tusXCi9aJigiLiY2NKVrMTdOo8GKRiGtYOyqyfv2oiNqMaziedA1nhF7DSKduZHRMVNHY6Pr1wsMioyPr14kKq1MstliME1k0LCa8dl23nsPDnejosPrh0bUjitauHVWsfr1i7v85pl7R2ohrGOWExUaFR9dnXMMJpGv4RWgt13diihatE1asaGRYvaJOeO0Yp15Yndja9WMiitaNDIuqV7tesbqRMfViIsPCi9aLdb+Xj6gd7mZnTL26dd1Sr4+4hsXqhEUVjYmpy7iGE0nXcGZoHkZE1Y2oE+X+PysaHl6svvv/PbJubGy9qHp1Y6OK1ouJderWiS5azKkT4/63TlhEnfpF69WOrF23drR7ld26h8xlxw1YvWK16zCu4STSNZwVmodOXTcTI53wekXDw2Lq1w6LLWqGcLF6TmR4eNFwtykWrRteJzIi0vRNt1XWqx9VNzwyJtyJiakTEVWvKKSW68SG1a3nFDPXL9Pt67jxgbhvr8zroyGvj4W8Ph7y+kTI6x9DXv8U8vpkyOtTIa9Ph7z+OeT1mZDXZ0Nenwt5/UvI619DXk/J8N/XU0NeTwt5PT3k9YyQ11+EvJ4Z8nrW7dez3f/OcX/nur/z3N/57u+X7u8C93fh7fsVxibIZMImyCLyphdig5fxuRcD7y9S3v7c3saPeb3aaxrJOPmQJRk2bgzGrAKM2QQYswsw5hBgfFiAMacAYy4BxtwCjI8IMOYRYMwrwPioAONjAoz5BBgfF2DML8BYQIDxCQHGJwUYCwowFhJgLCzA+JQA49MCjM8IMBYRYAwTYHQEGMMFGCMEGCMFGKMEGIsKMEYLMMYIMBYTYHxWgLG4AGMJAcaSAozPCTA+L8D4ggBjKQHG0gKMZQQYXxRgLCvA+JIA48sCjK8IMJYTYCwvwFhBgPFVAcaKAoyvCTBWEmB8XYCxsgDjGwKMbwowviXAWEWAsaoAYzUBxrcFGKsLMNYQYKwpwFhLgPEdAcZ3BRjfE2B8X4CxtgBjHQHGugKM9QQYYwUY6wswNhBgbCjA2EiA8QMBxg8FGBsLMDYRYGwqwPiRAOPHAozNBBibCzC2EGBsKcDYSoCxtQDjJwKMnwowthFgbCvA2E6A8TMBxvYCjB0EGDsKMHYSYOwswNhFgLGrAGM3AcbuAow9BBh7CjD2EmDsLcDYR4CxrwBjPwHG/gKMAwQYBwowDhJgHCzAOESAcWgy+xmHCTAOF2D8XIBxhADjSAHGUQKMowUYxwgwjhVgHCfAOF6AcYIA40QBxkkCjJMFGKcIME4VYJwmwDhdgHGGAOMXAowzBRhnCTDOFmCcI8A4V4BxngDjfAHGLwUYFwgwLhRgXCTAuFiAcYkA41IBxmUCjMsFGFcIMK4UYFwlwLhagHGNAONaAcZ1AozrBRg3CDBuFGDcJMC4WYBxiwDjVgHGbQKM2wUYdwgw7hRg3CXAuFuAcY8A414Bxn0CjPsFGA8IMH4lwHhQgPFrAcZvBBi/FWA8JMD4nQDjYQHGIwKM3wsw/iDAeFSA8ZgA43EBxhMCjD8KMP4kwHhSgPGUAONpAcafBRjPCDCeFWA8J8D4iwDjrwKM5wUYLwgw/ibAeFGA8ZIA42UBxt8FGP8QYPxTgPGKAONVAca/BBj/FmC8JsB4XYDxhgDjPwKM/wow3hRgvCXAaBa0nfEeAcbkAowpBBhTCjDeK8CYSoAxtQBjGgHGtAKM6QQY7xNgvF+AMb0A4wMCjA8KMGYQYHxIgDGjAGMmAcbMAoxZBBizCjBmE2DMLsCYQ4DxYQHGnAKMuQQYcwswPiLAmEeAMa8A46MCjI8JMOYTYHxcgDG/AGMBAcYnBBifFGAsKMBYSICxsADjUwKMTwswPiPAWESAMUyA0RFgDBdgjBBgjBRgjBJgLCrAGC3AGCPAWEyA8VkBxuICjCUEGEsKMD4nwPi8AOMLAoylBBhLCzCWEWB8UYCxrADjSwKMLwswviLAWE6AsbwAYwUBxlcFGCsKML4mwFhJgPF1AcbKAoxvCDC+KcD4lgBjFQHGqgKM1QQY3xZgrC7AWEOAsaYAYy0BxncEGN8VYHxPgPF9AcbaAox1BBjrCjDWE2CMFWCsL8DYQICxoQBjIwHGDwQYPxRgbCzA2ESAsakA40cCjB8LMDYTYGwuwNhCgLGlAGMrAcbWAoyfCDB+KsDYRoCxrQBjOwHGzwQY2wswdhBg7CjA2EmAsbMAYxcBxq4CjN0EGLsLMPYQYOwpwNhLgLG3AGMfAca+Aoz9BBj7CzAOEGAcKMA4SIBxsADjEAHGoQKMwwQYhwswfi7AOEKAcaQA4ygBxtECjGMEGMcKMI4TYBwvwDhBgHGiAOMkAcbJAoxTBBinCjBOE2CcLsA4Q4DxCwHGmQKMswQYZwswzhFgnCvAOE+Acb4A45cCjAsEGBcKMC4SYFwswLhEgHGpAOMyAcblAowrBBhXCjCuEmBcLcC4RoBxrQDjOgHG9QKMGwQYNwowbhJg3CzAuEWAcasA4zYBxu0CjDsEGHcKMO4SYNwtwLhHgHGvAOM+Acb9AowHBBi/EmA8KMD4tQDjNwKM3wowHhJg/E6A8bAA4xEBxu8FGH8QYDwqwHhMgPG4AOMJAcYfBRh/EmA8KcB4SoDxtADjzwKMZwQYzwownhNg/EWA8VcBxvMCjBcEGH8TYLwowHhJgPGyAOPvAox/CDD+KcB4RYDxqgDjXwKMfwswXhNgvC7AeEOA8R8Bxn8FGG8KMN4SYEyW3H7GewQYkwswphBgTCnAeK8AYyoBxtQCjGkEGNMKMKYTYLxPgPF+Acb0AowPCDA+KMCYQYDxIQHGjAKMmQQYMwswZhFgzCrAmE2AMbsAYw4BxocFGHMKMOYSYMwtwPiIAGMeAca8AoyPCjA+JsCYT4DxcQHG/AKMBQQYnxBgfFKAsaAAYyEBxsICjE8JMD4twPiMAGMRAcYwAUZHgDFcgDFCgDFSgDFKgLGoAGO0AGOMAGMxAcZnBRiLCzCWEGAsKcD4nADj8wKMLwgwlhJgLC3AWEaA8UUBxrICjC8JML4swPiKAGM5AcbyAowVBBhfFWCsKMD4mgBjJQHG1wUYKwswviHA+KYA41sCjFUEGKsKMFYTYHxbgLG6AGMNAcaaAoy1BBjfEWB8V4DxPQHG9wUYawsw1hFgrCvAWE+AMVaAsb4AYwMBxoYCjI0EGD8QYPxQgLGxAGMTAcamAowfCTB+LMDYTICxuQBjCwHGlgKMrQQYWwswfiLA+KkAYxsBxrYCjO0EGD8TYGwvwNhBgLGjAGMnAcbOAoxdBBi7CjB2E2DsLsDYQ4CxpwBjLwHG3gKMfQQY+wow9hNg7C/AOECAcaAA4yABxsECjEMEGIcKMA4TYBwuwPi5AOMIAcaRAoyjBBhHCzCOEWAcK8A4ToBxvADjBAHGiQKMkwQYJwswThFgnCrAOE2AcboA4wwBxi8EGGcKMM4SYJwtwDhHgHGuAOM8Acb5AoxfCjAuEGBcKMC4SIBxsQDjEgHGpQKMywQYlwswrhBgXCnAuEqAcbUA4xoBxrUCjOsEGNcLMG4QYNwowLhJgHGzAOMWAcatAozbBBi3CzDuEGDcKcC4S4BxtwDjHgHGvQKM+wQY9xMYGZzZU3M4k0E5Y8z/nM//ff4Mt18vcV8sdX+Xub/L3d8V7u9K93eV+7va/V3j/q51f9e5v+vd3w3u70b3d5P7u/n2Ilsy3F40xe3/mkXz/s/flsbzt2Xx/G15PH9bEc/fVsbzt1Xx/G11PH9bE8/f1sbzt3Xx/G19PH/bEM/fNsbzt03x/G1zPH/bcvtvXrBCkyAirGhkZGx0eKwT4dQOCy9WJyYqLDKqTtEYJ8aJiomqFx4TEREbExkTXaxOseiwYk5kRKxTP6pYRGx98xPmDHfXyJEmWbLkyORywsKGAxjr315uawZcQYVe160h1zU56Lp6zJ+7a+RMg1vPrGV4UyDjZB4+Ba4VGqeEft5tpJhvI9aSF3NojJy4XEKthYzRdlKMthPrcoS7Rm5gXZq1thPqcgRwre3AmO8gxXxHSMy9nxTg2OcA92PUWjtx1zQi9PqhawdZN7twn9lJloywieDyGUbUjPA+925S/exOxPWzB3dNw+PLpYR6gTdz0F4wArgWckbsJeX4XqIXjHTXyAPMSbPWXoIXjASutRcY832kmO/7f/h6WMJ+HFOTewg9ProqdgNIZbbFgD+394OeY/uB7gGMtQO8fk7o9UP3SmSfPGC5B5pcOUCola9I/fIrHzzwYPDrJyy+uglL2I9j/HnjA1gfN3vraM4lQC/4OgNnJqB7GvLe5htyT0O5bmJx028z2N0XTI18kwGbf9963+glw3526Hx14uruW8J8PUSar4eI96Cj3DUeBfYhs9Yhwj3oKOBah4B5/x0p5t8R70FNHz5IyP8XLL8HZXl1KZF70MNARwDG2iklcg+K7JNHLL8HNblyhFAr35P65fc+3IP+EPz6ibfvJvS7CM8x0N9FjAKuhXSCo6QcP0r0wNHuGvmA/c2sdZTggaOBax0FxvwYKebHiB5oavIHQo8va7kHsmbbSyIeeBw4x4Cxdl4S8UBknzxhuQeaXDlBqJUfSf3yRx888Kfg1w/FAz3HQHvgaOBaSCc4Scrxk0QPHOOukR/Y38xaJwkeOAa41klgzE+RYn6K6IGmJn8i9Pjylnsga7ZVEPHA08A5Boy1U0HEA5F98mfLPdDkys+EWjlD6pdnfPDAs8GvH4oHeo6B9sAxwLWQTnCOlOPniB441l3jCWB/M2udI3jgWOBa54Ax/4UU81+IHmhq8iyhx1ey3ANZs+11EQ/8FTjHgLF2XhfxQGSfPG+5B5pcOU+olQukfnnBBw/8Lfj1Q3s2+Sj42eSlhGeTlwK94KLlz4Waa3gMHJNlhJgsA8bkkkBMjoNjspwQk+XAmFwWiMkJcExWEGKyAhiT3wVi8iM4JisJMVkJjMkfAjH5CRyTVYSYrALG5E+BmJwEx2Q1ISargTG5IhCTU+CYrCHEZA0wJlcFYnIaHJO1hJisBcbkL4GY/AyOyTpCTNYBY/K3QEzOgGOynhCT9cCYXBOIyVlwTDYQYrIBGJPrAjE5B47JRkJMNgJjckMgJr+AY7KJEJNNwJj8IxCTX8Ex2UyIyWZgTP4FxsR8v5E+2X//gW1z1t/sO5t9TrOvZvZxzL6BuU8190XGw433Gc8wc830UVO3Jk/+9RZJhv8uyfybAd8Qvku6CbyWyW9fy//9Qa3PurY3M9jPeAvNiE4k7yGYxPLQSrKH7B4MplncAn5es575zIyiZvyjJYYVneP3AGMe+sW7WTfv7XWTg5nHuWsUBD50YdYyvOg6HwdcKzROCf28yUkxT/4Q7+E004d/I8hCS8sfTmM9cNNK5OG0FLhcdYCxdlqJPJyG7JMpH8J+ZnStmFxJSZiR95L65b0P8R9OSxX8+qEcUvAcA31IYRxwLaQTpCbleGqiB4531ygM7G9mrdQEDxwPXCs1MOZpSDFPQ/RAU5OpCD2+jeUeyJptbUU8MC1wjgFj7bQV8UBkn0xnuQeaXElHqJX7SP3yPh888P7g1w/FAz3HQHvgeOBaSCdIT8rx9EQPnOCu8TSwv5m10hM8cAJwrfTAmD9AivkDRA80NXk/ocd3sNwDWbOto4gHPgicY8BYOx1FPBDZJzNY7oEmVzIQauUhUr98yAcPzBj8+qF4oOcYaA+cAFwL6QSZSDmeieiBE901igD7m1krE8EDJwLXygSMeWZSzDMTPdDUZEZCj+9quQeyZls3EQ/MApxjwFg73UQ8ENkns1rugSZXshJqJRupX2bzwQOzB79+KH3Xe2g5OWFdVGy7W34NzbOM8V3DBD/oD8xp26+huX45CD3tYWBPM/FVfHgeeQ1YjDnRjOhEmpgs7mYssdw85RJ4eD4n8POa9XIpPDxPHDi57Rw4FIk21y83YeA8QpLoR4ibDqx8ypNYBOb2gZZchHzKS8qnvMSNy0nuGg7whtyslZewcTkJuFZe4Cx6lBTzR4k9xLhRdkL+97X8xoW1GdNPZOPyMWCPB8ba6SeycYnsk/ks37g0uZKPUCuPk/rl4z5sXOYPfv1QvsD2HAP9BfYk4FpIJyhAyvECRA+cbNYA9jezVgGCB04GrlUAGPMnSDF/guiBpibzE3r8IMs9kDXbBot44JPAOQaMtTNYxAORfbKg5R5ocqUgoVYKkfplIR88sHDw64figZ5joD1wMnAtpBM8Rcrxp4geOMVdIwrY38xaTxE8cApwraeAMX+aFPOniR5oarIwoccPt9wDWbPtcxEPfAY4x4Cxdj4X8UBknyxiuQeaXClCqJUwUr8M88EDneDXD8UDPcdAe+AU4FpIJwgn5Xg40QOnumtEA/ubWSuc4IFTgWuFA2MeQYp5BNEDTU06hB4/2nIPZM22MSIeGAmcY8BYO2NEPBDZJ6Ms90CTK1GEWilK6pdFffDA6ODXD+3Z2DyEXBorcICC8TzrOJF5EwOsF2CsnXECeRNDyJtiSQdvHOQ1YDE+a/vBG++mMbHc5BUXOHjzLPjgTXHSwRvvBz1sSgR/2NAO3ZQgDJuSJNEv6YPoP5ckLndBF3fgpjghl54n5dLzxI3Vae4axYAbBmat5wkbq9OAaz0PnEEvkGL+AnFj1ThRNCH/p1h+w8LaLJoqcqNbCjgvgLF2popsrCL7ZGnLN1ZNrpQm1EoZUr8s44NvvRj8+qF8we45BvoL9mnAtZBOUJaU42WJHjjdXaM4sL+ZtcoSPHA6cK2ywJi/RIr5S0QPNDX5IqHHf2G5B7Jm20wRD3wZOMeAsXZminggsk++YrkHmlx5hVAr5Uj9spwPHlg++PVD8UDPMdAeOB24FtIJKpByvALRA2e4a5QE9jezVgWCB84ArlUBGPNXSTF/leiBpibLE3r8XMs9kDXb5ol4YEXgHAPG2pkn4oHIPvma5R5ocuU1Qq1UIvXLSj544OvBrx+KB3qOgfbAGcC1kE5QmZTjlYke+IW7xvPA/mbWqkzwwC+Aa1UGxvwNUszfIHqgqcnXCT1+oeUeyJpti0Q88E3gHAPG2lkk4oHIPvmW5R5ocuUtQq1UIfXLKj54YNXg1w/twM1zhFxaLHBwgvEs6xKReVMNWC/AWDtLBPKmGiFv3k46cOMgrwGLsbrtB268m8bEcpNXQ+DATXXwgZsaYgduagZ/2NAO3NQkDJtaJNGv5YPov5MkLndBF3fgpgYhl94l5dK7xI3Vme4apYAbBmatdwkbqzOBa70LnEHvkWL+HnFj1ThRVUL+r7L8hoW1WbRa5Eb3feC8AMbaWS2ysYrsk7Ut31g1uVKbUCt1SP2yjg++VTf49UP5gt1zDPQX7DOBayGdoB4px+sRPXCWu0YZYH8za9UjeOAs4Fr1gDGPJcU8luiBpibrEnr8ess9kDXbNoh4YH3gHAPG2tkg4oHIPtnAcg80udKAUCsNSf2yoQ8e2Cj49UPxQM8x0B44C7gW0gk+IOX4B0QPnO2uURbY38xaHxA8cDZwrQ+AMf+QFPMPiR5oarIRocdvsdwDWbNtq4gHNgbOMWCsna0iHojsk00s90CTK00ItdKU1C+b+uCBHwW/fige6DkG2gNnA9dCOsHHpBz/mOiBc9w1Xgb2N7PWxwQPnANc62NgzJuRYt6M6IGmJj8i9Pidlnsga7btEvHA5sA5Boy1s0vEA5F9soXlHmhypQWhVlqS+mVLHzywVfDrh3bg5h1CLu0WODjBeJZ1j8i8aQ2sF2CsnT0CedOakDefJB24cZDXgMX4qe0HbrybxsRyk9dG4MDNp+ADN23EDty0Df6woR24aUsYNu1Iot/OB9H/LElc7oIu7sBNG0IutSflUnvixupcd41ywA0Ds1Z7wsbqXOBa7YEzqAMp5h2IG6vGiVoR8v+g5TcsrM2ir0VudDsC5wUw1s7XIhuryD7ZyfKNVZMrnQi10pnULzv74Ftdgl8/lC/YPcdAf8E+F7gW0gm6knK8K9ED57lrVAD2N7NWV4IHzgOu1RUY826kmHcjeqCpyS6EHv+d5R7Imm2HRTywO3COAWPtHBbxQGSf7GG5B5pc6UGolZ6kftnTBw/sFfz6oXig5xhoD5wHXAvpBL1JOd6b6IHz3TUqAvubWas3wQPnA9fqDYx5H1LM+xA90NRkL0KPP2q5B7Jm2zERD+wLnGPAWDvHRDwQ2Sf7We6BJlf6EWqlP6lf9vfBAwcEv34oHug5BtoD5wPXQjrBQFKODyR64JfuGpWA/c2sNZDggV8C1xoIjPkgUswHET3Q1OQAQo//yXIPZM22kyIeOBg4x4Cxdk6KeCCyTw6x3ANNrgwh1MpQUr8c6oMHDgt+/dAO3HxGyKVTAgcnGM+ynhaZN8OB9QKMtXNaIG+GE/Lm86QDNw7yGrAYR9h+4Ma7aUwsN3kjBQ7cjAAfuBkpduBmVPCHDe3AzSjCsBlNEv3RPoj+mCRxuQu6uAM3Iwm5NJaUS2OJG6sL3DUqAzcMzFpjCRurC4BrjQXOoHGkmI8jbqwaJxpGyP9fLb9hYW0WnRe50R0PnBfAWDvnRTZWkX1yguUbqyZXJhBqZSKpX070wbcmBb9+KF+we46B/oJ9AXAtpBNMJuX4ZKIHLnTXeBPY38xakwkeuBC41mRgzKeQYj6F6IGmJicRevwlyz2QNdsui3jgVOAcA8bauSzigcg+Oc1yDzS5Mo1QK9NJ/XK6Dx44I/j1Q/FAzzHQHrgQuBbSCb4g5fgXRA9c5K5RBdjfzFpfEDxwEXCtL4Axn0mK+UyiB5qanEHo8Vcs90DWbLsq4oGzgHMMGGvnqogHIvvkbMs90OTKbEKtzCH1yzk+eODc4NcPxQM9x0B74CLgWkgnmEfK8XlED1zsrlEN2N/MWvMIHrgYuNY8YMznk2I+n+iBpibnEnr8dcs9kDXbboh44JfAOQaMtXNDxAORfXKB5R5ocmUBoVYWkvrlQh88cFHw64d24GYMIZf+ETg4wXiW9V+RebMYWC/AWDv/CuTNYkLeLEk6cOMgrwGLcantB268m8bEcpO3TODAzVLwgZtlYgdulgd/2FBE38R6OWHYrCCJ/gofRH9lkrjcBV3cgZtlhFxaRcqlVcSN1SXuGtWBGwZmrVWEjdUlwLVWAWfQalLMVxM3Vo0TLSLkf4pqdt+wsDaLUlbTcI81wHkBjLUDvH7UjVVkn1xr+caqyZW1hFpZR+qX63zwrfXBrx/KF+yeY6C/YF8CXAvpBBtIOb6B6IFL3TVqAvubWWsDwQOXAtfaAIz5RlLMNxI90NTkekKPT2O5B7JmW1oRD9wEnGPAWDtpRTwQ2Sc3W+6BJlc2E2plC6lfbvHBA7cGv34oHug5BtoDlwLXQjrBNlKObyN64DJ3jXeA/c2stY3ggcuAa20Dxnw7KebbiR5oanIrocent9wDWbPtAREP3AGcY8BYOw+IeCCyT+603ANNruwk1MouUr/c5YMH7g5+/VA80HMMtAcuA66FdII9pBzfQ/TA5e4a7wH7m1lrD8EDlwPX2gOM+V5SzPcSPdDU5G5Cj89ouQeyZlsmEQ/cB5xjwFg7mUQ8ENkn91vugSZX9hNq5QCpXx7wwQO/Cn790A7crCTkUmbLPzfrWdYsIvPmILBegLF2sgjkzUFC3nyddODGQV4DFuM3th+48W4aE8tN3rcCB26+AR+4+VbswM2h4A8b2oGbQ4Rh8x1J9L/zQfQPJ4nLXdDFHbj5lpBLR0i5dIS4sbrCXaM2cMPArHWEsLG6ArjWEeAM+p4U8++JG6vGib4i5H9Oy29YWJtFuURudH8AzgtgrJ1cIhuryD551PKNVZMrRwm1cozUL4/54FvHg18/lC/YPcdAf8G+ArgW0glOkHL8BNEDV7pr1AX2N7PWCYIHrgSudQIY8x9JMf+R6IGmJo8Tenxeyz2QNdseFfHAn4BzDBhr51ERD0T2yZOWe6DJlZOEWjlF6penfPDA08GvH4oHeo6B9sCVwLWQTvAzKcd/JnrgKneNWGB/M2v9TPDAVcC1fgbG/Awp5meIHmhq8jShx+e33ANZs62AiAeeBc4xYKydAiIeiOyT5yz3QJMr5wi18gupX/7igwf+Gvz6oXig5xhoD1wFXAvpBOdJOX6e6IGr3TUaAPubWes8wQNXA9c6D4z5BVLMLxA90NTkr4QeX8hyD2TNtsIiHvgbcI4BY+0UFvFAZJ+8aLkHmly5SKiVS6R+eckHD7wc/PqhHbg5TMilpwQOTjCeZX1aZN78DqwXYKydpwXy5ndC3vyRdODGQV4DFuOfth+48W4aE8tN3hWBAzd/gg/cXBE7cHM1+MOGduDmKmHY/EUS/b98EP2/k8TlLujiDtxcIeTSNVIuXSNurK5x12gE3DAwa10jbKyuAa51DTiDrpNifp24sWqc6DIh/yMsv2FhbRZFitzo3gDOC2CsnUiRjVVkn/zH8o1Vkyv/EGrlX1K//NcH37oZ/PqhfMHuOQb6C/Y1wLWQTnCLlOO3iB641l3jQ2B/M2vdInjgWuBat4AxT5aRE3Ozbt7b66J7vKnJm4QeH2O5B7JmWzERD7wHl6sOMNZOMREPRPbJ5BmxnxldKyZXDCO6VlKQ+mWKjHwPTBn8+qF4oOcYaA9cC1wL6QT3knL83ow8D1znrtEE2N/MWoYX7YHrgGuFximhnzcVKeapiB5oajIloceXtNwDWbPtOREPTA2cY8BYO8+JeCCyT6ax3ANNrqQh1EpaUr9M64MHpgt+/VA80HMMtAeuA66FdIL7SDl+H9ED17trfATsb2at+wgeuB641n3AmN9Pivn9RA80NZmO0ONLW+6BrNlWRsQD0wPnGDDWThkRD0T2yQcs90CTKw8QauVBUr980AcPzBD8+qEduPmb8D3MiwIHJxjPspYVmTcPAesFGGunrEDePETovRmBvdfMVsUDN8hrwGLMhGZEJ9L6ZHE3jYnlJi8zOCDJwdfNNIxMwM9r1jOfmVXU5gc9bLIEf9jQDtxkIQybrCTRz+qD6GdLEpe7oIs7cJOZkEvZSbmUnbixusFdoxlww8CslZ2wsboBuFZ24AzKQYp5DuLGqnGiDIT8r2D5DQtrs+hVkRvdh4HzAhhr51WRjVVkn8xp+caqyZWchFrJReqXuXzwrdzBrx/KF+yeY6C/YN8AXAvpBI+QcvwRogdudNdoAexvZq1HCB64EbjWI8CY5yHFPA/RA01N5ib0+Nct90DWbKss4oF5gXMMGGunsogHIvvko5Z7oMmVRwm18hipXz7mgwfmC379UDzQcwy0B24EroV0gsdJOf440QM3uWu0AvY3s9bjBA/cBFzrcWDM85Ninp/ogaYm8xF6fBXLPZA126qKeGAB4BwDxtqpKuKByD75hOUeaHLlCUKtPEnql0/64IEFg18/FA/0HAPtgZuAayGdoBApxwsRPXCzu8YnwP5m1ipE8MDNwLUKAWNemBTzwkQPNDVZkNDja1jugazZVlPEA58CzjFgrJ2aIh6I7JNPW+6BJleeJtTKM6R++YwPHlgk+PVDO3CTjZBLtQQOTjCeZX1HZN6EAesFGGvnHYG8CSPkjZN04MZBXgMWY7jtB268m8bEcpMXIXDgJhx84CZC7MBNZPCHDe3ATSRh2ESRRD/KB9EvmiQud0EXd+AmgpBL0aRciiZurG5x12gD3DAwa0UTNla3ANeKBs6gGFLMY4gbq8aJihDyv67lNyyszaJ6Ije6xYDzAhhrp57IxiqyTz5r+caqyZVnCbVSnNQvi/vgWyWCXz+UL9g9x0B/wb4FuBbSCUqScrwk0QO3umu0A/Y3s1ZJggduBa5VEhjz50gxf47ogaYmSxB6fEPLPZA12xqJeODzwDkGjLXTSMQDkX3yBcs98D+5QqiVUqR+WcoHDywd/PqheKDnGGgP3ApcC+kEZUg5XobogdvcNdoD+5tZqwzBA7cB1yoDjPmLpJi/SPRAU5OlCT2+ieUeyJptTUU8sCxwjgFj7TQV8UBkn3zJcg80ufISoVZeJvXLl33wwFeCXz8UD/QcA+2B24BrIZ2gHCnHyxE9cLu7RkdgfzNrlSN44HbgWuWAMS9Pinl5ogeamnyF0OObW+6BrNnWQsQDKwDnGDDWTgsRD0T2yVct90CTK68SaqUiqV9W9MEDXwt+/dAO3BQl5FJLgYMTjGdZW4nMm0rAegHG2mklkDeVCHnzetKBGwd5DViMlW0/cOPdNCaWm7w3BA7cVAYfuHlD7MDNm8EfNrQDN28Shs1bJNF/ywfRr5IkLndBF3fg5g3Gv2xHyqWqxI3VHe4anYEbBmatqoSN1R3AtaoCZ1A1UsyrETdWjRO9Rsj/dpbfsLA2iz4TudF9GzgvgLF2PhPZWEX2yeqWb6yaXKnO+NfOSP2yhg++VTP49UP5gt1zDPQX7DuAayGdoBYpx2sRPXCnu0ZXYH8za9UieOBO4Fq1gDF/hxTzd4geaGqyJqHHd7LcA1mzrbOIB74LnGPAWDudRTwQ2Sffs9wDTa68R6iV90n98n0fPLB28OuH4oGeY6A9cCdwLaQT1CHleB2iB+5y1+gO7G9mrToED9wFXKsOMOZ1STGvS/RAU5O1CT2+u+UeyJptPUQ8sB5wjgFj7fQQ8UBkn4y13ANNrsQSaqU+qV/W98EDGwS/fige6DkG2gN3AddCOkFDUo43JHrgbneNnsD+ZtZqSPDA3cC1GgJj3ogU80ZEDzQ12YDQ4/tY7oGs2dZXxAM/AM4xYKydviIeiOyTH1rugSZXPiTUSmNSv2zsgwc2CX790A7cVCHkUj+BgxOMZ1n7i8ybpsB6Acba6S+QN00JefNR0oEbB3kNWIwf237gxrtpTCw3ec0EDtx8DD5w00zswE3z4A8b2oGb5ox/hYIk+i18EP2WSeJyF3RxB26aMU6Yk3KpFXFjdY+7Rm/ghoFZqxVhY3UPcK1WwBnUmhTz1sSNVeNETQj5P9TyGxbWZtEwkRvdT4DzAhhrZ5jIxiqyT35q+caqyZVPCbXShtQv2/jgW22DXz+UL9g9x0B/wb4HuBbSCdqRcrwd0QP3umv0BfY3s1Y7ggfuBa7VDhjzz0gx/4zogaYm2xJ6/EjLPZA120aJeGB74BwDxtoZJeKByD7ZwXIPNLnSgVArHUn9sqMPHtgp+PVD8UDPMdAeuBe4FtIJOpNyvDPRA/e5a/QH9jezVmeCB+4DrtUZGPMupJh3IXqgqclOhB4/znIPZM228SIe2BU4x4CxdsaLeCCyT3az3ANNrnRjHMoj9cvuPnhgj+DXD8UDPcdAe+A+4FpIJ+hJyvGeRA/c764xENjfzFo9CR64H7hWT2DMe5Fi3ovogaYmexB6/GTLPZA126aIeGBv4BwDxtqZIuKByD7Zx3IPNLnSh3E4jdQv+/rggf2CXz+0AzctCbk0VeDgBONZ1mki86Y/sF6AsXamCeRNf0LeDEg6cOMgrwGLcaDtB268m8bEcpM3SODAzUDwgZtBYgduBgd/2NAO3AwmDJshJNEf4oPoD00Sl7ugiztwM4jx4D0pl4YRN1YPuGsMBm4YmLWGETZWDwDXGgacQcNJMR9O3Fg1TtSPkP+zLb9hYW0WzRG50f0cOC+AsXbmiGysIvvkCMs3Vk2ujGA8jE3qlyN98K1Rwa8fyhfsnmOgv2A/AFwL6QSjSTk+muiBX7lrDAX2N7PWaIIHfgVcazQw5mNIMR9D9EBTk6MIPf5Lyz2QNdsWiHjgWOAcA8baWSDigcg+Oc5yDzS5Mo7xUDKpX473wQMnBL9+KB7oOQbaA78CroV0gomkHJ9I9MCD7hrDgf3NrDWR4IEHgWtNBMZ8Einmk4geaGpyAqHHL7HcA1mzbamIB04GzjFgrJ2lIh6I7JNTLPdAkytTGA/HkfrlVB88cFrw64figZ5joD3wIHAtpBNMJ+X4dKIHfu2uMQL5fUeaOF60B34NXGs6MOYzSDGfQfRAU5PTCD1+peUeyJptq0Q88AvgHAPG2lkl4oHIPjnTcg80uTKTUCuzSP1ylg8eODv49UN5Htg8h4d8hpH1jOicjHbPL/O55xA+99ykgxjO3Iz2M86z/SCGdzORWOR/vsBBjHnggxjzSQcx0J/d5CFyYLOE6EtC4zE/aPlZALyW+ari1nq8qt1D28jPAkLebBQ4Nfol4XNvErnZXgisF2CsndDrl7AN3rpOSneNVCG5E/qDzqeF4BtH72dRRiLwooz4dRcDBzrrcy8WkYQpbpNanAG33mx3rUUZCN+wWy6aU8HXcQ7pOi61/DpOA1/HuaTruMzy6zgdfB3nka7jcsuv4wzwdZxPuo4rLL+OX4Cv45ek67jS8us4E3wdF5Cu4yrLr+Ms8HVcSLqOq8HSnylZHOPXGeK+LTKvL4a8vhTy+nLI699DXv8R8vrPkNdXQl5fDXn9V8jrv0NeXwt5fT3k9Y2Q1/+EvP435PWSjP99vTTk9bKQ18tDXq8Ieb0y5PWqkNerb79e4/53rfu7zv1d7/5ucH83ur+b3N/Nt72esVmwmLBZsIX8jQ5iQ5XxubcCNx9S3v7c3gbJf3LFa0jJOPmQJRk2bgzGrAKM2QQYswsw5hBgfFiAMacAYy4BxtwCjI8IMOYRYMwrwPioAONjAoz5BBgfF2DML8BYQIDxCQHGJwUYCwowFhJgLCzA+JQA49MCjM8IMBYRYAwTYHQEGMMFGCMEGCMFGKMEGIsKMEYLMMYIMBYTYHxWgLG4AGMJAcaSAozPCTA+L8D4ggBjKQHG0gKMZQQYXxRgLCvA+JIA48sCjK8IMJYTYCwvwFhBgPFVAcaKAoyvCTBWEmB8XYCxsgDjGwKMbwowviXAWEWAsaoAYzUBxrcFGKsLMNYQYKwpwFhLgPEdAcZ3BRjfE2B8X4CxtgBjHQHGugKM9QQYYwUY6wswNhBgbCjA2EiA8QMBxg8FGBsLMDYRYGwqwPiRAOPHAozNBBibCzC2EGBsKcDYSoCxtQDjJwKMnwowthFgbCvA2E6A8TMBxvYCjB0EGDsKMHYSYOwswNhFgLGrAGM3AcbuAow9BBh7CjD2EmDsLcDYR4CxrwBjPwHG/gKMAwQYBwowDhJgHCzAOESAcagA4zABxuECjJ8LMI4QYBwpwDhKgHG0AOMYAcaxAozjBBjHCzBOEGCcKMA4SYBxsgDjFAHGqQKM0wQYpwswzhBg/EKAcaYA4ywBxtkCjHMEGOcKMM4TYJwvwPilAOMCAcaFAoyLBBgXCzAuEWBcKsC4TIBxuQDjCgHGlQKMqwQYVwswrhFgXCvAuE6Acb0A4wYBxo0CjJsEGDcLMG4RYNwqwLhNgHG7AOMOAcadAoy7BBh3CzDuEWDcK8C4T4BxvwDjAQHGrwQYDwowfi3A+I0A47cCjIcEGL8TYDwswHhEgPF7AcYfBBiPCjAeE2A8LsB4QoDxRwHGnwQYTwownhJgPC3A+LMA4xkBxrMCjOcEGH8RYPxVgPG8AOMFAcbfBBgvCjBeEmC8LMD4uwDjHwKMfwowXhFgvCrA+JcA498CjNcEGK8LMN4QYPxHgPFfAcabAoy3BBjNgrYz3iPAmFyAMYUAY0oBxnsFGFMJMKYWYEwjwJhWgDGdAON9Aoz3CzCmF2B8QIDxQQHGDAKMDwkwZhRgzCTAmFmAMYsAY1YBxmwCjNkFGHMIMD4swJhTgDGXAGNuAcZHBBjzCDDmFWB8VIDxMQHGfAKMjwsw5hdgLCDA+IQA45MCjAUFGAsJMBYWYHxKgPFpAcZnBBiLCDCGCTA6AozhAowRAoyRAoxRAoxFBRijBRhjBBiLCTA+K8BYXICxhABjSQHG5wQYnxdgfEGAsZQAY2kBxjICjC8KMJYVYHxJgPFlAcZXBBjLCTCWF2CsIMD4qgBjRQHG1wQYKwkwvi7AWFmA8Q0BxjcFGN8SYKwiwFhVgLGaAOPbAozVBRhrCDDWFGCsJcD4jgDjuwKM7wkwvi/AWFuAsY4AY10BxnoCjLECjPUFGBsIMDYUYGwkwPiBAOOHAoyNBRibCDA2FWD8SIDxYwHGZgKMzQUYWwgwthRgbCXA2FqA8RMBxk8FGNsIMLYVYGwnwPiZAGN7AcYOAowdBRg7CTB2FmDsIsDYVYCxmwBjdwHGHgKMPQUYewkw9hZg7CPA2FeAsZ8AY38BxgECjAMFGAcJMA4WYBwiwDhUgHGYAONwAcbPBRhHCDCOFGAcJcA4WoBxjADjWAHGcQKM4wUYJwgwThRgnCTAOFmAcYoA41QBxmkCjNMFGGcIMH4hwDhTgHGWAONsAcY5AoxzBRjnCTDOF2D8UoBxgQDjQgHGRQKMiwUYlwgwLhVgXCbAuFyAcYUA40oBxlUCjKsFGNcIMK4VYFwnwLhegHGDAONGAcZNAoybBRi3CDBuFWDcJsC4XYBxhwDjTgHGXQKMuwUY9wgw7hVg3CfAuF+A8YAA41cCjAcFGL8WYPxGgPFbAcZDAozfCTAeFmA8IsD4vQDjDwKMRwUYjwkwHhdgPCHA+KMA408CjCcFGE8JMJ4WYPxZgPGMAONZAcZzAoy/CDD+KsB4XoDxggDjbwKMFwUYLwkwXhZg/F2A8Q8Bxj8FGK8IMF4VYPxLgPFvAcZrAozXBRhvCDD+I8D4rwDjTQHGWwKMyZLbz3iPAGNyAcYUAowpBRjvFWBMJcCYWoAxjQBjWgHGdAKM9wkw3i/AmF6A8QEBxgcFGDMIMD4kwJhRgDGTAGNmAcYsAoxZBRizCTBmF2DMIcD4sABjTgHGXAKMuQUYHxFgzCPAmFeA8VEBxscEGPMJMD4uwJhfgLGAAOMTAoxPCjAWFGAsJMBYWIDxKQHGpwUYnxFgLCLAGCbA6AgwhgswRggwRgowRgkwFhVgjBZgjBFgLCbA+KwAY3EBxhICjCUFGJ8TYHxegPEFAcZSAoylBRjLCDC+KMBYVoDxJQHGlwUYXxFgLCfAWF6AsYIA46sCjBUFGF8TYKwkwPi6AGNlAcY3BBjfFGB8S4CxigBjVQHGagKMbwswVhdgrCHAWFOAsZYA4zsCjO8KML4nwPi+AGNtAcY6Aox1BRjrCTDGCjDWF2BsIMDYUICxkQDjBwKMHwowNhZgbCLA2FSA8SMBxo8FGJsJMDYXYGwhwNhSgLGVAGNrAcZPBBg/FWBsI8DYVoCxnQDjZwKM7QUYOwgwdhRg7CTA2FmAsYsAY1cBxm4CjN0FGHsIMPYUYOwlwNhbgLGPAGNfAcZ+Aoz9BRgHCDAOFGAcJMA4WIBxiADjUAHGYQKMwwUYPxdgHCHAOFKAcZQA42gBxjECjGMFGMcJMI4XYJwgwDhRgHGSAONkAcYpAoxTBRinCTBOF2CcIcD4hQDjTAHGWQKMswUY5wgwzhVgnCfAOF+A8UsBxgUCjAsFGBcJMC4WYFwiwLhUgHGZAONyAcYVAowrBRhXCTCuFmBcI8C4VoBxnQDjegHGDQKMGwUYNwkwbhZg3CLAuFWAcZsA43YBxh0CjDsFGHcJMO4WYNwjwLhXgHGfAON+AiODM3tqDmcyKGdd8z/n83+fP8Pt19syJku23f3d4f7udH93ub+73d897u9e93ef+7vf/T3g/n7l/h50f792f79xf7/NGLfGoYy3F01x+79m0bz/87ft8fxtRzx/2xnP33bF87fd8fxtTzx/2xvP3/bF87f98fztQDx/+yqevx2M529fx/O3b+L527fx/O3Q7b95wQpNgoiwopGRsdHhsU6EUzssvFidmKiwyKg6RWOcGCcqJqpeeExERGxMZEx0sTrFosOKOZERsU79qGIRsfXNT5jzjbvGqDTJkiVHJpcTFvYNgLH+7eW+y4grqNDr+l3IdU0Ouq4e87fuGmPS4NYzaxneFMg4uZH6FrhWaJwS+nkPk2J+mFhLXsyhMXLicgm1FjJGR0gxOkKsy0PuGuOAdWnWOkKoy0PAtY4AY/49Kebfh8Tc+0kBjv0ocD9GrfUD7ppGhF4/dO0g6+Yo7jM7yZLhJd7ExDCiZoT3uY+R6udYIq6f47hrGh5fLiXUC7yZg/aCQ8C1kDPiBCnHTxC94Dt3jQnAnDRrnSB4wXfAtU4AY/4jKeY//j98PSxhP46pyeOEHn+0GnYDSGa2gT+394OeYz8B3QMYawd4/ZzQ64fulcg+edJyDzS5cpJQK6dI/fKUDx54Ovj1ExZf3YQl7Mcx/vx1BqyPm711NOc2oBf8nJEzE9A9DXlvc4bc01Cum1jc9GxGu/uCqZEzGbH5dzbj/5WKvS7qxNXdWcJ8PUear+eI96CH3TUmAfuQWesc4R70MHCtc8C8/4UU81+I96CmD58m5P/Plt+Dsrz6jMg96K9ARwDG2jkjcg+K7JPnLb8HNblynlArF0j98oIP96C/Bb9+4u27Cf0uwnMM9HcRh4FrIZ3gIinHLxI98Ii7xhRgfzNrXSR44BHgWheBMb9EivklogeamvyN0ON/tdwDWbPtvIgHXgbOMWCsnfMiHojsk79b7oEmV34n1MofpH75hw8e+Gfw64figZ5joD3wCHAtpBNcIeX4FaIHfu+uMQ3Y38xaVwge+D1wrSvAmF8lxfwq0QNNTf5J6PGXLPdA1my7LOKBfwHnGDDWzmURD0T2yb8t90CTK38TauUaqV9e88EDrwe/fige6DkG2gO/B66FdIIbpBy/QfTAH9w1ZgD7m1nrBsEDfwCudQMY839IMf+H6IGmJq8TevwVyz2QNduuinjgv8A5Boy1c1XEA5F98qblHmhy5SahVm6R+uUtHzwwWabA1w/t2eSL4GeTtxOeTd4O9IJ7Mtkfk0vgmOwgxGQHMCbJBWJyGRyTnYSY7ATGJIVATH4Hx2QXISa7gDFJKRCTP8Ax2U2IyW5gTO4ViMmf4JjsIcRkDzAmqQRicgUck72EmOwFxiS1QEyugmOyjxCTfcCYpBGIyV/gmOwnxGQ/MCZpBWLyNzgmBwgxOQCMSTqBmFwDx+QrQky+AsbkPoGYXAfH5CAhJgeBMblfICY3wDH5mhCTr4ExSS8Qk3/AMfmGEJNvgDF5QCAm/4Jj8i0hJt8CY/IgMCbm+40Myf77D2ybs/5m39nsc5p9NbOPY/YNzH2quS8yHm68z3iGmWumj5q6NXliuLwf9HdJZ27/GwTo75IyAK9l8pDrGPqDWp91bTNksp/xITQjOpG8h2ASy0MrGS0fDKZZhCYN4h8tyZiJU9SMf7TEsKJzPBMw5qFfvJt1895eNzmY+ai7xkzgQxdmLcOLrvOjwLUyAfM+MynmmTPxHk4zfTgZIf8fftviuic+cJPzbbwgJEuGf7gmC/DhGmCsHeD1oz6chuyTWTNhPzO6VkyuZCX0iGykfpktE//htOzBrx/KIQXPMdCHFI4C10I6QQ5SjucgeuAxd43ZwP5m1spB8MBjwLVyAGP+MCnmDxM90NRkdkKPz2O5B7JmW14RD8wJnGPAWDt5RTwQ2SdzWe6BJldyEWolN6lf5vbBAx8Jfv1QPNBzDLQHHgOuhXSCPKQcz0P0wOPuGnOB/c2slYfggceBa+UBxjwvKeZ5iR5oavIRQo9/3HIPZM22/CIe+ChwjgFj7eQX8UBkn3zMcg80ufIYoVbykfplPh888PHg1w/FAz3HQHvgceBaSCfIT8rx/EQPPOGuMR/Y38xa+QkeeAK4Vn5gzAuQYl6A6IGmJh8n9PiClnsga7YVEvHAJ4BzDBhrp5CIByL75JOWe6DJlScZPYLULwv64IGFgl8/lL7rPbScnLAuKraFLb+G5lnG+K5hgj83MKdtv4bm+hUm9LSnkh6ed5DXgMX4tO0Pz59IFnczllhunp4ReHj+afDD888oPDxPHDhF7Bw4FIk2168IYeCEkSQ6jLjpwMonJ7EIzO0DLc8Q8imclE/hxI3LH901FgBvyM1a4YSNyx+Ba4UDZ1EEKeYRxB5i3KgQIf8dy29cWJsx4SIbl5HAHg+MtRMusnGJ7JNRlm9cmlyJItRKUVK/LOrDxmV08OuH8gW25xjoL7B/BK6FdIIYUo7HED3wJ3eNRcD+ZtaKIXjgT8C1YoAxL0aKeTGiB5qajGb0eMs9kDXbokU88FngHAPG2okW8UBknyxuuQeaXClOqJUSpH5ZwgcPLBn8+qF4oOcYaA/8CbgW0gmeI+X4c0QPPOmusQTY38xazxE88CRwreeAMX+eFPPniR5oarIkoccXt9wDabNNxANfAM4xYKydEiIeiOyTpSz3QJMrpQi1UprUL0v74IFlgl8/FA/0HAPtgSeBayGd4EVSjr9I9MBT7hrLgP3NrPUiwQNPAdd6ERjzsqSYlyV6oKnJMoQe/4LlHsiabaVEPPAl4BwDxtopJeKByD75suUeaHLlZUKtvELql6/44IHlgl8/tGdjHcY9hcABCsbzrGVE5k15YL0AY+2UEcib8oS8qZB08MZBXgMW46u2H7zxbhoTy01eRYGDN6+CD95UJB288X7Qw+a14A8b2qGb1wjDphJJ9Cv5IPqvJ4nLXdDFHbipSMilyqRcqkzcWD3trrECuGFg1qpM2Fg9DVyrMnAGvUGK+RvEjVXjROUI+V/O8hsW1mZReZEb3TeB8wIYa6e8yMYqsk++ZfnGqsmVtwi1UoXUL6v44FtVg18/lC/YPcdAf8F+GrgW0gmqkXK8GtEDf3bXWAXsb2atagQP/Bm4VjVgzN8mxfxtogeamqxK6PGvWe6BrNlWScQDqwPnGDDWTiURD0T2yRqWe6DJlRqEWqlJ6pc1ffDAWsGvH4oHeo6B9sCfgWshneAdUo6/Q/TAM+4aa4D9zaz1DsEDzwDXegcY83dJMX+X6IGmJmsRevyblnsga7a9JeKB7wHnGDDWzlsiHojsk+9b7oEmV94n1EptUr+s7YMH1gl+/VA80HMMtAeeAa6FdIK6pByvS/TAs+4a64D9zaxVl+CBZ4Fr1QXGvB4p5vWIHmhqsg6hx79tuQeyZlt1EQ+MBc4xYKyd6iIeiOyT9S33QJMr9Qm10oDULxv44IENg18/tAM3rxNyqYbAwQnGs6w1ReZNI2C9AGPt1BTIm0aEvPkg6cCNg7wGLMYPbT9w4900JpabvMYCB24+BB+4aSx24KZJ8IcN7cBNE8KwaUoS/aY+iP5HSeJyF3RxB24aE3LpY1IufUzcWD3nrrEBuGFg1vqYsLF6DrjWx8AZ1IwU82bEjVXjRA0ZX55ZfsPC2iyqI3Kj2xw4L4CxduqIbKwi+2QLyzdWTa60INRKS1K/bOmDb7UKfv1QvmD3HAP9Bfs54FpIJ2hNyvHWRA/8xV1jE7C/mbVaEzzwF+BarYEx/4QU80+IHmhqshWhx9e33ANZs62BiAd+CpxjwFg7DUQ8ENkn21jugSZX2hBqpS2pX7b1wQPbBb9+KB7oOQbaA38BroV0gs9IOf4Z0QN/ddfYAuxvZq3PCB74K3Ctz4Axb0+KeXuiB5qabEfo8R9a7oGs2dZYxAM7AOcYMNZOYxEPRPbJjpZ7oMmVjoRa6UTql5188MDOwa8figd6joH2wF+BayGdoAspx7sQPfC8u8Y2YH8za3UheOB54FpdgDHvSop5V6IHmprszHguwnIPZM22ZiIe2A04x4CxdpqJeCCyT3a33ANNrnQn1EoPUr/s4YMH9gx+/dAO3HxEyKXmAgcnGM+ythCZN72A9QKMtdNCIG96EfKmd9KBGwd5DViMfWw/cOPdNCaWm7y+Agdu+oAP3PQVO3DTL/jDhnbgph9h2PQniX5/H0R/QJK43AVd3IGbvoRcGkjKpYHEjdUL7ho7gBsGZq2BhI3VC8C1BgJn0CBSzAcRN1aNE/Uk5H8by29YWJtFbUVudAcD5wUw1k5bkY1VZJ8cYvnGqsmVIYRaGUrql0N98K1hwa8fyhfsnmOgv2C/AFwL6QTDSTk+nOiBv7lr7AL2N7PWcIIH/gZcazgw5p+TYv450QNNTQ4j9PgOlnsga7Z1FPHAEcA5Boy101HEA5F9cqTlHmhyZSShVkaR+uUoHzxwdPDrh+KBnmOgPfA34FpIJxhDyvExRA+86K6xB9jfzFpjCB54EbjWGGDMx5JiPpbogaYmRxN6fFfLPZA127qJeOA44BwDxtrpJuKByD453nIPNLkynlArE0j9coIPHjgx+PVD8UDPMdAeeBG4FtIJJpFyfBLRAy+5a+wD9jez1iSCB14CrjUJGPPJpJhPJnqgqcmJhB7fy3IPZM223iIeOAU4x4CxdnqLeCCyT0613ANNrkwl1Mo0Ur+c5oMHTg9+/dAO3Awg5FIfgYMTjGdZ+4rMmxnAegHG2ukrkDczCHnzRdKBGwd5DViMM20/cOPdNCaWm7xZAgduZoIP3MwSO3AzO/jDhnbgZjZh2Mwhif4cH0R/bpK43AVd3IGbWYRcmkfKpXnEjdXL7hoHgBsGZq15hI3Vy8C15gFn0HxSzOcTN1aNE00n5P9gy29YWJtFQ0RudL8EzgtgrJ0hIhuryD65wPKNVZMrCwi1spDULxf64FuLgl8/lC/YPcdAf8F+GbgW0gkWk3J8MdEDf3fXOAjsb2atxQQP/B241mJgzJeQYr6E6IGmJhcRevznlnsga7aNEPHApcA5Boy1M0LEA5F9cpnlHmhyZRmhVpaT+uVyHzxwRfDrh+KBnmOgPfB34FpIJ1hJyvGVRA/8w13jG2B/M2utJHjgH8C1VgJjvooU81VEDzQ1uYLQ48dY7oGs2TZWxANXA+cYMNbOWBEPRPbJNZZ7oMmVNYRaWUvql2t98MB1wa8figd6joH2wD+AayGdYD0px9cTPfBPd41DwP5m1lpP8MA/gWutB8Z8AynmG4geaGpyHaHHT7TcA1mzbZKIB24EzjFgrJ1JIh6I7JObLPdAkyubCLWymdQvN/vggVuCXz+0AzdzCbk0WeDgBONZ1iki82YrsF6AsXamCOTNVkLebEs6cOMgrwGLcbvtB268m8bEcpO3Q+DAzXbwgZsdYgdudgZ/2NAO3OwkDJtdJNHf5YPo704Sl7ugiztws4OQS3tIubSHuLF6xV3jMHDDwKy1h7CxegW41h7gDNpLivle4saqcaIthPyfafkNC2uzaJbIje4+4LwAxtqZJbKxiuyT+y3fWDW5sp9QKwdI/fKAD771VfDrh/IFu+cY6C/YrwDXQjrBQVKOHyR64FV3je+B/c2sdZDggVeBax0ExvxrUsy/JnqgqcmvGP/wgOUeyJpt80U88BvgHAPG2pkv4oHIPvmt5R5ocuVbQq0cIvXLQz544HfBrx+KB3qOgfbAq8C1kE5wmJTjh4ke+Je7xlFgfzNrHSZ44F/AtQ4DY36EFPMjRA80NfkdoccvstwDWbNtsYgHfg+cY8BYO4tFPBDZJ3+w3ANNrvxAqJWjpH551AcPPBb8+qF4oOcYaA/8C7gW0gmOk3L8ONED/zbrA/ubWes4wQP/Bq51HBjzE6SYnyB6oKnJY4x/XMNyD2TNthUiHvgjcI4BY+2sEPFAZJ/8yXIPNLnyE6FWTpL65UkfPPBU8OuHduBmNyGXVgocnGA8y7pKZN6cBtYLMNbOKoG8OU3Im5+TDtw4yGvAYjxj+4Eb76YxsdzknRU4cHMGfODmrNiBm3PBHza0AzfnCMPmF5Lo/+KD6P+aJC53QRd34OYsIZfOk3LpPHFj9Zq7xo/ADQOz1nnCxuo14FrngTPoAinmF4gbq8aJThHyf4PlNyyszaKNIje6vwHnBTDWzkaRjVVkn7xo+caqyZWLhFq5ROqXl3zwrcvBrx/KF+yeY6C/YL8GXAvpBL+Tcvx3ogded9c4CexvZq3fCR54HbjW78CY/0GK+R9EDzQ1eZnQ47da7oGs2bZNxAP/BM4xYKydbSIeiOyTVyz3QJMrVwi1cpXUL6/64IF/Bb9+KB7oOQbaA68D10I6wd+kHP+b6IE33DVOA/ubWetvggfeAK71NzDm10gxv0b0QFOTfxF6/C7LPZA123aLeOB14BwDxtrZLeKByD55w3IPNLlyg1Ar/5D65T8+eOC/wa8figd6joH2wBvAtZBOcJOU4zeJHviPu8YZYH8za90keOA/wLVuAmN+ixTzW0QPNDX5L6HH77fcA1mz7YCIBybLjLuWwFg7B0Q8ENkn78mM/czoWjG5YhjRtZI8M6dfmnXzJrvzB10/KYJfP7QDN78S+u5XAgcnGM+yHhSZNymB9QKMtXNQIG9SEnrvvcDea2ar4oEb5DVgMaZCM8I3c5LF3TQmlpu81OCAJAdfN9MwQpMGceDGfGZWUZsf9LBJE/xhQztwk4YwbNKSRD+tD6KfLklc7oIu7sBNakIu3UfKpfsy8zZW/3XXOAfcMDBrGV70zP0XuNZ9wBl0Pynm92fmbaz+x4kI+X/Y8hsW1mbREZEb3fTAeQGMtXNEZGMV2ScfsHxj1eTKA4RaeZDULx/0wbcyBL9+KF+we46B/oL9X+BaSCd4iJTjDxE98Ka7xq/A/mbWeojggTeBaz0EjHlGUswzEj3Q1GQGQo8/ZrkHsmbbcREPzAScY8BYO8dFPBDZJzNb7oEmVzITaiULqV9m8cEDswa/fige6DkG2gNvAtdCOkE2Uo5nI3rgLXeNC8D+ZtbKRvDAW8C1sgFjnp0U8+xEDzQ1mZXQ409a7oGs2XZKxANzAOcYMNbOKREPRPbJhy33QJMrDxNqJSepX+b0wQNzBb9+KB7oOQbaA28B10I6QW5SjucmeqB5g4vIf2AsTRwv2gMNJ2qt3MCYP0KK+SNEDzQ1mYvQ489a7oGs2XZOxAPzAOcYMNbOOREPRPbJvJZ7oMmVvIRaeZTULx/1wQMfC3790A7cpCPk0i8CBycYz7L+KjJv8gHrBRhr51eBvMlHyJvHkw7cOMhrwGLMb/uBG++mMbHc5BUQOHCTH3zgpoDYgZsngj9saAduniAMmydJov+kD6JfMElc7oIu7sBNAUIuFSLlUiHixuo97htcBm4YmLUKETZW7wHO3ELAGVSYFPPCxI1V40SPEfL/suU3LKzNot9FbnSfAs4LYKyd30U2VpF98mnLN1ZNrjxNqJVnSP3yGR98q0jw64fyBbvnGOgv2GFO4NzpbgnNkzBSjocRPTC5+wZ/APubWSuM4IHJgR4YBoy5Q4q5Q/RAU5NFCD3+quUeyJptf4l4YDhwjgFj7fwl4oHIPhlhuQeaXIkg1EokqV9G+uCBUcGvH4oHeo6B9sDkQA9EOkFRUo4XJXpgCvcNriD/F7zSxPGiPTAF0AOLAmMeTYp5NNEDTU1GEXr8Dcs9kDXb/hHxwBjgHAPG2vlHxAORfbKY5R5ocqUYoVaeJfXLZ33wwOLBrx+KB3qOgfbAFEAPRDpBCVKOlyB6YEr3Df4C9jezVgmCB6YEemAJYMxLkmJekuiBpiaLE3p8sup2eyBrtt0D/tzeD3qOPYd0D9xndoDXj+qByD75vOUeaHLleUKtvEDqly/44IGlgl8/tAM3BQm5lNzyz816ljWFyLwpDawXYKydFAJ5U5qQN2WSDtw4yGvAYnzR9gM33k1jYrnJKytw4OZF8IGbsmIHbl4K/rChHbh5iTBsXiaJ/ss+iP4rSeJyF3RxB27KEnKpHCmXyhE3Vu913+AacMPArFWOsLF6L3DmlgPOoPKkmJcnbqwaJypFyP+0lt+wsDaL0onc6FYAzgtgrJ10IhuryD75quUbqyZXXiXUSkVSv6zog2+9Fvz6oXzB7jkG+gt2mBM4d7pbQvOkEinHKxE9MJX7BjeA/c2sVYnggamAHlgJGPPXSTF/neiBpiZfI/T4Byz3QNZse1DEAysD5xgw1s6DIh6I7JNvWO6BJlfeINTKm6R++aYPHvhW8OuH4oGeY6A9MBXQA5FOUIWU41WIHpjafYN/gf3NrFWF4IGpgR5YBRjzqqSYVyV6oKnJtwg9PpPlHsiabZlFPLAacI4BY+1kFvFAZJ9823IPNLnyNqFWqpP6ZXUfPLBG8OuH4oGeY6A9MDXQA5FOUJOU4zWJHpjGfYNbwP5m1qpJ8MA0QA+sCYx5LVLMaxE90NRkDUKPz265B7JmWw4RD3wHOMeAsXZyiHggsk++a7kHmlx5l1Ar75H65Xs+eOD7wa8f2oGbVwi59LDAwQnGs6w5ReZNbWC9AGPt5BTIm9qEvKmTdODGQV4DFmNd2w/ceDeNieUmr57AgZu64AM39cQO3MQGf9jQDtzEEoZNfZLo1/dB9Bskictd0MUduKlHyKWGpFxqSNxYTeu+wT1pceuZtRoSNlbTAmduQ+AMakSKeSPixqpxovcJ+f+o5TcsrM2ix0RudD8AzgtgrJ3HRDZWkX3yQ8s3Vk2ufEiolcakftnYB99qEvz6oXzB7jkG+gt2mBM4d7pbQvOkKSnHmxI9MJ37BimA/c2s1ZTggemAHtgUGPOPSDH/iOiBpiabEHp8Acs9kDXbnhDxwI+BcwwYa+cJEQ9E9slmlnugyZVmhFppTuqXzX3wwBbBrx+KB3qOgfbAdEAPRDpBS1KOtyR64H3uG9wL7G9mrZYED7wP6IEtgTFvRYp5K6IHmppsQejxhS33QNZse0rEA1sD5xgw1s5TIh6I7JOfWO6BJlc+IdTKp6R++akPHtgm+PVD8UDPMdAeeB/QA5FO0JaU422JHni/+wapgf3NrNWW4IH3Az2wLTDm7Ugxb0f0QFOTbQg9PsxyD2TNNkfEAz8DzjFgrB1HxAORfbK95R5ocqU9oVY6kPplBx88sGPw64d24KYBIZfCBQ5OMJ5ljRCZN52A9QKMtRMhkDedCHnTOenAjYO8BizGLrYfuPFuGhPLTV5XgQM3XcAHbrqKHbjpFvxhQztw040wbLqTRL+7D6LfI0lc7oIu7sBNV0Iu9STlUk/ixmp69w3SAjcMzFo9CRur6YEztydwBvUixbwXcWPVOFFHQv4Xs/yGhbVZ9KzIjW5v4LwAxtp5VmRjFdkn+1i+sWpypQ+hVvqS+mVfH3yrX/Drh/IFu+cY6C/YYU7g3OluCc2T/qQc70/0wAfcN7gP2N/MWv0JHvgA0AP7A2M+gBTzAUQPNDXZj9Djn7PcA1mz7XkRDxwInGPAWDvPi3ggsk8OstwDTa4MItTKYFK/HOyDBw4Jfv1QPNBzDLQHPgD0QKQTDCXl+FCiBz7ovkF6YH8zaw0leOCDQA8cCoz5MFLMhxE90NTkEEKPL2O5B7Jm24siHjgcOMeAsXZeFPFAZJ/83HIPNLnyOaFWRpD65QgfPHBk8OuH4oGeY6A98EGgByKdYBQpx0cRPTCD+wYPAvubWWsUwQMzAD1wFDDmo0kxH030QFOTIwk9/hXLPZA128qJeOAY4BwDxtopJ+KByD451nIPNLkyllAr40j9cpwPHjg++PVDO3DTg5BL5QUOTjCeZa0gMm8mAOsFGGungkDeTCDkzcSkAzcO8hqwGCfZfuDGu2lMLDd5kwUO3EwCH7iZLHbgZkrwhw3twM0UwrCZShL9qT6I/rQkcbkLurgDN5MJuTSdlEvTiRurD7lv8BBww8CsNZ2wsfoQcOZOB86gGaSYzyBurBonGk/I/8qW37CwNoveELnR/QI4L4Cxdt4Q2VhF9smZlm+smlyZSaiVWaR+OcsH35od/PqhfMHuOQb6C3aYEzh3ultC82QOKcfnED0wo/sGmYD9zaw1h+CBGYEeOAcY87mkmM8leqCpydmEHl/Vcg9kzbZqIh44DzjHgLF2qol4ILJPzrfcA02uzCfUypekfvmlDx64IPj1Q/FAzzHQHpgR6IFIJ1hIyvGFRA/M5L5BFmB/M2stJHhgJqAHLgTGfBEp5ouIHmhqcgGhx9e03ANZs62WiAcuBs4xYKydWiIeiOyTSyz3QJMrSwi1spTUL5f64IHLgl8/FA/0HAPtgZmAHoh0guWkHF9O9MDM7htkA/Y3s9ZyggdmBnrgcmDMV5BivoLogaYmlxF6/PuWeyBrttUW8cCVwDkGjLVTW8QDkX1yleUeaHJlFaFWVpP65WofPHBN8OuH8jyweQ4P+Qwj6xnRtZntnl/mc68lfO51SQcxnHWZ7Wdcb/tBDO9mIrHI/waBgxjrwQcxNpAOYqA/u8lD5MBmCdFGQuMxP2j52QS8lhur4dbaVM3uoW3kZxMhbxoKnBrdSPjcjURutjcD6wUYayf0+iVsg7euk9JdI1VI7oT+oPNpM/jG0fvZkpkIvCUzft2twIHO+txbRSRhiduktmbErbfGXWtLRnzT22a5aC4FX8e1pOu43fLruAx8HdeRruMOy6/jcvB1XE+6jjstv44rwNdxA+k67rL8Oq4EX8eNpOu42/LruAp8HTeRruMey6/javB13Ey6jnvB0p8pWRzjzxnjvi0yr+/J9N/XyUNepwh5nTLk9b0hr1OFvE4d8jpNyOu0Ia/Thby+L+T1/SGv04e8fiDk9YMhr7dl/u/r7SGvd4S83hnyelfI690hr/eEvN57+/U+97/73d8D7u9X7u9B9/dr9/cb9/fb217P2CzYStgsOET+Rgexocr43N8BNx9SevWQ7L+xX+01pGScfMiSDBs3BmNWAcZsAozZBRhzCDA+LMCYU4AxlwBjbgHGRwQY8wgw5hVgfFSA8TEBxnwCjI8LMOYXYCwgwPiEAOOTAowFBRgLCTAWFmB8SoDxaQHGZwQYiwgwhgkwOgKM4QKMEQKMkQKMUQKMRQUYowUYYwQYiwkwPivAWFyAsYQAY0kBxucEGJ8XYHxBgLGUAGNpAcYyAowvCjCWFWB8SYDxZQHGVwQYywkwlhdgrCDA+KoAY0UBxtcEGCsJML4uwFhZgPENAcY3BRjfEmCsIsBYVYCxmgDj2wKM1QUYawgw1hRgrCXA+I4A47sCjO8JML4vwFhbgLGOAGNdAcZ6AoyxAoz1BRgbCDA2FGBsJMD4gQDjhwKMjQUYmwgwNhVg/EiA8WMBxmYCjM0FGFsIMLYUYGwlwNhagPETAcZPBRjbCDC2FWBsJ8D4mQBjewHGDgKMHQUYOwkwdhZg7CLA2FWAsZsAY3cBxh4CjD0FGHsJMPYWYOwjwNhXgLGfAGN/AcYBAowDBRgHCTAOFmAcIsA4VIBxmADjcAHGzwUYRwgwjhRgHCXAOFqAcYwA41gBxnECjOMFGCcIME4UYJwkwDhZgHGKAONUAcZpAozTBRhnCDB+IcA4U4BxlgDjbAHGOQKMcwUY5wkwzhdg/FKAcYEA40IBxkUCjIsFGJcIMC4VYFwmwLhcgHGFAONKAcZVAoyrBRjXCDCuFWBcJ8C4XoBxgwDjRgHGTQKMmwUYtwgwbhVg3CbAuF2AcYcA404Bxl0CjLsFGPcIMO4VYNwnwLhfgPGAAONXAowHBRi/FmD8RoDxWwHGQwKM3wkwHhZgPCLA+L0A4w8CjEcFGI8JMB4XYDwhwPijAONPAownBRhPCTCeFmD8WYDxjADjWQHGcwKMvwgw/irAeF6A8YIA428CjBcFGC8JMF4WYPxdgPEPAcY/BRivCDBeFWD8S4DxbwHGawKM1wUYbwgw/iPA+K8A400BxlsCjGZB2xnvEWBMLsCYQoAxpQDjvQKMqQQYUwswphFgTCvAmE6A8T4BxvsFGNMLMD4gwPigAGMGAcaHBBgzCjBmEmDMLMCYRYAxqwBjNgHG7AKMOQQYHxZgzCnAmEuAMbcA4yMCjHkEGPMKMD4qwPiYAGM+AcbHBRjzCzAWEGB8QoDxSQHGggKMhQQYCwswPiXA+LQA4zMCjEUEGMMEGB0BxnABxggBxkgBxigBxqICjNECjDECjMUEGJ8VYCwuwFhCgLGkAONzAozPCzC+IMBYSoCxtABjGQHGFwUYywowviTA+LIA4ysCjOUEGMsLMFYQYHxVgLGiAONrAoyVBBhfF2CsLMD4hgDjmwKMbwkwVhFgrCrAWE2A8W0BxuoCjDUEGGsKMNYSYHxHgPFdAcb3BBjfF2CsLcBYR4CxrgBjPQHGWAHG+gKMDQQYGwowNhJg/ECA8UMBxsYCjE0EGJsKMH4kwPixAGMzAcbmAowtBBhbCjC2EmBsLcD4iQDjpwKMbQQY2wowthNg/EyAsb0AYwcBxo4CjJ0EGDsLMHYRYOwqwNhNgLG7AGMPAcaeAoy9BBh7CzD2EWDsK8DYT4CxvwDjAAHGgQKMgwQYBwswDhFgHCrAOEyAcbgA4+cCjCMEGEcKMI4SYBwtwDhGgHGsAOM4AcbxAowTBBgnCjBOEmCcLMA4RYBxqgDjNAHG6QKMMwQYvxBgnCnAOEuAcbYA4xwBxrkCjPMEGOcLMH4pwLhAgHGhAOMiAcbFAoxLBBiXCjAuE2BcLsC4QoBxpQDjKgHG1QKMawQY1wowrhNgXC/AuEGAcaMA4yYBxs0CjFsEGLcKMG4TYNwuwLhDgHGnAOMuAcbdAox7BBj3CjDuE2DcL8B4QIDxKwHGgwKMXwswfiPA+K0A4yEBxu8EGA8LMB4RYPxegPEHAcajAozHBBiPCzCeEGD8UYDxJwHGkwKMpwQYTwsw/izAeEaA8awA4zkBxl8EGH8VYDwvwHhBgPE3AcaLAoyXBBgvCzD+LsD4hwDjnwKMVwQYrwow/iXA+LcA4zUBxusCjDcEGP8RYPxXgPGmAOMtAcZkye1nvEeAMbkAYwoBxpQCjPcKMKYSYEwtwJhGgDGtAGM6Acb7BBjvF2BML8D4gADjgwKMGQQYHxJgzCjAmEmAMbMAYxYBxqwCjNkEGLMLMOYQYHxYgDGnAGMuAcbcAoyPCDDmEWDMK8D4qADjYwKM+QQYHxdgzC/AWECA8QkBxicFGAsKMBYSYCwswPiUAOPTAozPCDAWEWAME2B0BBjDBRgjBBgjBRijBBiLCjBGCzDGCDAWE2B8VoCxuABjCQHGkgKMzwkwPi/A+IIAYykBxtICjGUEGF8UYCwrwPiSAOPLAoyvCDCWE2AsL8BYQYDxVQHGigKMrwkwVhJgfF2AsbIA4xsCjG8KML4lwFhFgLGqAGM1Aca3BRirCzDWEGCsKcBYS4DxHQHGdwUY3xNgfF+AsbYAYx0BxroCjPUEGGMFGOsLMDYQYGwowNhIgPEDAcYPBRgbCzA2EWBsKsD4kQDjxwKMzQQYmwswthBgbCnA2EqAsbUA4ycCjJ8KMLYRYGwrwNhOgPEzAcb2AowdBBg7CjB2EmDsLMDYRYCxqwBjNwHG7gKMPQQYewow9hJg7C3A2EeAsa8AYz8Bxv4CjAMEGAcKMA4SYBwswDhEgHGoAOMwAcbhAoyfCzCOEGAcKcA4SoBxtADjGAHGsQKM4wQYxwswThBgnCjAOEmAcbIA4xQBxqkCjNMEGKcLMM4QYPxCgHGmAOMsAcbZAoxzBBjnCjDOE2CcL8D4pQDjAgHGhQKMiwQYFwswLhFgXCrAuEyAcbkA4woBxpUCjKsEGFcLMK4RYFwrwLhOgHG9AOMGAcaNAoybBBg3CzBuEWDcKsC4TYBxuwDjDgHGnQKMuwQYdwsw7hFg3CvAuE+AcT+BkcGZPTWHMxmS0wkz/3M+//f5M9x+fThzsmRH3N/v3d8f3N+j7u8x9/e4+3vC/f3R/f3J/T3p/p5yf0+7vz+7v2fc37OZ49Y4l/n2oilu/9csmvd//nYknr99H8/ffojnb0fj+duxeP52PJ6/nYjnbz/G87ef4vnbyXj+diqev52O528/x/O3M/H87Ww8fzt3+29esEKTICKsaGRkbHR4rBPh1A4LL1YnJiosMqpO0RgnxomKiaoXHhMRERsTGRNdrE6x6LBiTmRErFM/qlhEbH3zE+ZkcRfMkTZZsuTg5DLrJpSx/u3lfsmMK6jQ6/pLyHVNDrquHnNW9w1ypsWtZ9YyvCmQcXIjlfUe3FqhcUro5/2VFPNfibXkxRwaIycul1BrIWN0nhSj88S6zOa+QW5gXZq1zhPqMhuwLs8DY36BFPMLITH3flKAY58D3I9Ra/2Gu6YRodcPXTvIurmI+8xOsmR4iTcxMYyoGeF97kuk+rmUiOvnMu6ahseXSwn1Am/moL0gG9ALkDPid1KO/070guzuG+QB5qRZ63eCF2QHesHvwJj/QYr5H/8PXw9L2I9javIyocd3rY7dAFKZbd3An9v7Qc+xP4HuAYy1A7x+Tuj1Q/dKZJ+8YrkHmly5QqiVq6R+edUHD/wr+PUTFl/dhCXsxzH+/HNGrI+bvXU052GgF/ydmTMT0D0NeW9zjdzTUK6bWNz0ema7+4KpkWuZsfl3PfN/awX52aHz1Ymru+uE+XqDNF9vEO9Bc7hv8CiwD5m1bhDuQXMA6/wGMO//IcX8H+I9qOnDfxHyv5/l96Asr+4vcg/6L9ARgLF2+ovcgyL75E3L70FNrtwk1MotUr+85cM9aLIsga+fePtuQr+L8BwD/V0EzAmcO90toXlyTxZOjpt1895eF93bHnbfIB+wv5m1DC/aAx8GemBonBL6eZOTYp48C88DTU2anobu8YMt90DWbBsi4oEpgHMMGGtniIgHIvtkyizYz4yuFZMrKQk94l5Sv7w3C98DUwW/fige6DkG2gMfBnog0glSk3I8NdEDc7pvkB/Y38xaqQkemBPogamBMU9DinkaogeamkxF6PGfW+6BrNk2QsQD0wLnGDDWzggRD0T2yXSWe6DJlXSEWrmP1C/v88ED7w9+/VA80HMMtAfmBHog0gnSk3I8PdEDc7lv8ASwv5m10hM8MBfQA9MDY/4AKeYPED3Q1OT9hB4/xnIPZM22sSIe+CBwjgFj7YwV8UBkn8xguQeaXMlAqJWHSP3yIR88MGPw64f2bPI9mXBxMOsdITybfAT43XCmLPbHJDk4Jt8TYvI9MCaZBWKSAhyTHwgx+QEYkywCMUkJjslRQkyOAmOSVSAm94JjcowQk2PAmGQTiEkqcEyOE2JyHBiT7AIxSQ2OyQlCTE4AY5JDICZpwDH5kRCTH4ExeVggJmnBMfmJEJOfgDHJKRCTdOCYnCTE5CQwJrkEYnIfOCanCDE5BYxJboGY3A+OyWlCTE4DY/KIQEzSg2PyMyEmPwNjkkcgJg+AY3KGEJMzwJjkFYjJg+CYnCXE5CwwJo8CY2K+33Av3//9A9vmrL/Zdzb7nGZfzezjmH0Dc59q7ouMhxvvM55h5prpo6ZuTZ4YLu8H/V3Stdv/BgH6u6THgNcy+e1r+b8/qPVZ1/axLPYz5kMzohPJewgmsTy08rjlg8E0i3zAz2vWezwLp6gZ/2jJ44Qv3vOTvnjPT3w4Lbf7BgWBD12YtfITHk7LDazz/MC8L0CKeQHiw2mmD2ck5P96yx9OYz1ws0Hk4bQngA/XAGPtbBB5OA3ZJ5+0/OE0kytPEmqlIKlfFvTh4bRCwa8fyiEFzzHQhxRgTuDc6W4JzZPCpBwvTPTAR9w3KAzsb2atwgQPfATogYWBMX+KFPOniB5oarIQocdvsdwDWbNtq4gHPg2cY8BYO1tFPBDZJ5+x3ANNrjxDqJUipH5ZxAcPDAt+/VA80HMMtAc+AvRApBM4pBx3iB6Yx32Dp4H9zazlEDwwD9ADHWDMw0kxDyd6oKnJMEKP32m5B7Jm2y4RD4wAzjFgrJ1dIh6I7JORlnugyZVIQq1EkfpllA8eWDT49UPxQM8x0B6YB+iBSCeIJuV4NNED87pvUATY38xa0QQPzAv0wGhgzGNIMY8heqCpyaKEHr/Pcg9kzbb9Ih5YDDjHgLF29ot4ILJPPmu5B5pceZZQK8VJ/bK4Dx5YIvj1Q+m73kPLyQnromJ7wPJraJ5ljO8aJvRzlwTmtO3X0Fy/koSe9lzSw/MO8hqwGJ+3/eF572Yssdw8vSDw8Pzz4IfnX1B4eJ44cErZOXAoEm2uXynCwClNkujSxE0HVj6VSSwCc/tAywuEfHqRlE8vEjcuH3XfwAHekJu1XiRsXD4KnL0vAmdRWVLMyxJ7iHGjEoT8P2T5jQtrM+Y7kY3Ll4A9Hhhr5zuRjUtkn3zZ8o1LkysvE2rlFVK/fMWHjctywa8fyhfYnmOgv8CGOYFzp7slNE/Kk3K8PNEDH3PfIALY38xa5Qke+BjQA8sDY16BFPMKRA80NVmO0ON/sNwDWbPtqIgHvgqcY8BYO0dFPBDZJyta7oEmVyoSauU1Ur98zQcPrBT8+qF4oOcYaA98DOiBSCd4nZTjrxM9MJ/7BlHA/mbWep3ggfmAHvg6MOaVSTGvTPRAU5OVCD3+R8s9kDXbfhLxwDeAcwwYa+cnEQ9E9sk3LfdAkytvEmrlLVK/fMsHD6wS/PqheKDnGGgPzAf0QKQTVCXleFWiBz7uvkE0sL+ZtaoSPPBxoAdWBca8Ginm1YgeaGqyCqHH/2y5B7Jm2xkRD3wbOMeAsXbOiHggsk9Wt9wDTa5UJ9RKDVK/rOGDB9YMfv3Qno0tQ8ilswIHKBjPs54TmTe1gPUCjLVzTiBvahHy5p2kgzcO8hqwGN+1/eCNd9OYWG7y3hM4ePMu+ODNe6SDN94Peti8H/xhQzt08z5h2NQmiX5tH0S/TpK43AVd3IGb9wi5VJeUS3WJG6v53TcoBtwwMGvVJWys5gfO3LrAGVSPFPN6xI1V40Q1Cfl/0fIbFtZm0SWRG91Y4LwAxtq5JLKxiuyT9S3fWDW5Up9QKw1I/bKBD77VMPj1Q/mC3XMM9BfsMCdw7nS3hOZJI1KONyJ6YAH3DYoD+5tZqxHBAwsAPbARMOYfkGL+AdEDTU02JPT4Py33QNZsuyLigR8C5xgw1s4VEQ9E9snGlnugyZXGhFppQuqXTXzwwKbBrx+KB3qOgfbAAkAPRDrBR6Qc/4jogU+4b1AS2N/MWh8RPPAJoAd+BIz5x6SYf0z0QFOTTQk9/prlHsiabddFPLAZcI4BY+1cF/FAZJ9sbrkHmlxpTqiVFqR+2cIHD2wZ/PqheKDnGGgPfALogUgnaEXK8VZED3zSfYPngf3NrNWK4IFPAj2wFTDmrUkxb030QFOTLQk9/qblHsiabbdEPPAT4BwDxtq5JeKByD75qeUeaHLlU0KttCH1yzY+eGDb4NcP7cBNHUIuJath9+dmPct6Tw2NedMO2eNwn9m5RyBv2hHy5rOkAzcO8hqwGNvbfuDGu2lMLDd5HQQO3LQHH7jpIHbgpmPwhw3twE1HwrDpRBL9Tj6IfuckcbkLurgDNx0IudSFlEtdiBurBd03KAXcMDBrdSFsrBYEztwuwBnUlRTzrsSNVeNEbQn5n9ryGxbWZlEakRvdbsB5AYy1kwbsHt4Pulci+2R3yzdWTa50J9RKD1K/7OGDb/UMfv1QvmD3HAP9BTvMCZw73S2hedKLlOO9iB5YyH2DMsD+ZtbqRfDAQkAP7AWMeW9SzHsTPdDUZE9Cj7/fcg9kzbb0Ih7YBzjHgLF20ot4ILJP9rXcA02u9CXUSj9Sv+zngwf2D379UDzQcwy0BxYCeiDSCQaQcnwA0QMLu29QFtjfzFoDCB5YGOiBA4AxH0iK+UCiB5qa7E/o8Q9Z7oGs2ZZRxAMHAecYMNZORhEPRPbJwZZ7oMmVwYRaGULql0N88MChwa8figd6joH2wMJAD0Q6wTBSjg8jeuBT7hu8DOxvZq1hBA98CuiBw4AxH06K+XCiB5qaHEro8Vkt90DWbMsm4oGfA+cYMNZONhEPRPbJEZZ7oMmVEYRaGUnqlyN98MBRwa8f2oGbzoRcyi5wcILxLGsOkXkzGlgvwFg7OQTyZjQhb8YkHbhxkNeAxTjW9gM33k1jYrnJGydw4GYs+MDNOLEDN+ODP2xoB27GE4bNBJLoT/BB9Ccmictd0MUduBlHyKVJpFyaRNxYfdp9g3LADQOz1iTCxurTwJk7CTiDJpNiPpm4sWqcaBQh//NYfsPC2izKK3KjOwU4L4CxdvKKbKwi++RUyzdWTa5MJdTKNFK/nOaDb00Pfv1QvmD3HAP9BTvMCZw73S2heTKDlOMziB74jPsGFYD9zaw1g+CBzwA9cAYw5l+QYv4F0QNNTU4n9PjHLfdA1mzLL+KBM4FzDBhrJ7+IByL75CzLPdDkyixCrcwm9cvZPnjgnODXD8UDPcdAe+AzQA9EOsFcUo7PJXpgEfcNKgL7m1lrLsEDiwA9cC4w5vNIMZ9H9EBTk3MIPb6g5R7Imm2FRDxwPnCOAWPtFBLxQGSf/NJyDzS58iWhVhaQ+uUCHzxwYfDrh+KBnmOgPbAI0AORTrCIlOOLiB5o3qgSsL+ZtRYRPDAM6IGLgDFfTIr5YqIHmppcSOjxz1jugazZVkTEA5cA5xgw1k4REQ9E9smllnugyZWlhFpZRuqXy3zwwOXBrx/agZuJhFwKEzg4wXiW1RGZNyuA9QKMteMI5M0KQt6sTDpw4yCvAYtxle0HbrybxsRyk7da4MDNKvCBm9ViB27WBH/Y0A7crCEMm7Uk0V/rg+ivSxKXu6CLO3CzmpBL60m5tJ64seq4b1AZuGFg1lpP2Fh1gDN3PXAGbSDFfANxY9U40XJC/kdbfsPC2iyKEbnR3QicF8BYOzEiG6vIPrnJ8o1VkyubCLWymdQvN/vgW1uCXz+UL9g9x0B/wQ5zAudOd0tonmwl5fhWogeGu2/wJrC/mbW2EjwwHOiBW4Ex30aK+TaiB5qa3ELo8SUs90DWbCsp4oHbgXMMGGunpIgHIvvkDss90OTKDkKt7CT1y50+eOCu4NcPxQM9x0B7YDjQA5FOsJuU47uJHhjhvkEVYH8za+0meGAE0AN3A2O+hxTzPUQPNDW5i9DjS1nugazZVlrEA/cC5xgw1k5pEQ9E9sl9lnugyZV9hFrZT+qX+33wwAPBrx+KB3qOgfbACKAHIp3gK1KOf0X0wEj3DaoB+5tZ6yuCB0YCPfArYMwPkmJ+kOiBpiYPEHr8S5Z7IGu2vSzigV8D5xgw1s7LIh6I7JPfWO6BJle+IdTKt6R++a0PHngo+PVDO3CzjpBLrwgcnGA8y1pOZN58B6wXYKydcgJ58x0hbw4nHbhxkNeAxXjE9gM33k1jYrnJ+17gwM0R8IGb78UO3PwQ/GFDO3DzA2HYHCWJ/lEfRP9YkrjcBV3cgZvvCbl0nJRLx4kbq1HuG1QHbhiYtY4TNlajgDP3OHAGnSDF/ARxY9U40SFC/ley/IaFtVn0usiN7o/AeQGMtfO6yMYqsk/+ZPnGqsmVnwi1cpLUL0/64Fungl8/lC/YPcdAf8EOcwLnTndLaJ6cJuX4aaIHFnXfoCawv5m1ThM8sCjQA08DY/4zKeY/Ez3Q1OQpQo9/y3IPZM22KiIeeAY4x4CxdqqIeCCyT5613ANNrpwl1Mo5Ur8854MH/hL8+qF4oOcYaA8sCvRApBP8SsrxX4keGO2+wTvA/mbW+pXggdFAD/wVGPPzpJifJ3qgqclfCD2+uuUeyJptNUQ88AJwjgFj7dQQ8UBkn/zNcg80ufIboVYukvrlRR888FLw64figZ5joD0wGuiBSCe4TMrxy0QPjHHf4D1gfzNrXSZ4YAzQAy8DY/47Kea/Ez3Q1OQlQo9/13IPZM2290Q88A/gHAPG2nlPxAORffJPyz3Q5MqfhFq5QuqXV3zwwKvBrx/agZtjhFx6X+DgBONZ1toi8+YvYL0AY+3UFsibvwh583fSgRsHeQ1YjNdsP3Dj3TQmlpu86wIHbq6BD9xcFztwcyP4w4Z24OYGYdj8QxL9f3wQ/X+TxOUu6OIO3Fwn5NJNUi7dJG6sFnPfoDZww8CsdZOwsVoMOHNvAmfQLVLMbxE3Vo0TXSXkfwPLb1hYm0UNRW50k2XFXUtgrJ2GIhuryD55T1bsZ0bXiskVw4iuleRZOf3SrJs32Z0/6PpJEfz6oXzB7jkG+gt2mBM4d7pbQvMkJSnHU2bleeCz7hvUBfY3s5bhRXvgs0APDI1TQj/vvaSY35uV54H/qUlCj29suQeyZlsTEQ9MBZxjwFg7TUQ8ENknU1vugSZXUhNqJQ2pX6bxwQPTBr9+KB7oOQbaA58FeiDSCdKRcjwd0QOLu28QC+xvZq10BA8sDvTAdMCY30eK+X1EDzQ1mZbQ45tZ7oGs2dZcxAPvB84xYKyd5iIeiOyT6S33QJMr6Qm18gCpXz7ggwc+GPz6oXig5xhoDywO9ECkE2Qg5XgGogeWcN+gAbC/mbUyEDywBNADMwBj/hAp5g8RPdDU5IOEHt/acg9kzbZPRDwwI3COAWPtfCLigcg+mclyDzS5kolQK5lJ/TKzDx6YJfj1Qztw8y/heZxPBQ5OMJ5lbSMyb7IC6wUYa6eNQN5kJfTebMDea2ar4oEb5DVgMWZHM6ITybtpTCw3eTnAAUkOvm6mYWQHfl6znvnMrKI2P+hh83Dwhw3twM3DhGGTkyT6OX0Q/VxJ4nIXdHEHbnIQcik3KZdyEzdWS7pv0Ai4YWDWyk3YWC0JnLm5gTPoEVLMHyFurBonykLI/46W37CwNos6idzo5gHOC2CsnU4iG6vIPpnX8o1Vkyt5CbXyKKlfPuqDbz0W/PqhfMHuOQb6C3aYEzh3ultC8yQfKcfzET3wOfcNPgT2N7NWPoIHPgf0wHzAmD9OivnjRA80NfkYocd3s9wDWbOtu4gH5gfOMWCsne4iHojskwUs90CTKwUItfIEqV8+4YMHPhn8+qF4oOcYaA98DuiBSCcoSMrxgkQPfN59gybA/mbWKkjwwOeBHlgQGPNCpJgXInqgqcknCT2+t+UeyJptfUQ8sDBwjgFj7fQR8UBkn3zKcg80ufIUoVaeJvXLp33wwGeCXz8UD/QcA+2BzwM9EOkERUg5XoTogS+4b/ARsL+ZtYoQPPAFoAcWAcY8jBTzMKIHmpp8htDjB1jugazZNlDEAx3gHAPG2hko4oHIPhluuQeaXAkn1EoEqV9G+OCBkcGvH9qBm1yEXBokcHCC8SzrYJF5EwWsF2CsncECeRNFyJuiSQduHOQ1YDFG237gxrtpTCw3eTECB26iwQduYsQO3BQL/rChHbgpRhg2z5JE/1kfRL94krjcBV3cgZsYQi6VIOVSCeLGain3DZoBNwzMWiUIG6ulgDO3BHAGlSTFvCRxY9U4USQh/0dYfsPC2iwaKXKj+xxwXgBj7YwU2VhF9snnLd9YNbnyPKFWXiD1yxd88K1Swa8fyhfsnmOgv2CHOYFzp7slNE9Kk3K8NNEDS7tv0ALY38xapQkeWBrogaWBMS9DinkZogeamixF6PFjLfdA1mwbJ+KBLwLnGDDWzjgRD0T2ybKWe6DJlbKEWnmJ1C9f8sEDXw5+/VA80HMMtAeWBnog0gleIeX4K0QPLOO+QStgfzNrvULwwDJAD3wFGPNypJiXI3qgqcmXCT1+kuUeyJptk0U8sDxwjgFj7UwW8UBkn6xguQeaXKlAqJVXSf3yVR88sGLw64figZ5joD2wDNADkU7wGinHXyN64IvuG3wC7G9mrdcIHvgi0ANfA8a8EinmlYgeaGqyIqHHT7fcA1mzbYaIB74OnGPAWDszRDwQ2ScrW+6BJlcqE2rlDVK/fMMHD3wz+PVDO3BTnJBLXwgcnGA8yzpTZN68BawXYKydmQJ58xYhb6okHbhxkNeAxVjV9gM33k1jYrnJqyZw4KYq+MBNNbEDN28Hf9jQDty8TRg21UmiX90H0a+RJC53QRd34KYaIZdqknKpJnFjtaz7Bm2AGwZmrZqEjdWywJlbEziDapFiXou4sWqc6E1C/s+3/IaFtVn0pciN7jvAeQGMtfOlyMYqsk++a/nGqsmVdwm18h6pX77ng2+9H/z6oXzB7jkG+gt2mBM4d7pbQvOkNinHaxM98CX3DdoB+5tZqzbBA18CemBtYMzrkGJeh+iBpibfJ/T4xZZ7IGu2LRHxwLrAOQaMtbNExAORfbKe5R5ocqUeoVZiSf0y1gcPrB/8+qF4oOcYaA98CeiBSCdoQMrxBkQPfNl9g/bA/mbWakDwwJeBHtgAGPOGpJg3JHqgqcn6hB6/wnIPZM22lSIe2Ag4x4CxdlaKeCCyT35guQeaXPmAUCsfkvrlhz54YOPg1w/FAz3HQHvgy0APRDpBE1KONyF64CvuG3QE9jezVhOCB74C9MAmwJg3JcW8KdEDTU02JvT4tZZ7IGu2rRPxwI+AcwwYa2ediAci++THlnugyZWPCbXSjNQvm/nggc2DXz+0Azc1CLm0XuDgBONZ1g0i86YFsF6AsXY2CORNC0LetEw6cOMgrwGLsZXtB268m8bEcpPXWuDATSvwgZvWYgduPgn+sKEduPmEMGw+JYn+pz6IfpskcbkLurgDN60JudSWlEttiRur5dw36AzcMDBrtSVsrJYDzty2wBnUjhTzdsSNVeNEzQn5v83yGxbWZtF2kRvdz4DzAhhrZ7vIxiqyT7a3fGPV5Ep7Qq10IPXLDj74Vsfg1w/lC3bPMdBfsMOcwLnT3RKaJ51IOd6J6IHl3TfoCuxvZq1OBA8sD/TATsCYdybFvDPRA01NdiT0+N2WeyBrtu0R8cAuwDkGjLWzR8QDoX3Scg80udKVUCvdSP2ymw8e2D349UPxQM8x0B5YHuiBSCfoQcrxHkQPrOC+QXdgfzNr9SB4YAWgB/YAxrwnKeY9iR5oarI7occfsNwDWbPtKxEP7AWcY8BYO1+JeCCyT/a23ANNrvQm1EofUr/s44MH9g1+/VA80HMMtAdWAHog0gn6kXK8H9EDX3XfoCewv5m1+hE88FWgB/YDxrw/Keb9iR5oarIvocd/a7kHsmbbIREPHACcY8BYO4dEPBDZJwda7oEmVwYSamUQqV8O8sEDBwe/fmgHbtoQcuk7gYMTjGdZD4vMmyHAegHG2jkskDdDCHkzNOnAjYO8BizGYbYfuPFuGhPLTd5wgQM3w8AHboaLHbj5PPjDhnbg5nPCsBlBEv0RPoj+yCRxuQu6uAM3wwm5NIqUS6OIG6sV3TfojfziKG0cL3rmVgTO3FHAGTSaFPPRxI1V40SDCfl/3PIbFtZm0QmRG90xwHkBjLVzQmRjFdknx1q+sWpyZSyhVsaR+uU4H3xrfPDrh/IFu+cY6C/YYU7g3OluCc2TCaQcn0D0wNfcN+gL7G9mrQkED3wN6IETgDGfSIr5RKIHmpocT+jxpyz3QNZsOy3igZOAcwwYa+e0iAci++Rkyz3Q5MpkQq1MIfXLKT544NTg1w/FAz3HQHvga0APRDrBNFKOTyN6YCX3DfoD+5tZaxrBAysBPXAaMObTSTGfTvRAU5NTCT3+nOUeyJptv4h44AzgHAPG2vlFxAORffILyz3Q5MoXhFqZSeqXM33wwFnBrx+KB3qOgfbASkAPRDrBbFKOzyZ64OvuGwxEPkieNo4X7YGvAz1wNjDmc0gxn0P0QFOTswg9/jfLPZA12y6KeOBc4BwDxtq5KOKByD45z3IPNLkyj1Ar80n9cr4PHvhl8OuHduBmJCGXLgkcnGA8y3pZZN4sANYLMNbOZYG8WUDIm4VJB24c5DVgMS6y/cCNd9OYWG7yFgscuFkEPnCzWOzAzZLgDxvagZslhGGzlCT6S30Q/WVJ4nIXdHEHbhYTcmk5KZeWEzdWK7tvMBi4YWDWWk7YWK0MnLnLgTNoBSnmK4gbq8aJviTk/1+W37CwNov+FrnRXQmcF8BYO3+LbKwi++QqyzdWTa6sItTKalK/XO2Db60Jfv1QvmD3HAP9BTvMCZw73S2hebKWlONriR74hvsGQ4H9zay1luCBbwA9cC0w5utIMV9H9EBTk2sIPf4fyz2QNdv+FfHA9cA5Boy186+IByL75AbLPdDkygZCrWwk9cuNPnjgpuDXD8UDPcdAe+AbQA9EOsFmUo5vJnrgm+4bDAf2N7PWZoIHvgn0wM3AmG8hxXwL0QNNTW4i9Ph7atrtgazZlhz8ub0f9BzbCpxjwFg7wOtH9UBkn9xmuQeaXNlGqJXtpH653QcP3BH8+qF4oOcYaA98E+iBSCfYScrxnUQPfMt9gxHA/mbW2knwwLeAHrgTGPNdpJjvInqgqckdhB6fynIPZM221CIeuBs4x4CxdlKLeCCyT+6x3ANNruwh1MpeUr/c64MH7gt+/VCeBzbP4SGfYWQ9I7o/q93zy3zu/YTPfSDpIIZzIKv9jF/ZfhDDu5lILPJ/UOAgxlfggxgHSQcx0J/d5CFyYLOE6GtC4zE/aPn5BngtG1bHrdWout1D28jPN4S8ecDym23TK74mfO4HRW62vwXWCzDWTuj1S9gGb10npbtGqpDcCf1B59O34BtH7+dQViLwoaz4db8DDnTW5/5ORBK2uU3qu8y49fa5ax3KTPjfNLVcNLeDr+N+0nU8Yvl13AG+jgdI1/F7y6/jTvB1/Ip0HX+w/DruAl/Hg6TreNTy67gbfB2/Jl3HY5Zfxz3g6/gN6Toet/w67gVfx29J1/EEWPrNzrT579+Z474t+s/fsvz3deaQ11lCXmcNeZ0t5HX2kNc5Ql4/HPI6Z8jrXCGvc4e8fiTkdZ6Q13lDXj8a8vpw1v++PhLy+vuQ1z+EvD4a8vpYyOvjIa9P3H79o/vfn9zfk+7vKff3tPv7s/t7xv09e9vrGZsF3xE2C86Rv9FBbKgyPvcvwM2HlLc/t7dBYl6v9hpSMk4+ZEmGjRuDMasAYzYBxuwCjDkEGB8WYMwpwJhLgDG3AOMjAox5BBjzCjA+KsD4mABjPgHGxwUY8wswFhBgfEKA8UkBxoICjIUEGAsLMD4lwPi0AOMzAoxFBBjDBBgdAcZwAcYIAcZIAcYoAcaiAozRAowxAozFBBifFWAsLsBYQoCxpADjcwKMzwswviDAWEqAsbQAYxkBxhcFGMsKML4kwPiyAOMrAozlBBjLCzBWEGB8VYCxogDjawKMlQQYXxdgrCzA+IYA45sCjG8JMFYRYKwqwFhNgPFtAcbqAow1BBhrCjDWEmB8R4DxXQHG9wQY3xdgrC3AWEeAsa4AYz0BxlgBxvoCjA0EGBsKMDYSYPxAgPFDAcbGAoxNBBibCjB+JMD4sQBjMwHG5gKMLQQYWwowthJgbC3A+IkA46cCjG0EGNsKMLYTYPxMgLG9AGMHAcaOAoydBBg7CzB2EWDsKsDYTYCxuwBjDwHGngKMvQQYewsw9hFg7CvA2E+Asb8A4wABxoECjIMEGAcLMA4RYBwqwDhMgHG4AOPnAowjBBhHCjCOEmAcLcA4RoBxrADjOAHG8QKMEwQYJwowThJgnCzAOEWAcaoA4zQBxukCjDMEGL8QYJwpwDhLgHG2AOMcAca5AozzBBjnCzB+KcC4QIBxoQDjIgHGxQKMSwQYlwowLhNgXC7AuEKAcaUA4yoBxtUCjGsEGNcKMK4TYFwvwLhBgHGjAOMmAcbNAoxbBBi3CjBuE2DcLsC4Q4BxpwDjLgHG3QKMewQY9wow7hNg3C/AeECA8SsBxoMCjF8LMH4jwPitAOMhAcbvBBgPCzAeEWD8XoDxBwHGowKMxwQYjwswnhBg/FGA8ScBxpMCjKcEGE8LMP4swHhGgPGsAOM5AcZfBBh/FWA8L8B4QYDxNwHGiwKMlwQYLwsw/i7A+IcA458CjFeS2c94VYDxLwHGvwUYrwkwXhdgvCHA+I8A478CjDcFGG8JMJoFbWe8R4AxuQBjCgHGlAKM9wowphJgTC3AmEaAMa0AYzoBxvsEGO8XYEwvwPiAAOODAowZBBgfEmDMKMCYSYAxswBjFgHGrAKM2QQYswsw5hBgfFiAMacAYy4BxtwCjI8IMOYRYMwrwPioAONjAoz5BBgfF2DML8BYQIDxCQHGJwUYCwowFhJgLCzA+JQA49MCjM8IMBYRYAwTYHQEGMMFGCMEGCMFGKMEGIsKMEYLMMYIMBYTYHxWgLG4AGMJAcaSAozPCTA+L8D4ggBjKQHG0gKMZQQYXxRgLCvA+JIA48sCjK8IMJYTYCwvwFhBgPFVAcaKAoyvCTBWEmB8XYCxsgDjGwKMbwowviXAWEWAsaoAYzUBxrcFGKsLMNYQYKwpwFhLgPEdAcZ3BRjfE2B8X4CxtgBjHQHGugKM9QQYYwUY6wswNhBgbCjA2EiA8QMBxg8FGBsLMDYRYGwqwPiRAOPHAozNBBibCzC2EGBsKcDYSoCxtQDjJwKMnwowthFgbCvA2E6A8TMBxvYCjB0EGDsKMHYSYOwswNhFgLGrAGM3AcbuAow9BBh7CjD2EmDsLcDYR4CxrwBjPwHG/gKMAwQYBwowDhJgHCzAOESAcagA4zABxuECjJ8LMI4QYBwpwDhKgHG0AOMYAcaxAozjBBjHCzBOEGCcKMA4SYBxsgDjFAHGqQKM0wQYpwswzhBg/EKAcaYA4ywBxtkCjHMEGOcKMM4TYJwvwPilAOMCAcaFAoyLBBgXCzAuEWBcKsC4TIBxuQDjCgHGlQKMqwQYVwswrhFgXCvAuE6Acb0A4wYBxo0CjJsEGDcLMG4RYNwqwLhNgHG7AOMOAcadAoy7BBh3CzDuEWDcK8C4T4BxvwDjAQHGrwQYDwowfi3A+I0A47cCjIcEGL8TYDwswHhEgPF7AcYfBBiPCjAeE2A8LsB4QoDxRwHGnwQYTwownhJgPC3A+LMA4xkBxrMCjOcEGH8RYPxVgPG8AOMFAcbfBBgvCjBeEmC8LMD4uwDjHwKMfwowXhFgvCrA+JcA498CjNcEGK8LMN4QYPxHgPFfAcabAoy3BBiTJbef8R4BxuQCjCkEGFMKMN4rwJhKgDG1AGMaAca0AozpBBjvE2C8X4AxvQDjAwKMDwowZhBgfEiAMaMAYyYBxswCjFkEGLMKMGYTYMwuwJhDgPFhAcacAoy5BBhzCzA+IsCYR4AxrwDjowKMjwkw5hNgfFyAMb8AYwEBxicEGJ8UYCwowFhIgLGwAONTAoxPCzA+I8BYRIAxTIDREWAMF2CMEGCMFGCMEmAsKsAYLcAYI8BYTIDxWQHG4gKMJQQYSwowPifA+LwA4wsCjKUEGEsLMJYRYHxRgLGsAONLAowvCzC+IsBYToCxvABjBQHGVwUYKwowvibAWEmA8XUBxsoCjG8IML4pwPiWAGMVAcaqAozVBBjfFmCsLsBYQ4CxpgBjLQHGdwQY3xVgfE+A8X0BxtoCjHUEGOsKMNYTYIwVYKwvwNhAgLGhAGMjAcYPBBg/FGBsLMDYRICxqQDjRwKMHwswNhNgbC7A2EKAsaUAYysBxtYCjJ8IMH4qwNhGgLGtAGM7AcbPBBjbCzB2EGDsKMDYSYCxswBjFwHGrgKM3QQYuwsw9hBg7CnA2EuAsbcAYx8Bxr4CjP0EGPsLMA4QYBwowDhIgHGwAOMQAcahAozDBBiHCzB+LsA4QoBxpADjKAHG0QKMYwQYxwowjhNgHC/AOEGAcaIA4yQBxskCjFMEGKcKME4TYJwuwDhDgPELAcaZAoyzBBhnCzDOEWCcK8A4T4BxvgDjlwKMCwQYFwowLhJgXCzAuESAcakA4zIBxuUCjCsEGFcKMK4SYFwtwLhGgHGtAOM6Acb1AowbBBg3CjBuEmDcLMC4RYBxqwDjNgHG7QKMOwQYdwow7hJg3C3AuEeAca8A4z4Bxv0ERgZn9tQczmRITifS/M/5/N/nz3D79a9ZkyU77/5ecH9/c38vur+X3N/L7u/v7u8f7u+f7u8V9/eq+/uX+/u3+3vN/b2eNW6NG1lvL5ri9n/Nonn/52/n4/nbhXj+9ls8f7sYz98uxfO3y/H87fd4/vZHPH/7M56/XYnnb1fj+dtf8fzt73j+di2ev12P5283bv/NC1ZoEkSEFY2MjI0Oj3UinNph4cXqxESFRUbVKRrjxDhRMVH1wmMiImJjImOii9UpFh1WzImMiHXqRxWLiK1vfsKcKu6Co9ImS5YcmlxhYWbdhDLWv73cP1lxBRV6Xf8Jua7JQdfVY67qvsGYtLj1zFqGNwUyTuYf37wHt1ZonBL6ef8lxfxfYi15MYfGyInLJdRayBjdJMXoJrEuq7lvMA5Yl2atm4S6rAasy5vAmN8ixfxWSMy9nxTg2I8C92PUWsmywa5pROj1Q9cOsm7uwX1mJ1kyvMSbmBhG1IzwPnfybJz6MevmTZY46ycF7pqGx5dLCfUCb+agvaAa0AuQMyIlKcdTZuN5wdvuG0wA5qRZy/CiveBtoBeEximhn/deUszvzfb/7+thCftx/lOThB5fsCZ2A0hlthUCf27vBz3HUgHdAxhrB3j9nNDrh+6VyD6Z2nIPNLmSmlAraUj9Mo0PHpg2+PUTFl/dhCXsxzH+/HdmrI+bvXU0569AF0yXjTMT0D0NeW9zH7mnoVw3sbjp/dns7gumRu7Lhs0/85mTYTnxLurE1d39hPmanjRf0xPvQau7bzAJ2IfMWukJ96DVgXWeHpj3D5Bi/gDxHtT04bSE/A+3/B6U5dURIvegDwIdARhrJ0LkHhTZJzNYfg9qciUDoVYeIvXLh3y4B80Y/PqJt+8m9LsIzzHQ30XAnMC5090SmieZSDmeieiBNdw3mALsb2atTAQPrAH0wEzAmGcmxTwz0QNNTWYk9Phoyz2QNdtiRDwwC3COAWPtxIh4ILJPZrXcA02uZCXUSjZSv8zmgwdmD379UDzQcwy0B9YAeiDSCXKQcjwH0QNrum8wDdjfzFo5CB5YE+iBOYAxf5gU84eJHmhqMjuhx5ew3ANZs62kiAfmBM4xYKydkiIeiOyTuSz3QJMruQi1kpvUL3P74IGPBL9+KB7oOQbaA2sCPRDpBHlIOZ6H6IG13DeYAexvZq08BA+sBfTAPMCY5yXFPC/RA01NPkLo8aUs90DWbCst4oGPAucYMNZOaREPRPbJxyz3QJMrjxFqJR+pX+bzwQMfD3790J5NzpQFFwez3nnCs8nngc8m57f8uVBzDTODY3KBEJMLwJgUEIhJFnBMfiPE5DdgTJ4QiElWcEwuEmJyERiTJwVikg0ck0uEmFwCxqSgQEyyg2NymRCTy8CYFBKISQ5wTH4nxOR3YEwKC8TkYXBM/iDE5A9gTJ4SiElOcEz+JMTkT2BMnhaISS5wTK4QYnIFGJNnBGKSGxyTq4SYXAXGpIhATB4Bx+QvQkz+AsYkTCAmecAx+ZsQk7+BMXEEYpIXHJNrhJhcA8YkXCAmj4Jjcp0Qk+vAmEQAY2K+3zD/Hrb3D2ybs/5m39nsc5p9NbOPY/YNzH2quS8yHm68z3iGmWumj5q6NXkSEXKmH/1d0n23/w0C9HdJkcBrmfz2tfzfH9T6rGsbmc1+xig0IzqRvIdgEstDK0UtHwymWUSB/9GSotk4Rc34R0uKMg7rkb54jyY+nPaO+wYzgQ9dmLWiCQ+nvQOs82hg3seQYh5DfDjN9OHHCflf3/KH01gP3DQQeTitGPDhGmCsnQYiD6ch++Szlj+cZnLlWUKtFCf1y+I+PJxWIvj1Qzmk4DkG+pACzAmcO90twYfWSDlekuiB77pvMBvY38xaJQke+C7QA0sCY/4cKebPET3Q1GQJQo//0HIPZM22xiIe+DxwjgFj7TQW8UBkn3zBcg/8T64wDjKR+mUpHzywdPDrh+KBnmOgPfBdoAcinaAMKcfLED3wPfcN5gL7m1mrDMED3wN6YBlgzF8kxfxFogeamixN6PEfW+6BrNnWTMQDywLnGDDWTjMRD0T2yZcs90CTKy8RauVlUr982QcPfCX49UPxQM8x0B74HtADkU5QjpTj5Yge+L77BvOB/c2sVY7gge8DPbAcMOblSTEvT/RAU5OvEHp8K8s9kDXbWot4YAXgHAPG2mkt4oHIPvmq5R5ocuVVQq1UJPXLij544GvBrx9K3/UeWk5OWBcV208sv4bmWcb4rmFCP3clYE7bfg3N9atE6GmvJz087yCvAYuxsu0Pz3s3Y4nl5ukNgYfnK4Mfnn9D4eF54sB5086BQ5Foc/3eJAyct0gS/RZx04GVT1USi8DcPtDyBiGfqpLyqSpx47K2+wYLgDfkZq2qhI3L2sDZWxU4i6qRYl6N2EOMG71GyP/2lt+4sDZjOohsXL4N7PHAWDsdRDYukX2yuuUblyZXqhNqpQapX9bwYeOyZvDrh/IFtucY6C+wYU7g3OluCT68T8rxWkQPrOO+wSJgfzNr1SJ4YB2gB9YCxvwdUszfIXqgqcmahB7fxXIPZM22riIe+C5wjgFj7XQV8UBkn3zPcg80ufIeoVbeJ/XL933wwNrBrx+KB3qOgfbAOkAPRDpBHVKO1yF6YF33DZYA+5tZqw7BA+sCPbAOMOZ1STGvS/RAU5O1CT2+p+UeyJptvUQ8sB5wjgFj7fQS8UBkn4y13ANNrsQSaqU+qV/W98EDGwS/fige6DkG2gPrAj0Q6QQNSTnekOiB9dw3WAbsb2athgQPrAf0wIbAmDcixbwR0QNNTTYg9Ph+lnsga7b1F/HAD4BzDBhrp7+IByL75IeWe6DJlQ8JtdKY1C8b++CBTYJfP7RnY6sQcmmAwAEKxvOsA0XmTVNgvQBj7QwUyJumhLz5KOngjYO8BizGj20/eOPdNCaWm7xmAgdvPgYfvGlGOnjj/aCHTfPgDxvaoZvmhGHTgiT6LXwQ/ZZJ4nIXdHEHbpox/qUUUi61Im6sxrpvsAK4YWDWakXYWI0FztxWwBnUmhTz1sSNVeNETQj5P9zyGxbWZtHnIje6nwDnBTDWzuciG6vIPvmp5RurJlc+JdRKG1K/bOODb7UNfv1QvmD3HAP9BTvMCZw73S2hedKOlOPtiB5Y332DVcD+ZtZqR/DA+kAPbAeM+WekmH9G9EBTk20JPX605R7Imm1jRDywPXCOAWPtjBHxQGSf7GC5B5pc6UColY6kftnRBw/sFPz6oXig5xhoD6wP9ECkE3Qm5Xhnogc2cN9gDbC/mbU6EzywAdADOwNj3oUU8y5EDzQ12YnQ4ydY7oGs2TZRxAO7AucYMNbORBEPRPbJbpZ7oMmVboRa6U7ql9198MAewa8figd6joH2wAZAD0Q6QU9SjvckemBD9w3WAfubWasnwQMbAj2wJzDmvUgx70X0QFOTPQg9fqrlHsiabdNEPLA3cI4BY+1ME/FAZJ/sY7kHmlzpQ6iVvqR+2dcHD+wX/PqhHbhpScil6QIHJxjPss4QmTf9gfUCjLUzQyBv+jMOqCUduHGQ14DFOND2AzfeTWNiuckbJHDgZiD4wM0gsQM3g4M/bGgHbgYThs0QkugP8UH0hyaJy13QxR24GUTIpWGkXBpG3Fht5L7BBuCGgVlrGGFjtRFw5g4DzqDhpJgPJ26sGifqR8j/uZbfsLA2i+aJ3Oh+DpwXwFg780Q2VpF9coTlG6smV0YQamUkqV+O9MG3RgW/fihfsHuOgf6CHeYEzp3uluADB6QcH030wA/cN9gE7G9mrdEED/wA6IGjgTEfQ4r5GKIHmpocRejxCy33QNZsWyTigWOBcwwYa2eRiAci++Q4yz3Q5Mo4Qq2MJ/XL8T544ITg1w/FAz3HQHvgB0APRDrBRFKOTyR64IfuG2wB9jez1kSCB34I9MCJwJhPIsV8EtEDTU1OIPT4ZZZ7IGu2LRfxwMnAOQaMtbNcxAORfXKK5R5ocmUK42FsUr+c6oMHTgt+/VA80HMMtAd+CPRApBNMJ+X4dKIHNnbfYBuwv5m1phM8sDHQA6cDYz6DFPMZRA80NTmN0ONXW+6BrNm2RsQDvwDOMWCsnTUiHojskzMt90CTKzMJtTKL1C9n+eCBs4NfP7QDN0MJubRW4OAE41nWdSLzZg6wXoCxdtYJ5M0cxnN7SQduHOQ1YDHOs/3AjXfTmFhu8uYLHLiZBz5wM1/swM2XwR82tAM3XxKGzQKS6C/wQfQXJonLXdDFHbiZz3jgipRLi4gbq03cN9gB3DAway0ibKw2Ac7cRcAZtJgU88XEjVXjRLMJ+b/F8hsW1mbRVpEb3SXAeQGMtbNVZGMV2SeXWr6xanJlKeMhHFK/XOaDby0Pfv1QvmD3HAP9BTvMCZw73S3B/0tYpBxfQfTApu4b7AL2N7PWCoIHNgV64ApgzFeSYr6S6IGmJpcTevxOyz2QNdt2iXjgKuAcA8ba2SXigcg+udpyDzS5sprxMAqpX67xwQPXBr9+KB7oOQbaA5sCPRDpBOtIOb6O6IEfuW+wB9jfzFrrCB74EdAD1wFjvp4U8/VEDzQ1uZbQ4/dZ7oGs2bZfxAM3AOcYMNbOfhEPRPbJjZZ7oMmVjYRa2UTql5t88MDNwa8figd6joH2wI+AHoh0gi2kHN9C9MCP3TfYB+xvZq0tBA/8GOiBW4Ax30qK+VaiB5qa3Ezo8V9b7oGs2faNiAduA84xYKydb0Q8ENknt1vugSZXthNqZQepX+7wwQN3Br9+aAduFhJy6VuBgxOMZ1kPicybXcB6AcbaOSSQN7sIebM76cCNg7wGLMY9th+48W4aE8tN3l6BAzd7wAdu9ooduNkX/GFDO3Czj/HlCEn09/sg+geSxOUu6OIO3Owl5NJXpFz6irix2sx9gwPADQOz1leEjdVmwJn7FXAGHSTF/CBxY9U40U5C/h+1/IaFtVl0TORG92vgvADG2jkmsrGK7JPfWL6xanLlG8ZmGKlffuuDbx0Kfv1QvmD3HAP9BTvMCZw73S2hefIdKce/I3pgc/cNDgL7m1nrO4IHNgd64HfAmB8mxfww0QNNTR4i9PifLPdA1mw7KeKBR4BzDBhr56SIByL75PeWe6DJle8JtfIDqV/+4IMHHg1+/VA80HMMtAc2B3og0gmOkXL8GNEDW7hv8A3yPjdtHC/aA1sAPfAYMObHSTE/TvRAU5NHCT3+jOUeyJptZ0U88ARwjgFj7ZwV8UBkn/zRcg80ufIj416R1C9/8sEDTwa/fige6DkG2gNbAD0Q6QSnSDl+iuiBLd03OATsb2atUwQPbAn0wFPAmJ8mxfw00QNNTZ4k9Pjzlnsga7ZdEPHAn4FzDBhr54KIByL75BnLPdDkyhnGPROpX571wQPPBb9+aAduDhBy6TeBgxOMZ1kvisybX4D1Aoy1c1Egb34h5M2vSQduHOQ1YDGet/3AjXfTmFhu8i4IHLg5Dz5wc0HswM1vwR82tAM3vzEkhST6F30Q/UtJ4nIXdHEHbi4QcukyKZcuEzdWW7lvcBi4YWDWukzYWG0FnLmXgTPod1LMfydurBonOkfI/yuW37CwNouuitzo/gGcF8BYO1dFNlaRffJPyzdWTa78yegRpH55xQffuhr8+qF8we45BvoLdpgTOHe6W0Lz5C9Sjv9F9MDW7ht8j3yQPG0cL9oDWwM98C9gzP8mxfxvogeamrxK6PHXLfdA1my7IeKB14BzDBhr54aIByL75HXLPdDkynVGrZD65Q0fPPCf4NcPxQM9x0B7YGugByKd4F9Sjv9L9MBP3Dc4CuxvZq1/CR74CdAD/wXG/CYp5jeJHmhq8h9Cj79luQeyZluyWhoeeAs4x24h3a0W1om8H3SvRPbJZNnt9kCTK4YRXSv3ZOf0S7Nu3mR3/qDrJ3n2wNcPxQM9x0B74CdAD0Q6QQpSjqfIzvPAT903OA7sb2Ytw4v2wE+BHhgap4R+3pSkmKfMzvNAU5PJCT0+JbkfhSXshzbb7hXxwHuBcwwYa+deEQ9E9slUlnugyZVUhFpJTeqXqX3wwDTBrx/agZtLhPvvVJZ/btazrKlF5k1aYL0AY+2kFsibtITemw7Ye81sVTxwg7wGLMb70IzoRPJuGhPLTd794IAkRyeM2zDuA35es575zKyiNj/oYZM++MOGduAmPWHYPEAS/Qd8EP0Hk8TlLujiDtzcT8ilDKRcykDcWG3jvsGPyH+pLW0cL3rmtgHO3AzAGfQQKeYPETdWjROlIeR/estvWFibRQ+I3OhmBM4LYKydB0Q2VpF9MpPlG6smVzIRaiUzqV9m9sG3sgS/fihfsHuOgf6CHeYEzp3ultA8yUrK8axED2zrvsFJYH8za2UleGBboAdmBcY8Gynm2YgeaGoyC6HHZ7TcA1mzLZOIB2YHzjFgrJ1MIh6I7JM5LPdAkys5CLXyMKlfPuyDB+YMfv1QPNBzDLQHtgV6INIJcpFyPBfRA9u5b3Aa2N/MWrkIHtgO6IG5gDHPTYp5bqIHmprMSejx2Sz3QNZsyy7igY8A5xgw1k52EQ9E9sk8lnugyZU8hFrJS+qXeX3wwEeDXz8UD/QcA+2B7YAeiHSCx0g5/hjRAz9z3+AM8n+5IW0cL9oDPwN64GPAmOcjxTwf0QNNTT5K6PG5LPdA1mzLLeKBjwPnGDDWTm4RD0T2yfyWe6DJlfyEWilA6pcFfPDAJ4JfP7QDNw8ScukRgYMTjGdZ84jMmyeB9QKMtZNHIG+eJORNwaQDNw7yGrAYC9l+4Ma7aUwsN3mFBQ7cFAIfuCksduDmqeAPG9qBm6cIw+Zpkug/7YPoP5MkLndBF3fgpjAhl4qQcqkIcWO1vfsG54AbBmatIoSN1fbAmVsEOIPCSDEPI26sGid6gpD/+S2/YaFtFonc6DrAeQGMtVNAZGMV2SfDLd9YNbkSTqiVCFK/jPDBtyKDXz+UL9g9x0B/wQ5zAudOd0tonkSRcjyK6IEd3Df4FdjfzFpRBA/sAPTAKGDMi5JiXpTogaYmIwk9vpDlHsiabYVFPDAaOMeAsXYKi3ggsk/GWO6BJldiCLVSjNQvi/nggc8Gv34oHug5BtoDOwA9EOkExUk5XpzogR3dN7gA7G9mreIED+wI9MDiwJiXIMW8BNEDTU0+y9gPt9wDWbMtTMQDSwLnGDDWTpiIByL75HOWe6DJlecItfI8qV8+74MHvhD8+qF4oOcYaA/sCPRApBOUIuV4KaIHdnLf4CKwv5m1ShE8sBPQA0sBY16aFPPSRA/8zzwj9PhIyz2QNduiRDywDHCOAWPtRIl4ILJPvmi5B5pceZFQK2VJ/bKsDx74UvDrh3bg5hlCLhUVODjBeJY1WmTevAysF2CsnWiBvHmZkDevJB24cZDXgMVYzvYDN95NY2K5ySsvcOCmHPjATXmxAzcVgj9saAduKhCGzask0X/VB9GvmCQud0EXd+CmPCGXXiPl0mvEjdXO7htcBm4YmLVeI2ysdgbO3NeAM6gSKeaViBurxoleIuR/SctvWFibRc+J3Oi+DpwXwFg7z4lsrCL7ZGXLN1ZNrlQm1MobpH75hg++9Wbw64fyBbvnGOgv2GFO4NzpbgnNk7dIOf4W0QO7uG/wB7C/mbXeInhgF6AHvgWMeRVSzKsQPdDU5JuEHl/acg9kzbYyIh5YFTjHgLF2yoh4ILJPVrPcA02uVCPUytukfvm2Dx5YPfj1Q/FAzzHQHtgF6IFIJ6hByvEaRA/s6r7BFWB/M2vVIHhgV6AH1gDGvCYp5jWJHmhqsjqhx79suQeyZtsrIh5YCzjHgLF2XhHxQGSffMdyDzS58g6hVt4l9ct3ffDA94JfPxQP9BwD7YFdgR6IdIL3STn+PtEDu7lv8Bewv5m13id4YDegB74PjHltUsxrEz3Q1OR7jGdsLPdA1myrKOKBdYBzDBhrp6KIByL7ZF3LPdDkSl1CrdQj9ct6PnhgbPDrh3bgpiLjOTyBgxOMZ1kricyb+sB6AcbaqSSQN/UJedMg6cCNg7wGLMaGth+48W4aE8tNXiOBAzcNwQduGokduPkg+MOGduDmA8Kw+ZAk+h/6IPqNk8TlLujiDtw0IuRSE1IuNSFurHZ33+AacMPArNWEsLHaHThzmwBnUFNSzJsSN1aNE8US8r+K5TcsrM2iqiI3uh8B5wUw1k5VkY1VZJ/82PKNVZMrHxNqpRmpXzbzwbeaB79+KF+we46B/oId5gTOne6W0DxpQcrxFkQP7OG+wQ1gfzNrtSB4YA+gB7YAxrwlKeYtiR5oarI5ocfXsNwDWbOtpogHtgLOMWCsnZoiHojsk60t90CTK60JtfIJqV9+4oMHfhr8+qF4oOcYaA/sAfRApBO0IeV4G6IH9nTf4F9gfzNrtSF4YE+gB7YBxrwtKeZtiR5oavJTQo9/z3IPZM2290U8sB1wjgFj7bwv4oHIPvmZ5R5ocuUzQq20J/XL9j54YIfg1w/FAz3HQHtgT6AHIp2gIynHOxI9sJf7BreA/c2s1ZHggb2AHtgRGPNOpJh3InqgqckOjIfpLfdA1myLFfHAzsA5Boy1Eyvigcg+2cVyDzS50oVQK11J/bKrDx7YLfj1Qztw05iQS/UFDk4wnmVtIDJvugPrBRhrp4FA3nQn5E2PpAM3DvIasBh72n7gxrtpTCw3eb0EDtz0BB+46SV24KZ38IcN7cBNb8Kw6UMS/T4+iH7fJHG5C7q4Aze9CLnUj5RL/Ygbq73dN7gnHW49s1Y/wsZqb+DM7QecQf1JMe9P3Fg1TtSNceDM8hsW1mZRU5Eb3QHAeQGMtdNUZGMV2ScHWr6xanJlIKFWBpH65SAffGtw8OuH8gW75xjoL9hhTuDc6W4JzZMhpBwfQvTAPu4bpAD2N7PWEIIH9gF64BBgzIeSYj6U6IGmJgcTenxzyz2QNdtaiHjgMOAcA8baaSHigcg+OdxyDzS5MpxQK5+T+uXnPnjgiODXD8UDPcdAe2AfoAcinWAkKcdHEj2wr/sG9wL7m1lrJMED+wI9cCQw5qNIMR9F9EBTkyMYhyot90DWbPtUxANHA+cYMNbOpyIeiOyTYyz3QJMrYwi1MpbUL8f64IHjgl8/FA/0HAPtgX2BHoh0gvGkHB9P9MB+7hukBvY3s9Z4ggf2A3rgeGDMJ5BiPoHogaYmxxF6/GeWeyBrtrUX8cCJwDkGjLXTXsQDkX1ykuUeaHJlEqFWJpP65WQfPHBK8OuHduCmLyGXOggcnGA8y9pRZN5MBdYLMNZOR4G8mUrIm2lJB24c5DVgMU63/cCNd9OYWG7yZggcuJkOPnAzQ+zAzRfBHza0AzdfEIbNTJLoz/RB9Gclictd0MUduJlByKXZpFyaTdxY7e++QVrghoFZazZhY7U/cObOBs6gOaSYzyFurBonmkLI/+6W37CwNot6iNzozgXOC2CsnR4iG6vIPjnP8o1VkyvzCLUyn9Qv5/vgW18Gv34oX7B7joH+gh3mBM6d7pbQPFlAyvEFRA8c4L7BfcD+ZtZaQPDAAUAPXACM+UJSzBcSPdDU5JeMf8TCcg9kzba+Ih64CDjHgLF2+op4ILJPLrbcA02uLCbUyhJSv1zigwcuDX79UDzQcwy0Bw4AeiDSCZaRcnwZ0QMHum+QHtjfzFrLCB44EOiBy4AxX06K+XKiB5qaXEro8QMt90DWbBsk4oErgHMMGGtnkIgHIvvkSss90OTKSkKtrCL1y1U+eODq4NcPxQM9x0B74ECgByKdYA0px9cQPXCQ+wYPAvubWWsNwQMHAT1wDTDma0kxX0v0QFOTqwk9fpjlHsiabcNFPHAdcI4BY+0MF/FAZJ9cb7kHmlxZT6iVDaR+ucEHD9wY/PqhHbiZxfjHnAQOTjCeZR0hMm82AesFGGtnhEDebCLkzeakAzcO8hqwGLfYfuDGu2lMLDd5WwUO3GwBH7jZKnbgZlvwhw3twM02wrDZThL97T6I/o4kcbkLurgDN1sJubSTlEs7iRurg903eAi4YWDW2knYWB0MnLk7gTNoFynmu4gbq8aJNhLyf5zlNyyszaLxIje6u4HzAhhrZ7zIxiqyT+6xfGPV5MoeQq3sJfXLvT741r7g1w/lC3bPMdBfsMOcwLnT3RKaJ/tJOb6f6IFD3DfIBOxvZq39BA8cAvTA/cCYHyDF/ADRA01N7mP8a3WWeyBrtk0R8cCvgHMMGGtniogHIvvkQcs90OTKQUKtfE3ql1/74IHfBL9+KB7oOQbaA4cAPRDpBN+ScvxbogcOdd8gC7C/mbW+JXjgUKAHfguM+SFSzA8RPdDU5DeEHj/Dcg9kzbYvRDzwO+AcA8ba+ULEA5F98rDlHmhy5TChVo6Q+uURHzzw++DXD8UDPcdAe+BQoAcineAHUo7/QPTAYe4bZAP2N7PWDwQPHAb0wB+AMT9KivlRogeamvye0OPnWO6BrNk2V8QDjwHnGDDWzlwRD0T2yeOWe6DJleOEWjlB6pcnfPDAH4NfP5Tngc1zeMhnGFnPiP6U3e75ZT73T4TPfTLpIIZzMrv9jKdsP4jh3UwkFvk/LXAQ4xT4IMZp0kEM9Gc3eYgc2Cwh+pnQeMwPWn7OAK/lAzVxaz1Y0+6hbeTnDCFvFgucGv2Z8LmXiNxsnwXWCzDWTuj1S9gGb10npbtGqpDcCf1B59NZ8I2j93MuOxH4XHb8ur8ABzrrc/8iIgmH3VuVX7Li1vvRXetcVnzT+9Vy0TwCvo4/ka7jecuv4/fg63iSdB0vWH4dfwBfx1Ok6/ib5dfxKPg6niZdx4uWX8dj4Ov4M+k6XrL8Oh4HX8czpOt42fLreAJ8Hc+SruPvYOnPlCyOMV22uG+LzOv8Ia8LhLx+IuT1kyGvC4a8LhTyunDI66dCXj8d8vqZkNdFQl6Hhbx2Ql6Hh7yOCHn9a/b/vj4f8vpCyOvfQl5fDHl9KeT15ZDXv99+/Yf73z/d3yvu71X39y/392/395r7e/221zM2C34hbBbcIH+jg9hQZXzuf4CbDylvf25vg8S8Xu01pGScfMiSDBs3BmNWAcZsAozZBRhzCDA+LMCYU4AxlwBjbgHGRwQY8wgw5hVgfFSA8TEBxnwCjI8LMOYXYCwgwPiEAOOTAowFBRgLCTAWFmB8SoDxaQHGZwQYiwgwhgkwOgKM4QKMEQKMkQKMUQKMRQUYowUYYwQYiwkwPivAWFyAsYQAY0kBxucEGJ8XYHxBgLGUAGNpAcYyAowvCjCWFWB8SYDxZQHGVwQYywkwlhdgrCDA+KoAY0UBxtcEGCsJML4uwFhZgPENAcY3BRjfEmCsIsBYVYCxmgDj2wKM1QUYawgw1hRgrCXA+I4A47sCjO8JML4vwFhbgLGOAGNdAcZ6AoyxAoz1BRgbCDA2FGBsJMD4gQDjhwKMjQUYmwgwNhVg/EiA8WMBxmYCjM0FGFsIMLYUYGwlwNhagPETAcZPBRjbCDC2FWBsJ8D4mQBjewHGDgKMHQUYOwkwdhZg7CLA2FWAsZsAY3cBxh4CjD0FGHsJMPYWYOwjwNhXgLGfAGN/AcYBAowDBRgHCTAOFmAcIsA4VIBxmADjcAHGzwUYRwgwjhRgHCXAOFqAcYwA41gBxnECjOMFGCcIME4UYJwkwDhZgHGKAONUAcZpAozTBRhnCDB+IcA4U4BxlgDjbAHGOQKMcwUY5wkwzhdg/FKAcYEA40IBxkUCjIsFGJcIMC4VYFwmwLhcgHGFAONKAcZVAoyrBRjXCDCuFWBcJ8C4XoBxgwDjRgHGTQKMmwUYtwgwbhVg3CbAuF2AcYcA404Bxl0CjLsFGPcIMO4VYNwnwLhfgPGAAONXAowHBRi/FmD8RoDxWwHGQwKM3wkwHhZgPCLA+L0A4w8CjEcFGI8JMB4XYDwhwPijAONPAownBRhPCTCeFmD8WYDxjADjWQHGcwKMvwgw/irAeF6A8YIA428CjBcFGC8JMF4WYPxdgPEPAcY/BRivCDBeFWD8S4DxbwHGawKM1wUYbwgw/iPA+K8A400BxlsCjGZB2xnvEWBMLsCYQoAxpQDjvQKMqQQYUwswphFgTCvAmE6A8T4BxvsFGNMLMD4gwPigAGMGAcaHBBgzCjBmEmDMLMCYRYAxqwBjNgHG7AKMOQQYHxZgzCnAmEuAMbcA4yMCjHkEGPMKMD4qwPiYAGM+AcbHBRjzCzAWEGB8QoDxSQHGggKMhQQYCwswPiXA+LQA4zMCjEUEGMMEGB0BxnABxggBxkgBxigBxqICjNECjDECjMUEGJ8VYCwuwFhCgLGkAONzAozPCzC+IMBYSoCxtABjGQHGFwUYywowviTA+LIA4ysCjOUEGMsLMFYQYHxVgLGiAONrAoyVBBhfF2CsLMD4hgDjmwKMbwkwVhFgrCrAWE2A8W0BxuoCjDUEGGsKMNYSYHxHgPFdAcb3BBjfF2CsLcBYR4CxrgBjPQHGWAHG+gKMDQQYGwowNhJg/ECA8UMBxsYCjE0EGJsKMH4kwPixAGMzAcbmAowtBBhbCjC2EmBsLcD4iQDjpwKMbQQY2wowthNg/EyAsb0AYwcBxo4CjJ0EGDsLMHYRYOwqwNhNgLG7AGMPAcaeAoy9BBh7CzD2EWDsK8DYT4CxvwDjAAHGgQKMgwQYBwswDhFgHCrAOEyAcbgA4+cCjCMEGEcKMI4SYBwtwDhGgHGsAOM4AcbxAowTBBgnCjBOEmCcLMA4RYBxqgDjNAHG6QKMMwQYvxBgnCnAOEuAcbYA4xwBxrkCjPMEGOcLMH4pwLhAgHGhAOMiAcbFAoxLBBiXCjAuE2BcLsC4QoBxpQDjKgHG1QKMawQY1wowrhNgXC/AuEGAcaMA4yYBxs0CjFsEGLcKMG4TYNwuwLhDgHGnAOMuAcbdAox7BBj3CjDuE2DcL8B4QIDxKwHGgwKMXwswfiPA+K0A4yEBxu8EGA8LMB4RYPxegPEHAcajAozHBBiPCzCeEGD8UYDxJwHGkwKMpwQYTwsw/izAeEaA8awA4zkBxl8EGH8VYDwvwHhBgPE3AcaLAoyXBBgvCzD+LsD4hwDjnwKMVwQYrwow/iXA+LcA4zUBxusCjDcEGP8RYPxXgPGmAOMtAcZkye1nvEeAMbkAYwoBxpQCjPcKMKYSYEwtwJhGgDGtAGM6Acb7BBjvF2BML8D4gADjgwKMGQQYHxJgzCjAmEmAMbMAYxYBxqwCjNkEGLMLMOYQYHxYgDGnAGMuAcbcAoyPCDDmEWDMK8D4qADjYwKM+QQYHxdgzC/AWECA8QkBxicFGAsKMBYSYCwswPiUAOPTAozPCDAWEWAME2B0BBjDBRgjBBgjBRijBBiLCjBGCzDGCDAWE2B8VoCxuABjCQHGkgKMzwkwPi/A+IIAYykBxtICjGUEGF8UYCwrwPiSAOPLAoyvCDCWE2AsL8BYQYDxVQHGigKMrwkwVhJgfF2AsbIA4xsCjG8KML4lwFhFgLGqAGM1Aca3BRirCzDWEGCsKcBYS4DxHQHGdwUY3xNgfF+AsbYAYx0BxroCjPUEGGMFGOsLMDYQYGwowNhIgPEDAcYPBRgbCzA2EWBsKsD4kQDjxwKMzQQYmwswthBgbCnA2EqAsbUA4ycCjJ8KMLYRYGwrwNhOgPEzAcb2AowdBBg7CjB2EmDsLMDYRYCxqwBjNwHG7gKMPQQYewow9hJg7C3A2EeAsa8AYz8Bxv4CjAMEGAcKMA4SYBwswDhEgHGoAOMwAcbhAoyfCzCOEGAcKcA4SoBxtADjGAHGsQKM4wQYxwswThBgnCjAOEmAcbIA4xQBxqkCjNMEGKcLMM4QYPxCgHGmAOMsAcbZAoxzBBjnCjDOE2CcL8D4pQDjAgHGhQKMiwQYFwswLhFgXCrAuEyAcbkA4woBxpUCjKsEGFcLMK4RYFwrwLhOgHG9AOMGAcaNAoybBBg3CzBuEWDcKsC4TYBxuwDjDgHGnQKMuwQYdwsw7hFg3CvAuE+AcT+BkcGZPTWHMxmS04kx/3M+//f5M9x+/W/2ZMluur+33N9kOdz/O/c3ufubwv1N6f7e6/6mcn9Tu79p3N+07m869/c+9/f+HHFrpM9xe9EUt/9rFs37P3+7Gc/fbsXzNwPxv3+7J56/JY/nbyni+VvKeP52bzx/SxXP31LH87c08fwtbTx/SxfP3+6L52/3x/O39Lf/5gUrNAkiwopGRsZGh8c6EU7tsPBidWKiwiKj6hSNcWKcqJioeuExERGxMZEx0cXqFIsOK+ZERsQ69aOKRcTWNz9hznB3wRzp3Ov3P+uGJeTHCQsz6yaUsf7t5R7IgSuo0Ov6QMh1TQ66rh7z5+4b5EyHW8+sZXhTIONkHj69B7dWaJwS+nkfJMX8QWIteTGHxsiJyyXUWsgYZSDFKAOxLke4b5AbWJdmrQyEuhwBrMsMwJg/RIr5QyEx935SgGOfA9yPUWtlxF3TiNDrh64dZN1kwn1mJ1kyvMSbmBhG1IzwPndmUv1kTsT1kwV3TcPjy6WEeoE3c9BeMALoBcgZkZWU41mJXjDSfYM8wJw0a2UleMFIoBdkBcY8Gynm2f4fvh6WsB/H1GQWQo/fVwu7AaQy2/aDP7f3g55j2YHuAYy1A7x+Tuj1Q/dKZJ/MYbkHmlzJQaiVh0n98mEfPDBn8OsnLL66CUvYj2P8OV02rI+bvXU0p1kTxZgrB2cmoHsa8t4mN7mnoVw3sbjpIzns7gumRnLnwObfIzn+WyvIzw6dr05c3T1CmK95SPM1D/EedJT7Bo8C+5BZKw/hHnQUsM7zAPM+LynmeYn3oKYP5yTk/3eW34OyvPqwyD3oo0BHAMbaOSxyD4rsk49Zfg9qcuUxQq3kI/XLfD7cgz4e/PqJt+8m9LsIzzHQ30XAnMC5090Smif5STmen+iBo903yAfsb2at/AQPHA30wPzAmBcgxbwA0QNNTT5O6PFHLfdA1mw7JuKBTwDnGDDWzjERD0T2ySct90CTK08SaqUgqV8W9MEDCwW/fige6DkG2gNHAz0Q6QSFSTlemOiBY9w3yA/sb2atwgQPHAP0wMLAmD9FivlTRA80NVmI0ON/stwDWbPtpIgHPg2cY8BYOydFPBDZJ5+x3ANNrjxDqJUipH5ZxAcPDAt+/VA80HMMtAeOAXog0gkcUo47RA8c677BE8D+ZtZyCB44FuiBDjDm4aSYhxM90NRkGKHHn7HcA1mz7ayIB0YA5xgw1s5ZEQ9E9slIyz3Q5EokoVaiSP0yygcPLBr8+qE9m5wf/GzyTcKzyTeBzyZHW/5cqLmGBcAxuUWIyS1gTGIEYvIEOCbm37hBcyYD+nMxgZg8CY7JPYSY3AOMybMCMSkIjklyQkySA2NSXCAmhcAxSUGISQpgTEoIxKQwOCYpCTFJCYxJSYGYPAWOyb2EmNwLjMlzAjF5GhyTVISYpALG5HmBmDwDjklqQkxSA2PygkBMioBjkoYQkzTAmJQSiEkYOCZpCTFJC4xJaYGYOOCYpCPEJB0wJmUEYhIOjsl9hJjcB4zJiwIxiQDH5H5CTO4HxqQsMCbm+w1zFN/7B7bNWX+z72z2Oc2+mtnHMfsG5j7V3BcZD/+P97m/Zq6ZPmrq1uRJ2ZAz/fB/CytH3L9BgP4u6SXgtUx++1r+7w9qfda1fSmH/YwvoxnRieQ9BJNYHlp5xfLBYJrFy8DPa9Z7JQenqBn/aMkrhGZZjvTFezniw2nj3DcoCHzowqxVjvBw2jhgnZcD5n15UszLEx9OM324KCH/73/H4ronPnCT/h28ICRLhn+4pgLw4RpgrB3g9aM+nIbsk69a/nCayZVXCbVSkdQvK/rwcNprwa8fyiEFzzHQhxRgTuDc6W4JzZNKpByvRPTA8e4bFAb2N7NWJYIHjgd6YCVgzF8nxfx1ogeamnyN0OMfstwDWbMto4gHVgbOMWCsnYwiHojsk29Y7oEmV94g1MqbpH75pg8e+Fbw64figZ5joD1wPNADkU5QhZTjVYgeOMF9g6eB/c2sVYXggROAHlgFGPOqpJhXJXqgqcm3CD0+q+UeyJpt2UQ8sBpwjgFj7WQT8UBkn3zbcg80ufI2oVaqk/pldR88sEbw64figZ5joD1wAtADkU5Qk5TjNYkeONF9gyLA/mbWqknwwIlAD6wJjHktUsxrET3Q1GQNQo/PabkHsmZbLhEPfAc4x4CxdnKJeCCyT75ruQeaXHmXUCvvkfrlez544PvBrx9K3/UeWk5OWBcV29yWX0PzLGN81zChn7s2MKdtv4bm+tUm9LQ6SQ/PO8hrwGKsa/vD897NWGK5eaon8PB8XfDD8/UUHp4nDpxYOwcORaLN9YslDJz6JImuT9x0YOVTg8QiMLcPtNQj5FNDUj41JG5cTnLfwAHekJu1GhI2LicBZ29D4CxqRIp5I2IPMW70PiH/81l+48LajHlcZOPyA2CPB8baeVxk4xLZJz+0fOPS5MqHhFppTOqXjX3YuGwS/PqhfIHtOQb6C2yYEzh3ultC86QpKcebEj1wsvsGEcD+ZtZqSvDAyUAPbAqM+UekmH9E9EBTk00IPf5Jyz2QNdsKinjgx8A5Boy1U1DEA5F9spnlHmhypRmhVpqT+mVzHzywRfDrh+KBnmOgPXAy0AORTtCSlOMtiR44xX2DKGB/M2u1JHjgFKAHtgTGvBUp5q2IHmhqsgWhxz9tuQeyZtszIh7YGjjHgLF2nhHxQGSf/MRyDzS58gmhVj4l9ctPffDANsGvH4oHeo6B9sApQA9EOkFbUo63JXrgVPcNooH9zazVluCBU4Ee2BYY83akmLcjeqCpyTaEHh9uuQeyZluEiAd+BpxjwFg7ESIeiOyT7S33QJMr7Qm10oHULzv44IEdg18/tGdjGxByKVLgAAXjedYokXnTCVgvwFg7UQJ504mQN52TDt44yGvAYuxi+8Eb76YxsdzkdRU4eNMFfPCmK+ngjfeDHjbdgj9saIduuhGGTXeS6Hf3QfR7JInLXdDFHbjpSsilnqRc6kncWJ3mvkEx4IaBWasnYWN1GnDm9gTOoF6kmPcibqwaJ+pIyP/ilt+wsDaLSojc6PYGzgtgrJ0SIhuryD7Zx/KNVZMrfQi10pfUL/v64Fv9gl8/lC/YPcdAf8EOcwLnTndLaJ70J+V4f6IHTnffoDiwv5m1+hM8cDrQA/sDYz6AFPMBRA80NdmP0ONfsNwDWbOtlIgHDgTOMWCsnVIiHojsk4Ms90CTK4MItTKY1C8H++CBQ4JfPxQP9BwD7YHTgR6IdIKhpBwfSvTAGe4blAT2N7PWUIIHzgB64FBgzIeRYj6M6IGmJocQenxZyz2QNdteEvHA4cA5Boy185KIByL75OeWe6DJlc8JtTKC1C9H+OCBI4NfPxQP9BwD7YEzgB6IdIJRpBwfRfTAL9w3eB7Y38xaowge+AXQA0cBYz6aFPPRRA80NTmS0OPLW+6BrNlWQcQDxwDnGDDWTgURD0T2ybGWe6DJlbGEWhlH6pfjfPDA8cGvH9qBmx6EXHpV4OAE41nWiiLzZgKwXoCxdioK5M0EQt5MTDpw4yCvAYtxku0HbrybxsRykzdZ4MDNJPCBm8liB26mBH/Y0A7cTCEMm6kk0Z/qg+hPSxKXu6CLO3AzmZBL00m5NJ24sTrTfYNSwA0Ds9Z0wsbqTODMnQ6cQTNIMZ9B3Fg1TjSekP9vWn7DwtosekvkRvcL4LwAxtp5S2RjFdknZ1q+sWpyZSahVmaR+uUsH3xrdvDrh/IFu+cY6C/YYU7g3OluCc2TOaQcn0P0wFnuG5QB9jez1hyCB84CeuAcYMznkmI+l+iBpiZnE3r825Z7IGu2VRfxwHnAOQaMtVNdxAORfXK+5R5ocmU+oVa+JPXLL33wwAXBrx+KB3qOgfbAWUAPRDrBQlKOLyR64Gz3DcoC+5tZayHBA2cDPXAhMOaLSDFfRPRAU5MLCD3+Hcs9kDXb3hXxwMXAOQaMtfOuiAci++QSyz3Q5MoSQq0sJfXLpT544LLg1w/FAz3HQHvgbKAHIp1gOSnHlxM9cI77Bi8D+5tZaznBA+cAPXA5MOYrSDFfQfRAU5PLCD2+juUeyJptdUU8cCVwjgFj7dQV8UBkn1xluQeaXFlFqJXVpH652gcPXBP8+qEduJlGyKV6AgcnGM+yxorMm7XAegHG2okVyJu1hLxZl3TgxkFeAxbjetsP3Hg3jYnlJm+DwIGb9eADNxvEDtxsDP6woR242UgYNptIor/JB9HfnCQud0EXd+BmAyGXtpByaQtxY3Wu+wblgBsGZq0thI3VucCZuwU4g7aSYr6VuLFqnGgNIf8/tPyGhbVZ1FjkRncbcF4AY+00FtlYRfbJ7ZZvrJpc2U6olR2kfrnDB9/aGfz6oXzB7jkG+gt2mBM4d7pbQvNkFynHdxE9cJ77BhWA/c2stYvggfOAHrgLGPPdpJjvJnqgqcmdhB7/seUeyJptzUQ8cA9wjgFj7TQT8UBkn9xruQeaXNlLqJV9pH65zwcP3B/8+qF4oOcYaA+cB/RApBMcIOX4AaIHznffoCKwv5m1DhA8cD7QAw8AY/4VKeZfET3Q1OR+Qo9vZbkHsmZbaxEPPAicY8BYO61FPBDZJ7+23ANNrnxNqJVvSP3yGx888Nvg1w/FAz3HQHvgfKAHIp3gECnHDxE98Ev3DSoB+5tZ6xDBA78EeuAhYMy/I8X8O6IHmpr8ltDj21rugazZ1k7EAw8D5xgw1k47EQ9E9skjlnugyZUjhFr5ntQvv/fBA38Ifv3QDtxsJuTSZwIHJxjPsrYXmTdHgfUCjLXTXiBvjhLy5ljSgRsHeQ1YjMdtP3Dj3TQmlpu8EwIHbo6DD9ycEDtw82Pwhw3twM2PhGHzE0n0f/JB9E8mictd0MUduDlByKVTpFw6RdxYXeC+QWXghoFZ6xRhY3UBcOaeAs6g06SYnyZurBon+oGQ/10tv2FhbRZ1E7nR/Rk4L4CxdrqJbKwi++QZyzdWTa6cIdTKWVK/POuDb50Lfv1QvmD3HAP9BTvMCZw73S2hefILKcd/IXrgQvcN3gT2N7PWLwQPXAj0wF+AMf+VFPNfiR5oavIcocf3stwDWbOtt4gHngfOMWCsnd4iHojskxcs90CTKxcItfIbqV/+5oMHXgx+/VA80HMMtAcuBHog0gkukXL8EtEDF7lvUAXY38xalwgeuAjogZeAMb9MivllogeamrxI6PH9LfdA1mwbIOKBvwPnGDDWzgARD0T2yT8s90CTK38QauVPUr/80wcPvBL8+qF4oOcYaA9cBPRApBNcJeX4VaIHLnbfoBqwv5m1rhI8cDHQA68CY/4XKeZ/ET3Q1OQVQo8fYrkHsmbbUBEP/Bs4x4CxdoaKeCCyT16z3ANNrlwj1Mp1Ur+87oMH3gh+/dAO3Jwk5NIwgYMTjGdZh4vMm3+A9QKMtTNcIG/+IeTNv0kHbhzkNWAx3rT9wI1305hYbvJuCRy4uQk+cHNL7MBNsocDP2xoB27MtUP3iHtw8bhD9M26eZPd+YPOpeTBzyXagZtbBHFJQcqlFA/zNlaXuG9QHbhhYNYyvOiZuwQ4c0PjlNDPm5IU85QP8zZWjRPdIOT/GMtvWFibRWNFbnTvBc4LYKydsSIbq8g+meph7GdG14rJlVQE30pN6pepffCtNMGvH8oX7J5joL9ghzmBc6e7JTRP0pJyPC3RA5e6b1AT2N/MWmkJHrgU6IFpgTFPR4p5OqIHmppMQ+jxEy33QNZsmyTigfcB5xgw1s4kEQ9E9sn7LfdAkyv3E2rl/2PvP8CkqrqtDbQFMwaCSIaCboKSepGDgGQRkKSiItCEBhFREQEVERRQERExYwAVUBEVkKgEBVQERMw555xzvHvSvb+vqk/9595LjVFnjd29n6d+6+/vPKvfveacY4619l7NoSS9PDQNPvCw6NcPxQeGHgPtA9cAfSDSExxOyvHDiT5wbfALBgL1zcY6nOAD1wJ94OHAmJckxbwk0QdaTR5G0PjFnvtAVm+7R8QHlgL2MWCs3T0iPhCpk6U994GWK6UJtVKGpJdl0uADj4h+/VB8YOgx0D5wLdAHIj1BWVKOlyX6wHXBLxgM1DcbqyzBB64D+sCywJgfSYr5kUQfaDV5BEHj7/fcB7J621IRH1gO2MeAsXZLRXwgUifLe+4DLVfKE2qlAkkvK6TBB1aMfv3QDtwUI+TSAwIHJxjvsj4o0m8qAesFGGv3oEDeVCLkTWWg9lpvVTxwg5wDFmMVNCM6kcJFY2FZ5FUFB6QYOmGCSqwCvF8bz+6ZVdR2oZtNteg3G9qBm2qEZhMjGf1YGox+9SLjshd0eQduqhJyqQYpl2oQN1YfCX7BEOCGgY1Vg7Cx+giw59YA9qBMUswziRur5okqEvJ/pecLFtZm0SqRhW4WsF8AY+1WiWysInWypucbq5YrNQm1Uoukl7XS4LdqR79+KA/YQ4+BfsAO8wQu0bulmid1SDleh+gDHw1+wTCgvtlYdQg+8FGgD6wDjPlRpJgfRfSBVpO1CRq/znMfyOptj4j4wKOBfQwYa/eIiA9E6mRdz32g5UpdQq3UI+llvTT4wPrRrx+KDww9BtoHPgr0gUhP0ICU4w2IPnB98AtygfpmYzUg+MD1QB/YABjzhqSYNyT6QKvJ+gSN3+i5D2T1tk0iPjAb2MeAsXabRHwgUied5z7QcsURaqURSS8bpcEHNo5+/VB8YOgx0D5wPdAHIj1BE1KONyH6wA3BLxgJ1DcbqwnBB24A+sAmwJg3JcW8KdEHWk02Jmj8Fs99IKu3bRXxgc2AfQwYa7dVxAcidbK55z7QcqU5oVZakPSyRRp8YMvo1w/twE11Qi49IXBwgvEu65Mi/aYVsF6AsXZPCuRNK0LetC46cOOQc8BiPMb3AzfhorGwLPLaCBy4OQZ84KaN2IGbttFvNrQDN20JzaYdyei3S4PRP7bIuOwFXd6BmzaEXGpPyqX2xI3VjcEvGAXcMLCx2hM2VjcCe257YA/qQIp5B+LGqnmiloT83+n5goW1WfSMyEK3I7BfAGPtnhHZWEXqZCfPN1YtVzoRaqUzSS87p8FvdYl+/VAesIceA/2AHeYJXKJ3SzVPupJyvCvRB24KfsFooL7ZWF0JPnAT0Ad2Bcb8OFLMjyP6QKvJLgSNf85zH8jqbc+L+MBuwD4GjLV7XsQHInXyeM99oOXK8YRa6U7Sy+5p8IE9ol8/FB8Yegy0D9wE9IFIT9CTlOM9iT7wseAXjAHqm43Vk+ADHwP6wJ7AmJ9AivkJRB9oNdmDoPEve+4DWb3tFREf2AvYx4Cxdq+I+ECkTvb23AdarvQm1Eofkl72SYMP7Bv9+qH4wNBjoH3gY0AfiPQE/Ug53o/oAx8PfsE5QH2zsfoRfODjQB/YDxjzE0kxP5HoA60m+xI0/g3PfSCrt70p4gNPAvYxYKzdmyI+EKmTJ3vuAy1XTibUSn+SXvZPgw88Jfr1Qztwcywhl94SODjBeJf1bZF+cyqwXoCxdm8L5M2phLw5rejAjUPOAYtxgO8HbsJFY2FZ5J0ucOBmAPjAzeliB24GRr/Z0A7cDCQ0m0Ekoz8oDUZ/cJFx2Qu6vAM3pxNyKYeUSznEjdXNwS8YC9wwsLFyCBurm4E9NwfYg4aQYj6EuLFqnugUQv5/6PmChbVZ9JHIQncosF8AY+0+EtlYRerkMM83Vi1XhhFqZThJL4enwW/lRr9+KA/YQ4+BfsAO8wQu0bulmicjSDk+gugDtwS/YBxQ32ysEQQfuAXoA0cAYz6SFPORRB9oNZlL0PjPPPeBrN72uYgPPAPYx4Cxdp+L+ECkTo7y3Adarowi1MqZJL08Mw0+cHT064fiA0OPgfaBW4A+EOkJziLl+FlEH7g1+AXjgfpmY51F8IFbgT7wLGDMx5BiPoboA60mRxM0/mvPfSCrt30j4gPPBvYxYKzdNyI+EKmT53juAy1XziHUyrkkvTw3DT5wbPTrh+IDQ4+B9oFbgT4Q6QnOI+X4eUQf+ETwCyYC9c3GOo/gA58A+sDzgDEfR4r5OKIPtJocS9D4Hzz3gaze9qOIDzwf2MeAsXY/ivhApE6O99wHWq6MJ9TKBJJeTkiDD5wY/fqhHbgZTMilnwQOTjDeZf1ZpN9cAKwXYKzdzwJ5cwEhby4sOnDjkHPAYrzI9wM34aKxsCzyJgkcuLkIfOBmktiBm4uj32xoB24uJjSbySSjPzkNRv+SIuOyF3R5B24mEXJpCimXphA3Vp8MfsGFwA0DG2sKYWP1SWDPnQLsQVNJMZ9K3Fg1TzSRkP9/er5gYW0W/SWy0L0U2C+AsXZ/iWysInXyMs83Vi1XLiPUyjSSXk5Lg9+aHv36oTxgDz0G+gE7zBO4RO+Wap7MIOX4DKIPfCr4BZOA+mZjzSD4wKeAPnAGMOaXk2J+OdEHWk1OJ2h8xiC/fSCrt+0Dvu/wQvexK5DeA3fPDjh/VB+I1MkrPfeBlitXEmplJkkvZ6bBB14V/fqh+MDQY6B94FNAH4j0BLNIOT6L6AO3Bb9gMlDfbKxZBB+4DegDZwFjfjUp5lcTfaDV5FUEjd/Pcx/I6m37i/jA2cA+Boy121/EByJ18hrPfaDlyjWEWplD0ss5afCB10a/fig+MPQYaB+4DegDkZ5gLinH5xJ94NPBL5gC1Dcbay7BBz4N9IFzgTG/jhTz64g+0GryWoLGH+y5D2T1thIiPvB6YB8DxtqVEPGBSJ28wXMfaLlyA6FWbiTp5Y1p8IE3Rb9+aAduLiHk0iGe3zfrXdZDRfrNzcB6AcbaHSqQNzcT8uaWogM3DjkHLMZ5vh+4CReNhWWRd6vAgZt54AM3t4oduLkt+s2GduDmNkKzuZ1k9G9Pg9G/o8i47AVd3oGbWwm5NJ+US/OJG6vbg19wKXDDwMaaT9hY3Q7sufOBPWgBKeYLiBur5oluIuR/Gc8XLKzNoiNEFrp3AvsFMNbuCJGNVaRO3uX5xqrlyl2EWrmbpJd3p8FvLYx+/VAesIceA/2AHeYJXKJ3SzVPFpFyfBHRB+4IfsE0oL7ZWIsIPnAH0AcuAsZ8MSnmi4k+0GpyIUHjy3vuA1m9rYKID7wH2MeAsXYVRHwgUifv9dwHWq7cS6iV+0h6eV8afOCS6NcPxQeGHgPtA3cAfSDSE9xPyvH7iT5wZ/ALZgD1zca6n+ADdwJ94P3AmC8lxXwp0QdaTS4haHwVz30gq7dVFfGBDwD7GDDWrqqID0Tq5IOe+0DLlQcJtfIQSS8fSoMPXBb9+qH4wNBjoH3gTqAPRHqC5aQcX070gc8Ev+AKoL7ZWMsJPvAZoA9cDoz5ClLMVxB9oNXkMoLG1/DcB7J6W6aID3wY2MeAsXaZIj4QqZMrPfeBlisrCbWyiqSXq9LgA1dHv35oB27uIORSlsDBCca7rDVF+s0aYL0AY+1qCuTNGkLerC06cOOQc8BiXOf7gZtw0VhYFnmPCBy4WQc+cPOI2IGbR6PfbGgHbh4lNJv1JKO/Pg1Gf0ORcdkLurwDN48QcmkjKZc2EjdWdwW/YCZww8DG2kjYWN0F7LkbgT1oEynmm4gbq+aJVhPyv67nCxbWZlE9kYXuY8B+AYy1qyeysYrUycc931i1XHmcUCubSXq5OQ1+a0v064fygD30GOgH7DBP4BK9W6p5spWU41uJPvDZ4BfMAuqbjbWV4AOfBfrArcCYP0GK+RNEH2g1uYWg8dme+0BWb3MiPvBJYB8Dxto5ER+I1MmnPPeBlitPEWplG0kvt6XBBz4d/fqh+MDQY6B94LNAH4j0BNtJOb6d6AN3B79gNlDfbKztBB+4G+gDtwNjvoMU8x1EH2g1+TRB45t67gNZva2ZiA/cCexjwFi7ZiI+EKmTz3juAy1XniHUyi6SXu5Kgw98Nvr1Q/GBocdA+8DdQB+I9AS7STm+m+gDnwt+wRygvtlYuwk+8DmgD9wNjPlzpJg/R/SBVpPPEjS+lec+kNXbWov4wOeBfQwYa9daxAcidfIFz32g5coLhFp5kaSXL6bBB74U/fqhHbjZQMilYwQOTjDeZW0j0m9eBtYLMNaujUDevEzIm1eKDtw45BywGF/1/cBNuGgsLIu81wQO3LwKPnDzmtiBm9ej32xoB25eJzSbN0hG/400GP03i4zLXtDlHbh5jZBLb5Fy6S3ixurzwS+YC9wwsLHeImysPg/suW8Be9DbpJi/TdxYNU/0EiH/O3q+YGFtFnUSWei+A+wXwFi7TiIbq0idfNfzjVXLlXcJtfIeSS/fS4Pfej/69UN5wB56DPQDdpgncIneLdU8+YCU4x8QfeALwS+4HqhvNtYHBB/4AtAHfgCM+YekmH9I9IFWk+8TNP44z30gq7d1E/GBHwH7GDDWrpuID0Tq5Mee+0DLlY8JtfIJSS8/SYMP/DT69UPxgaHHQPvAF4A+EOkJPiPl+GdEH/hi8AtuBOqbjfUZwQe+CPSBnwFj/jkp5p8TfaDV5KcEje/puQ9k9bYTRHzgF8A+Boy1O0HEByJ18kvPfaDlypeEWvmKpJdfpcEHfh39+qH4wNBjoH3gi0AfiPQE35By/BuiD3wp+AU3A/XNxvqG4ANfAvrAb4Ax/5YU82+JPtBq8muCxvf13Aeyels/ER/4HbCPAWPt+on4QKROfu+5D7Rc+Z5QKz+Q9PKHNPjAH6NfP5T3ge09POQ7jKx3RH+q6Hf/svv+iXDfPxcdxHA/V/Sf8RffD2KEi4nCYv5/FTiI8Qv4IMavpIMY6Hu3PEQ2bJYh+o0gPHahzc/vwLlcdTpurNWn+920zfz8Tsib0wROjf5GuO8BIovtP4D1Aoy1i5+/1DZ4h7l9gzH2j8ud+AudT3+AF47h9WdFIvCfFfHj/gVs6Kz7/kvEJHxZPmAtjxvvx2CsP8vjRe9vz43mV+B5/Ik0j/94Po9fg+fxZ9I8/uv5PH4DnsdfSPOYUcnvefwWPI+/kuZxH8/n8TvwPP5Gmsdins/j9+B5/J00j8U9n8cfwPP4B2ke9wXOo7GVychjrFwh72mRfW8e971F3PeWcd9bxX1vHff9mLjvbeK+t4373i7u+7Fx39vHfe8Q971j3PdOcd87x33/u+J/v/8T9/3fuO/WW8Lv+8R9Lxb3vXjc933zv+8X/Hf/4HNA8Dkw+BwUfA4OPiWCzyGV8mLB2Cz4i7BZcCi4DtF8rPs+DHffexb54ZPWcA42hIKUwcmHshnYuDEYjxRgLCfAWF6AsYIAY0UBxkoCjJUFGKsIMFYVYKwmwBgTYKwuwFhDgDFTgDFLgLGmAGMtAcbaAox1BBiPEmA8WoCxrgBjPQHG+gKMDQQYGwowZgswOgHGRgKMjQUYmwgwNhVgbCbA2FyAsYUAY0sBxlYCjK0FGI8RYGwjwNhWgLGdAOOxAoztBRg7CDB2FGDsJMDYWYCxiwBjVwHG4wQYuwkwHi/A2F2AsYcAY08BxhMEGHsJMPYWYOwjwNhXgLGfAOOJAownCTCeLMDYX4DxFAHGUwUYTxNgHCDAeLoA40ABxkECjIMFGHMEGIcIMA4VYBwmwDhcgDFXgHGEAONIAcYzBBhHCTCeKcA4WoDxLAHGMQKMZwswniPAeK4A41gBxvMEGMcJMJ4vwDhegHGCAONEAcYLBBgvFGC8SIBxkgDjxQKMkwUYLxFgnCLAOFWA8VIBxssEGKcJME4XYJwhwHi5AOMVAoxXCjDOFGC8SoBxlgDj1QKMswUYrxFgnCPAeK0A41wBxusEGK8XYLxBgPFGAcabBBhvFmC8RYBxngDjrQKMtwkw3i7AeIcA43wBxgUCjHcKMN4lwHi3AONCAcZFAoyLBRjvEWC8V4DxPgHGJQKM9wswLhVgfECA8UEBxocEGJcJMC4XYFwhwPiwAONKAcZVAoyrBRjXCDCuFWBcJ8D4iADjowKM6wUYNwgwbhRg3CTA+JgA4+MCjJsFGLcIMG4VYHxCgPFJAcanBBi3CTA+LcC4XYBxhwDjTgHGZwQYdwkwPivAuFuA8TkBxucFGF8QYHxRgPElAcaXBRhfEWB8VYDxNQHG1wUY3xBgfFOA8S0BxrcFGN8RYHxXgPE9Acb3BRg/EGD8UIDxIwHGjwUYPxFg/FSA8TMBxs8FGL8QYPxSgPErAcavBRi/EWD8VoDxOwHG7wUYfxBg/FGA8ScBxp8FGH8RYPxVgPE3AcbfBRj/EGD8U4DxLwHGvwUY/xFg/FeA0Qb0nXEfAcZiAozFBRj3FWDcT4BxfwHGAwQYDxRgPEiA8WABxhICjIcIMB4qwHiYAOPhAowlBRhLCTCWFmAsI8B4hABjWQHGIwUYywkwlhdgrCDAWFGAsZIAY2UBxioCjFUFGKsJMMYEGKsLMNYQYMwUYMwSYKwpwFhLgLG2AGMdAcajBBiPFmCsK8BYT4CxvgBjAwHGhgKM2QKMToCxkQBjYwHGJgKMTQUYmwkwNhdgbCHA2FKAsZUAY2sBxmMEGNsIMLYVYGwnwHisAGN7AcYOAowdBRg7CTB2FmDsIsDYVYDxOAHGbgKMxwswdhdg7CHA2FOA8QQBxl4CjL0FGPsIMPYVYOwnwHiiAONJAownCzD2F2A8RYDxVAHG0wQYBwgwni7AOFCAcZAA42ABxhwBxiECjEMFGIcJMA4XYMwVYBwhwDhSgPEMAcZRAoxnCjCOFmA8S4BxjADj2QKM5wgwnivAOFaA8TwBxnECjOcLMI4XYJwgwDhRgPECAcYLBRgvEmCcJMB4sQDjZAHGSwQYpwgwThVgvFSA8TIBxmkCjNMFGGcIMF4uwHiFAOOVAowzBRivEmCcJcB4tQDjbAHGawQY5wgwXivAOFeA8ToBxusFGG8QYLxRgPEmAcabBRhvEWCcJ8B4qwDjbQKMtwsw3iHAOF+AcYEA450CjHcJMN4twLhQgHGRAONiAcZ7BBjvFWC8T4BxiQDj/QKMSwUYHxBgfFCA8SEBxmUCjMsFGFcIMD4swLhSgHGVAONqAcY1AoxrBRjXCTA+IsD4qADjegHGDQKMGwUYNwkwPibA+LgA42YBxi0CjFsFGJ8QYHxSgPEpAcZtAoxPCzBuF2DcIcC4U4DxGQHGXQKMzwow7hZgfE6A8XkBxhcEGF8UYHxJgPFlAcZXBBhfFWB8TYDxdQHGNwQY3xRgfEuA8W0BxncEGN8VYHxPgPF9AcYPBBg/FGD8SIDxYwHGTwQYPxVg/EyA8XMBxi8EGL8UYPxKgPFrAcZvBBi/FWD8ToDxewHGHwQYfxRg/EmA8WcBxl8EGH8VYPxNgPF3AcY/BBj/FGD8S4DxbwHGfwQY/xVgzCjmP+M+AozFBBiLCzDuK8C4nwDj/gKMBwgwHijAeJAA48ECjCUEGA8RYDxUgPEwAcbDBRhLCjCWEmAsLcBYRoDxCAHGsgKMRwowlhNgLC/AWEGAsaIAYyUBxsoCjFUEGKsKMFYTYIwJMFYXYKwhwJgpwJglwFhTgLGWAGNtAcY6AoxHCTAeLcBYV4CxngBjfQHGBgKMDQUYswUYnQBjIwHGxgKMTQQYmwowNhNgbC7A2EKAsaUAYysBxtYCjMcIMLYRYGwrwNhOgPFYAcb2AowdBBg7CjB2EmDsLMDYRYCxqwDjcQKM3QQYjxdg7C7A2EOAsacA4wkCjL0EGHsLMPYRYOwrwNhPgPFEAcaTBBhPFmDsL8B4igDjqQKMpwkwDhBgPF2AcaAA4yABxsECjDkCjEMEGIcKMA4TYBwuwJgrwDhCgHGkAOMZAoyjBBjPFGAcLcB4lgDjGAHGswUYzxFgPFeAcawA43kCjOMEGM8XYBwvwDhBgHGiAOMFAowXCjBeJMA4SYDxYgHGyQKMlwgwThFgnCrAeKkA42UCjNMEGKcLMM4QYLxcgPEKAcYrBRhnCjBeJcA4S4DxagHG2QKM1wgwzhFgvFaAca4A43UCjNcLMN4gwHijAONNAow3CzDeIsA4T4DxVgHG2wQYbxdgvEOAcb4A4wIBxjsFGO8SYLxbgHGhAOMiAcbFAoz3CDDeK8B4nwDjEgHG+wUYlwowPiDA+KAA40MCjMsEGJcLMK4QYHxYgHGlAOMqAcbVAoxrBBjXCjCuE2B8RIDxUQHG9QKMGwQYNwowbhJgfEyA8XEBxs0CjFsEGLcKMD4hwPikAONTAozbBBifFmDcLsC4Q4BxpwDjMwKMuwQYnxVg3C3A+ByBkcFZ/gAOZwaS0w2zf87nP/dfMv/74ZWC78GnVPApHXzKBJ8jgk/Z4HNk8CkXfMoHnwrBp2LwqRR8KgefKsGnaqW8MapVyh+0eP5/bdBYgZ+VTPKzUkl+VjrJz8ok+dkRSX5WNsnPjkzys3JJflY+yc8qJPlZxSQ/q5TkZ5WT/KxKkp9VTfKzavk/C4MVnwSNs5s1aZLbvFGua+yGZDdqObRF0+wmTYc2a+FauKYtmg5v1KJx49wWTVo0bzm0ZfPslq5J41w3omnLxrkj7Mp2LwcDzjs4I6MYNLmys23cVBlH5A8Xq4QrqPh5jcXNazHQvIbMrwS/4LaDcePZWMZbHBmnIFKv7IMbKz5Oqd5vdVLMqxNrKYw5NEYuL5dQYyFjVIMUoxrEunw1+AV3AOvSxqpBqMtXgXVZAxjzTFLMM+NiHl7FwbGfB9Zj1FhZuDltHD9/6NpB1k1N3D27jAy8ibeYGCOqR4T3XYtUP7UKcf3Uxs1po2S5lKovCHsO2he8CvQFyB5Rh5TjdYi+4LXgFywA5qSNVYfgC14D+oI6wJgfRYr5Uf+LX89O7XJWk7UJGj9+EHYDSKW3TQDfd3ih+9jRQO8BjLUDzp+Lnz+0ViJ1sq7nPtBypS6hVuqR9LJeGnxg/ejXT3ayuslO7XLmnytXwPpx21tHcx4O9AUNKnF6AlrTkGubhmRNQ3ndwuJNsyv5rQtWIw0rYfMvu9J/awV579D+6vLqLpvQXx2pvzriGvT14BfcBdQhG8sR1qCvA+vcAfO+ESnmjYhrUNPh+oT8v8TzNSjLV08RWYM2BnoEYKzdFJE1KFInm3i+BrVcaUKolaYkvWyahjVos+jXT1LdTfVZROgx0M8iYJ7AJXq3VPOkOSnHmxN94BvBL1gI1DcbqznBB74B9IHNgTFvQYp5C6IPtJpsRtD4aZ77QFZvmy7iA1sC+xgw1m66iA9E6mQrz32g5UorQq20Jull6zT4wGOiXz8UHxh6DLQPfAPoA5GeoA0px9sQfeCbwS9YDNQ3G6sNwQe+CfSBbYAxb0uKeVuiD7SaPIag8Vd67gNZvW2miA9sB+xjwFi7mSI+EKmTx3ruA/fkCqFW2pP0sn0afGCH6NcPxQeGHgPtA98E+kCkJ+hIyvGORB/4VvAL7gXqm43VkeAD3wL6wI7AmHcixbwT0QdaTXYgaPxsz30gq7ddI+IDOwP7GDDW7hoRH4jUyS6e+0DLlS6EWulK0suuafCBx0W/fmjvJjcHv5tckvBuckmgL+jm+XuhNoctwDEpRYhJKWBMjheISUtwTEoTYlIaGJPuAjFpBY5JGUJMygBj0kMgJq3BMTmCEJMjgDHpKRCTY8AxKUuISVlgTE4QiEkbcEyOJMTkSGBMegnEpC04JuUIMSkHjElvgZi0A8ekPCEm5YEx6SMQk2PBMalAiEkFYEz6CsSkPTgmFQkxqQiMST+BmHQAx6QSISaVgDE5USAmHcExqUyISWVgTE4SiEkncEyqEGJSBRiTkwVi0hkck6qEmFQFxqQ/MCb2fKNyxn//wLad9bd9Z9vntH0128exfQNbp9q6yHy4+T7zGdbXTEetbi1P+sed6Uc/S7K/GdCQ8CzpFOBcFsufy4IXanzW3J5SyX/GU9GM6EQKX4IpLC+tnOZ5YzCxOBV4vzbeaZU4Rc34oyWnEcRyAOnB+wDiy2lvB79gCfClCxtrAOHltLeBdT4AmPenk2J+OvHlNNPh4wj5/7DnL6exXrhZKfJy2kDgyzXAWLuVIi+nIXVykOcvp1muDCLUymCSXg5Ow8tpOdGvH8ohhdBjoA8pwDyBS/RuqebJEFKODyH6wHeCX7AUqG821hCCD3wH6AOHAGM+lBTzoUQfaDWZQ9D4tZ77QFZvWyfiA4cB+xgw1m6diA9E6uRwz32g5cpwQq3kkvQyNw0+cET064fiA0OPgfaB7wB9INITjCTl+EiiD3w3+AUPAvXNxhpJ8IHvAn3gSGDMzyDF/AyiD7SaHEHQ+A2e+0BWb9so4gNHAfsYMNZuo4gPROrkmZ77QMuVMwm1Mpqkl6PT4APPin79UHxg6DHQPvBdoA9EeoIxpBwfQ/SB7wW/YBlQ32ysMQQf+B7QB44BxvxsUszPJvpAq8mzCBq/2XMfyOptW0R84DnAPgaMtdsi4gOROnmu5z7QcuVcQq2MJenl2DT4wPOiXz8U3Q1fWi5GGBcV262ez6G9y5hsDlO973HAnPZ9Dm3+xhE07fyil+cdcg5YjON9f3k+XIwVlsXTBIGX58eDX56foPDyPLHhTPSz4VBMtM3fRELDuYBkoi8gbjqw8unCwmJg8g+0TCDk00WkfLqIuHH5fvALVgAX5DbWRYSNy/eBvfciYC+aRIr5JKKGmDc6j5D/2z1fuLA2Y3aIbFxeDNR4YKzdDpGNS6ROTvZ849JyZTKhVi4h6eUladi4nBL9+qE8wA49BvoBNswTuETvlmqeTCXl+FSiD/wg+AUrgfpmY00l+MAPgD5wKjDml5JifinRB1pNTiFo/LOe+0BWb9st4gMvA/YxYKzdbhEfiNTJaZ77QMuVaYRamU7Sy+lp8IEzol8/FB8Yegy0D/wA6AORnuByUo5fTvSBHwa/YDVQ32ysywk+8EOgD7wcGPMrSDG/gugDrSZnEDT+Rc99IKu3vSTiA68E9jFgrN1LIj4QqZMzPfeBliszCbVyFUkvr0qDD5wV/fqh+MDQY6B94IdAH4j0BFeTcvxqog/8KPgFa4H6ZmNdTfCBHwF94NXAmM8mxXw20QdaTc4iaPxrnvtAVm97XcQHXgPsY8BYu9dFfCBSJ+d47gMtV+YQauVakl5emwYfODf69UN7N/ZCQi69IXCAgvE+65si/eY6YL0AY+3eFMib6wh5c33RwRuHnAMW4w2+H7wJF42FZZF3o8DBmxvAB29uJB28CS90s7kp+s2GdujmJkKzuZlk9G9Og9G/pci47AVd3oGbGwm5NI+US/OIG6sfB7/gEeCGgY01j7Cx+jGw584D9qBbSTG/lbixap5oLiH/3/d8wcLaLPpAZKF7G7BfAGPtPhDZWEXq5O2eb6xartxOqJU7SHp5Rxr81vzo1w/lAXvoMdAP2GGewCV6t1TzZAEpxxcQfeAnwS9YD9Q3G2sBwQd+AvSBC4Axv5MU8zuJPtBqcj5B4z/x3AeyetunIj7wLmAfA8bafSriA5E6ebfnPtBy5W5CrSwk6eXCNPjARdGvH4oPDD0G2gd+AvSBSE+wmJTji4k+8NPgF2wE6puNtZjgAz8F+sDFwJjfQ4r5PUQfaDW5iKDxX3ruA1m97SsRH3gvsI8BY+2+EvGBSJ28z3MfaLlyH6FWlpD0ckkafOD90a8fig8MPQbaB34K9IFIT7CUlONLiT7ws+AXPAbUNxtrKcEHfgb0gUuBMX+AFPMHiD7QavJ+gsZ/57kPZPW270V84IPAPgaMtftexAcidfIhz32g5cpDhFpZRtLLZWnwgcujXz+0Aze3EHLpB4GDE4x3WX8U6TcrgPUCjLX7USBvVhDy5uGiAzcOOQcsxpW+H7gJF42FZZG3SuDAzUrwgZtVYgduVke/2dAO3KwmNJs1JKO/Jg1Gf22RcdkLurwDN6sIubSOlEvriBurnwe/YDNww8DGWkfYWP0c2HPXAXvQI6SYP0LcWDVPtJyQ/797vmBhbRb9IbLQfRTYL4Cxdn+IbKwidXK95xurlivrCbWygaSXG9LgtzZGv34oD9hDj4F+wA7zBC7Ru6WaJ5tIOb6J6AO/CH7BVqC+2VibCD7wC6AP3ASM+WOkmD9G9IFWkxsJGv+P5z6Q1dv+FfGBjwP7GDDW7l8RH4jUyc2e+0DLlc2EWtlC0sstafCBW6NfPxQfGHoMtA/8AugDkZ7gCVKOP0H0gV8Gv+BJoL7ZWE8QfOCXQB/4BDDmT5Ji/iTRB1pNbiVofPHBfvtAVm/bF3zf4YXuY08B+xgw1g44f1QfiNTJbZ77QMuVbYRaeZqkl0+nwQduj379UHxg6DHQPvBLoA9EeoIdpBzfQfSBXwW/YBtS3w7O40X7wK+APnAHMOY7STHfSfSBVpPbCRp/oOc+kNXbDhLxgc8A+xgw1u4gER+I1MldnvtAy5VdhFp5lqSXz6bBB+6Ofv3QDtysJeTSwZ7fN+td1hIi/eY5YL0AY+1KCOTNc4S8eb7owI1DzgGL8QXfD9yEi8bCssh7UeDAzQvgAzcvih24eSn6zYZ24OYlQrN5mWT0X06D0X+lyLjsBV3egZsXCbn0KimXXiVurH4d/ILtwA0DG+tVwsbq18Ce+yqwB71GivlrxI1V80S7CflfyvMFC2uzqLTIQvd1YL8AxtqVFtlYRerkG55vrFquvEGolTdJevlmGvzWW9GvH8oD9tBjoB+wwzyBS/RuqebJ26Qcf5voA78JfsFOoL7ZWG8TfOA3QB/4NjDm75Bi/g7RB1pNvkXQ+CM994Gs3lZOxAe+C+xjwFi7ciI+EKmT73nuAy1X3iPUyvskvXw/DT7wg+jXD8UHhh4D7QO/AfpApCf4kJTjHxJ94LfBL9iFfIHo4DxetA/8FugDPwTG/CNSzD8i+kCryQ8IGl/Jcx/I6m2VRXzgx8A+Boy1qyziA5E6+YnnPtBy5RNCrXxK0stP0+ADP4t+/VB8YOgx0D7wW6APRHqCz0k5/jnRB34X/ILdQH2zsT4n+MDvgD7wc2DMvyDF/AuiD7Sa/Iyg8THPfSCrt1UX8YFfAvsYMNauuogPROrkV577QMuVrwi18jVJL79Ogw/8Jvr1Qztw8wohl2oIHJxgvMuaKdJvvgXWCzDWLlMgb74l5M13RQduHHIOWIzf+37gJlw0FpZF3g8CB26+Bx+4+UHswM2P0W82tAM3PxKazU8ko/9TGoz+z0XGZS/o8g7c/EDIpV9IufQLcWP1++AXPA/cMLCxfiFsrH4P7Lm/AHvQr6SY/0rcWDVP9A0h/4/yfMHC2iw6WmSh+xuwXwBj7Y4W2VhF6uTvnm+sWq78TqiVP0h6+Uca/Naf0a8fygP20GOgH7DDPIFL9G6p5slfpBz/i+gDfwh+wYtAfbOx/iL4wB+APvAvYMz/JsX8b6IPtJr8k6DxDTz3gaze1lDEB/4D7GPAWLuGIj4QqZP/eu4DLVf+JdSKPZUBMSbopY0by0i80PWzT+XI1w/FB4YeA+0DfwD6QKQnKEbK8WKVeT7wx+AXvAzUNxvLeNE+8EegD4yPU8r/qgsp5sUr83yg1aRpGlrjG3vuA1m9rYmID9wX2MeAsXZNRHwgUif3q4y9Z3StWK7sR9CI/Ul6uX8afOAB0a8fig8MPQbaB/4I9IFIT3AgKccPJPrAn4Jf8CpQ32ysAwk+8CegDzwQGPODSDE/iOgDrSYPIGh8C899IKu3tRTxgQcD+xgw1q6liA9E6mQJz32g5UoJQq0cQtLLQ9LgAw+Nfv3QDtz8TFh/txI4OMF4l7W1SL85DFgvwFi71gJ5cxhBew8Haq/1VsUDN8g5YDGWRDPCX6bPXzQWlkVeKXBAioHnzQSjJPB+bbxSlXlFbRe62ZSOfrOhHbgpTWg2ZUhGv0wajP4RRcZlL+jyDtyUIuRSWVIulSVurP4c/ILXgRsGNlZZwsbqz8CeWxbYg44kxfxI4saqeaJDCfnf3vMFC2uzqIPIQrccsF8AY+06iGysInWyvOcbq5Yr5Qm1UoGklxXS4LcqRr9+KA/YQ4+BfsAO8wQu0bul/JedSTleiegDfwl+wZtAfbOxKhF84C9AH1gJGPPKpJhXJvpAq8mKBI3v4rkPZPW2riI+sAqwjwFj7bqK+ECkTlb13AdarlQl1Eo1kl5WS4MPjEW/fig+MPQYaB/4C9AHIj1BdVKOVyf6wF+DX/A2UN9srOoEH/gr0AdWB8a8BinmNYg+0GoyRtD47p77QFZv6yHiAzOBfQwYa9dDxAcidTLLcx9ouZJFqJWaJL2smQYfWCv69UPxgaHHQPvAX4E+EOkJapNyvDbRB/4W/IJ3gfpmY9Um+MDfgD6wNjDmdUgxr0P0gVaTtQga39tzH8jqbX1EfOBRwD4GjLXrI+IDkTp5tOc+0HLlaEKt1CXpZd00+MB60a8f2oGbIwi51Ffg4ATjXdZ+Iv2mPrBegLF2/QTypj4hbxoUHbhxyDlgMTb0/cBNuGgsLIu8bIEDNw3BB26yxQ7cuOg3G9qBG0doNo1IRr9RGox+4yLjshd0eQdusgm51ISUS02IG6u/B7/gfeCGgY3VhLCx+juw5zYB9qCmpJg3JW6smieqR8j/Uz1fsLA2i04TWeg2A/YLYKzdaSIbq0idbO75xqrlSnPGXzsj6WWLNPitltGvH8oD9tBjoB+wwzyBS/RuKf+FJVKOtyL6wD+CX/AhUN9srFYEH/gH0Ae2Asa8NSnmrYk+0GqyJUHjB3nuA1m9bbCIDzwG2MeAsXaDRXwgUifbeO4DLVfaEGqlLUkv26bBB7aLfv1QfGDoMdA+8A+gD0R6gmNJOX4s0Qf+GfyCj4H6tmcsgg/8E+gDjwXGvD0p5u2JPtBqsh1B44d57gNZvW24iA/sAOxjwFi74SI+EKmTHT33gZYrHQm10omkl53S4AM7R79+KD4w9BhoH/gn0AciPUEXUo53IfrAv4Jf8ClQ32ysLgQf+BfQB3YBxrwrKeZdiT7QarIzQePP8NwHsnrbKBEfeBywjwFj7UaJ+ECkTnbz3AdarnQj1MrxJL08Pg0+sHv064d24KYxIZfOFDg4wXiXdbRIv+kBrBdgrN1ogbzpQcibnkUHbhxyDliMJ/h+4CZcNBaWRV4vgQM3J4AP3PQSO3DTO/rNhnbgpjfjr1CQjH6fNBj9vkXGZS/o8g7c9GKcMCflUj/ixurfwS/4HLhhYGP1I2ys/g3suf2APehEUsxPJG6smifqTsj/sZ4vWFibReeJLHRPAvYLYKzdeSIbq0idPNnzjVXLlZMJtdKfpJf90+C3Tol+/VAesIceA/2AHeYJXKJ3S/ngKSnHTyX6wH+CX/AlUN9srFMJPvAfoA88FRjz00gxP43oA60mTyFo/ATPfSCrt00U8YEDgH0MGGs3UcQHInXydM99oOXK6YRaGUjSy4Fp8IGDol8/FB8Yegy0D/wH6AORnmAwKccHE33gv8Ev+BqobzbWYIIP/BfoAwcDY55DinkO0QdaTQ4iaPwkz30gq7ddLOIDhwD7GDDW7mIRH4jUyaGe+0DLlaGMQ3kkvRyWBh84PPr1Q/GBocdA+8B/gT4Q6QlySTmeS/SBNuC3QH2zsXIJPtA4UWPlAmM+ghTzEUQfaDU5nKDxUz33gazedqmIDxwJ7GPAWLtLRXwgUifP8NwHWq6cwTicRtLLUWnwgWdGv35oB276EnLpMoGDE4x3WaeJ9JvRwHoBxtpNE8ib0YS8OavowI1DzgGLcYzvB27CRWNhWeSdLXDgZgz4wM3ZYgduzol+s6EduDmH0GzOJRn9c9Ng9McWGZe9oMs7cHM248V7Ui6dR9xY3ScY8HvghoGNdR5hY3UfYM89D9iDxpFiPo64sWqe6ExC/s/0fMHC2iy6SmShez6wXwBj7a4S2VhF6uR4zzdWLVfGM17GJunlhDT4rYnRrx/KA/bQY6AfsMM8gUv0bqnmyQWkHL+A6AOLBQP+CNQ3G+sCgg8sBvSBFwBjfiEp5hcSfaDV5ESCxl/juQ9k9bY5Ij7wImAfA8bazRHxgUidnOS5D7RcmcR4KZmklxenwQdOjn79UHxg6DHQPhDmCVyid0s1Ty4h5fglRB9YPBjwZ6C+2ViXEHxgcaAPvAQY8ymkmE8h+kCryckEjb/ecx/I6m03iPjAqcA+Boy1u0HEByJ18lLPfaDlyqWMl+NIenlZGnzgtOjXD8UHhh4D7QNhnsAlerdU82Q6KcenE33gvsGAvwL1zcaaTvCB+wJ94HRgzGeQYj6D6AOtJqcRNP4Wz30gq7fNE/GBlwP7GDDWbp6ID0Tq5BWe+0DLlSsItXIlSS+vTIMPnBn9+qEduBlLyKVbBQ5OMN5lvU2k31wFrBdgrN1tAnlzFSFvZhUduHHIOWAxXu37gZtw0VhYFnmzBQ7cXA0+cDNb7MDNNdFvNrQDN9cwXpIhGf05aTD61xYZl72gyztwM5uQS3NJuTSXuLG6XzDg78ANAxtrLmFjdT9gz50L7EHXkWJ+HXFj1TzRTEL+3+X5goW1WXS3yEL3emC/AMba3S2ysYrUyRs831i1XLmBUCs3kvTyxjT4rZuiXz+UB+yhx0A/YId5Apfo3VLNk5tJOX4z0QfuHwz4J1DfbKybCT5wf6APvBkY81tIMb+F6AOtJm8iaPw9nvtAVm+7V8QHzgP2MWCs3b0iPhCpk7d67gMtV25lPBwk6eVtafCBt0e/fig+MPQYaB8I8wQu0bulmid3kHL8DqIPPCAY8G+gvtlYdxB84AFAH3gHMObzSTGfT/SBVpO3EzR+qe8v/JB62wMiPnABsI8BY+0eEPGBSJ2803MfaLlyJ+OZAUkv70qDD7w7+vVD8YGhx0D7QJgncIneLdU8WUjK8YVEH3hgMOC/QH2zsRYSfOCBQB+4EBjzRaSYLyL6QKvJuwkav9xzH8jqbStEfOBiYB8DxtqtEPGBSJ28x3MfaLlyD2PvnKSX96bBB94X/fqhHbi5lpBLDwscnGC8y7pSpN8sAdYLMNZupUDeLCHkzf1FB24ccg5YjEt9P3ATLhoLyyLvAYEDN0vBB24eEDtw82D0mw3twM2DhGbzEMnoP5QGo7+syLjsBV3egZsHGBtLpFxaTtxYPSgYcJ8SuPFsrOWEjdWDgD13ObAHrSDFfAVxY9U80X2E/H/E8wULa7PoUZGF7sPAfgGMtXtUZGMVqZMrPd9YtVxZSaiVVSS9XJUGv7U6+vVDecAeegz0A3aYJ3CJ3i3VPFlDyvE1RB94cDBgcaC+2VhrCD7wYKAPXAOM+VpSzNcSfaDV5GqCxm/y3AeyettjIj5wHbCPAWPtHhPxgUidfMRzH2i58ghjzUTSy0fT4APXR79+KD4w9BhoHwjzBC7Ru6WaJxtIOb6B6ANLBAPuB9Q3G2sDwQeWAPrADcCYbyTFfCPRB1pNrido/FbPfSCrtz0h4gM3AfsYMNbuCREfiNTJxzz3gZYrjxFq5XGSXj6eBh+4Ofr1Q/GBocdA+0CYJ3CJ3i3VPNlCyvEtRB94SDDgAUB9s7G2EHzgIUAfuAUY862kmG8l+kCryc0EjX/acx/I6m3bRXzgE8A+Boy12y7iA5E6+aTnPtBy5UlCrTxF0sun0uADt0W/fmgHbpYRcmmHwMEJxrusO0X6zdPAegHG2u0UyJunGT6l6MCNQ84Bi3GH7wduwkVjYVnk7RQ4cLMDfOBmp9iBm2ei32xoB26eITSbXSSjvysNRv/ZIuOyF3R5B252EnJpNymXdhM3Vg8NBjwIuGFgY+0mbKweCuy5u4E96DlSzJ8jbqyaJ9pGyP/nPV+wsDaLXhBZ6D4P7BfAWLsXRDZWkTr5gucbq5YrLxBq5UWSXr6YBr/1UvTrh/KAPfQY6AfsME/gEr1bqnnyMinHXyb6wMOCAUsA9c3GepngAw8D+sCXgTF/hRTzV4g+0GryJYLGv+K5D2T1tldFfOCrwD4GjLV7VcQHInXyNc99oOXKa4RaeZ2kl6+nwQe+Ef36ofjA0GOgfSDME7hE75ZqnrxJyvE3iT7w8GDAQ4H6ZmO9SfCBhwN94JvAmL9FivlbRB9oNfkGQePf9NwHsnrbWyI+8G1gHwPG2r0l4gOROvmO5z7QcuUdQq28S9LLd9PgA9+Lfv1QfGDoMdA+EOYJXKJ3SzVP3ifl+PtEH1gyGPBwoL7ZWO8TfGBJoA98HxjzD0gx/4DoA60m3yNo/Hue+0BWb3tfxAd+COxjwFi790V8IFInP/LcB1qufESolY9JevlxGnzgJ9GvH9qBm2cJufSBwMEJxrusH4r0m0+B9QKMtftQIG8+JeTNZ0UHbhxyDliMn/t+4CZcNBaWRd4XAgduPgcfuPlC7MDNl9FvNrQDN18Sms1XJKP/VRqM/tdFxmUv6PIO3HxByKVvSLn0DXFjtVQwYCnghoGN9Q1hY7UUsOd+A+xB35Ji/i1xY9U80SeE/P/c8wULa7PoC5GF7nfAfgGMtftCZGMVqZPfe76xarnyPaFWfiDp5Q9p8Fs/Rr9+KA/YQ4+BfsAO8wQu0bulmic/kXL8J6IPLB0MWAaobzbWTwQfWBroA38CxvxnUsx/JvpAq8kfGesgz30gq7d9K+IDfwH2MWCs3bciPhCpk7967gMtV34l1MpvJL38LQ0+8Pfo1w/FB4YeA+0DYZ7AJXq3VPPkD1KO/0H0gWWCAcsC9c3G+oPgA8sAfeAfwJj/SYr5n0QfaDX5O0Hjf/TcB7J6208iPvAvYB8Dxtr9JOIDkTr5t+c+0HLlb0Kt/EPSy3/S4AP/jX79UHxg6DHQPhDmCVyid0s1TzKqcHLcxo3lj4vWtiOCAcsB9c3GMl60DzwC6APj45Tq/e5Divk+VXg+0GryX8Za33MfyOptv4v4wGK4XHXAWLvfRXwgUieLV8HeM7pWLFeMEV0r+5L0ct8qfB+4X/Trh/I+sL2Hh3yHkfWO6P5V/O5fdt/7E2ryAOB9W+4oHsQ4oIr/jAeiGdGJFC4mCov5P6iK38JrgnEg8H5tPLtnRlGj793yENmwWYboYILw2IU2PyWAc3naINxYAwb53bTN/JQg5E1Gjv9m5WDCfe+To1EvhyAXeLh7dvHzl9oG7zC3bzDG/nG5E3+h8+kQ8MIxvA6tQgQ+tAp+3MOADZ1134eJmIS/KwaslXDj7ReMdWglvOgd7rnR/Ac8j/uT5rGk5/P4L3geDyDNYynP5zGjEnYeDyTNY2nP53Ef8DweRJrHMp7PYzHwPB5MmscjPJ/H4uB5LEGax7Kez+O+4Hk8hDSPR4JNf5mMPMYGlfKeFtn3bnHfj4/73j3ue4+47z3jvp8Q971X3Pfecd/7xH3vG/e9X9z3E+O+nxT3/eS47/3jvh9e5b/fS8Z9LxX3vXTc9zJx34+I+1427vuR+d/LBf8tH3wqBJ+KwadS8KkcfKoEn6r5vp6xWXAYYbOgGvmJDmJDlXHfMeDmw7759x1ukNj3DaEgZXDyoWwGNm4MxiMFGMsJMJYXYKwgwFhRgLGSAGNlAcYqAoxVBRirCTDGBBirCzDWEGDMFGDMEmCsKcBYS4CxtgBjHQHGowQYjxZgrCvAWE+Asb4AYwMBxoYCjNkCjE6AsZEAY2MBxiYCjE0FGJsJMDYXYGwhwNhSgLGVAGNrAcZjBBjbCDC2FWBsJ8B4rABjewHGDgKMHQUYOwkwdhZg7CLA2FWA8TgBxm4CjMcLMHYXYOwhwNhTgPEEAcZeAoy9BRj7CDD2FWDsJ8B4ogDjSQKMJwsw9hdgPEWA8VQBxtMEGAcIMJ4uwDhQgHGQAONgAcYcAcYhAoxDBRiHCTAOF2DMFWAcIcA4UoDxDAHGUQKMZwowjhZgPEuAcYwA49kCjOcIMJ4rwDhWgPE8AcZxAoznCzCOF2CcIMA4UYDxAgHGCwUYLxJgnCTAeLEA42QBxksEGKcIME4VYLxUgPEyAcZpAozTBRhnCDBeLsB4hQDjlQKMMwUYrxJgnCXAeLUA42wBxmsEGOcIMF4rwDhXgPE6AcbrBRhvEGC8UYDxJgHGmwUYbxFgnCfAeKsA420CjLcLMN4hwDhfgHGBAOOdAox3CTDeLcC4UIBxkQDjYgHGewQY7xVgvE+AcYkA4/0CjEsFGB8QYHxQgPEhAcZlAozLBRhXCDA+LMC4UoBxlQDjagHGNQKMawUY1wkwPiLA+KgA43oBxg0CjBsFGDcJMD4mwPi4AONmAcYtAoxbBRifEGB8UoDxKQHGbQKMTwswbhdg3CHAuFOA8RkBxl0CjM8KMO4WYHxOgPF5AcYXBBhfFGB8SYDxZQHGVwQYXxVgfE2A8XUBxjcEGN8UYHxLgPFtAcZ3BBjfFWB8T4DxfQHGDwQYPxRg/EiA8WMBxk8EGD8VYPxMgPFzAcYvBBi/FGD8SoDxawHGbwQYvxVg/E6A8XsBxh8EGH8UYPxJgPFnAcZfBBh/FWD8TYDxdwHGPwQY/xRg/EuA8W8Bxn8EGP8VYLQBfWfcR4CxmABjcQHGfQUY9xNg3F+A8QABxgMFGA8SYDxYgLGEAOMhAoyHCjAeJsB4uABjSQHGUgKMpQUYywgwHiHAWFaA8UgBxnICjOUFGCsIMFYUYKwkwFhZgLGKAGNVAcZqAowxAcbqAow1BBgzBRizBBhrCjDWEmCsLcBYR4DxKAHGowUY6wow1hNgrC/A2ECAsaEAY7YAoxNgbCTA2FiAsYkAY1MBxmYCjM0FGFsIMLYUYGwlwNhagPEYAcY2AoxtBRjbCTAeK8DYXoCxgwBjRwHGTgKMnQUYuwgwdhVgPE6AsZsA4/ECjN0FGHsIMPYUYDxBgLGXAGNvAcY+Aox9BRj7CTCeKMB4kgDjyQKM/QUYTxFgPFWA8TQBxgECjKcLMA4UYBwkwDhYgDFHgHGIAONQAcZhAozDBRhzBRhHCDCOFGA8Q4BxlADjmQKMowUYzxJgHCPAeLYA4zkCjOcKMI4VYDxPgHGcAOP5AozjBRgnCDBOFGC8QIDxQgHGiwQYJwkwXizAOFmA8RIBxikCjFMFGC8VYLxMgHGaAON0AcYZAoyXCzBeIcB4pQDjTAHGqwQYZwkwXi3AOFuA8RoBxjkCjNcKMM4VYLxOgPF6AcYbBBhvFGC8SYDxZgHGWwQY5wkw3irAeJsA4+0CjHcIMM4XYFwgwHinAONdAox3CzAuFGBcJMC4WIDxHgHGewUY7xNgXCLAeL8A41IBxgcEGB8UYHxIgHGZAONyAcYVAowPCzCuFGBcJcC4WoBxjQDjWgHGdQKMjwgwPirAuF6AcYMA40YBxk0CjI8JMD4uwLhZgHGLAONWAcYnBBifFGB8SoBxmwDj0wKM2wUYdwgw7hRgfEaAcZcA47MCjLsFGJ8TYHxegPEFAcYXBRhfEmB8WYDxFQHGVwUYXxNgfF2A8Q0BxjcFGN8SYHxbgPEdAcZ3BRjfE2B8X4DxAwHGDwUYPxJg/FiA8RMBxk8FGD8TYPxcgPELAcYvBRi/EmD8WoDxGwHGbwUYvxNg/F6A8QcBxh8FGH8SYPxZgPEXAcZfBRh/E2D8XYDxDwHGPwUY/xJg/FuA8R8Bxn8FGDOK+c+4jwBjMQHG4gKM+wow7ifAuL8A4wECjAcKMB4kwHiwAGMJAcZDBBgPFWA8TIDxcAHGkgKMpQQYSwswlhFgPEKAsawA45ECjOUEGMsLMFYQYKwowFhJgLGyAGMVAcaqAozVBBhjAozVBRhrCDBmCjBmCTDWFGCsJcBYW4CxjgDjUQKMRwsw1hVgrCfAWF+AsYEAY0MBxmwBRifA2EiAsbEAYxMBxqYCjM0EGJsLMLYQYGwpwNhKgLG1AOMxAoxtBBjbCjC2E2A8VoCxvQBjBwHGjgKMnQQYOwswdhFg7CrAeJwAYzcBxuMFGLsLMPYQYOwpwHiCAGMvAcbeAox9BBj7CjD2E2A8UYDxJAHGkwUY+wswniLAeKoA42kCjAMEGE8XYBwowDhIgHGwAGOOAOMQAcahAozDBBiHCzDmCjCOEGAcKcB4hgDjKAHGMwUYRwswniXAOEaA8WwBxnMEGM8VYBwrwHieAOM4AcbzBRjHCzBOEGCcKMB4gQDjhQKMFwkwThJgvFiAcbIA4yUCjFMEGKcKMF4qwHiZAOM0AcbpAowzBBgvF2C8QoDxSgHGmQKMVwkwzhJgvFqAcbYA4zUCjHMEGK8VYJwrwHidAOP1Aow3CDDeKMB4kwDjzQKMtwgwzhNgvFWA8TYBxtsFGO8QYJwvwLhAgPFOAca7BBjvFmBcKMC4SIBxsQDjPQKM9wow3ifAuESA8X4BxqUCjA8IMD4owPiQAOMyAcblAowrBBgfFmBcKcC4SoBxtQDjGgHGtQKM6wQYHxFgfFSAcb0A4wYBxo0CjJsEGB8TYHxcgHGzAOMWAcatAoxPCDA+KcD4lADjNgHGpwUYtwsw7hBg3CnA+IwA4y4BxmcFGHcLMD5HYGRwlj+Aw5mB5GyUbf+cz3/uv2T+9+pVMjJqBJ/M4JMVfGoGn1rBp3bwqRN8jgo+RwefusGnXvCpH3waBJ+GwSe7St4Yrkr+oMXz/2uDxgr8rEaSn2Um+VlWkp/VTPKzWkl+VjvJz+ok+dlRSX52dJKf1U3ys3pJflY/yc8aJPlZwyQ/y07yM5f/szBY8UnQOLtZkya5zRvlusZuSHajlkNbNM1u0nRosxauhWvaounwRi0aN85t0aRF85ZDWzbPbumaNM51I5q2bJw7wq68fyC7QomMjGLI5HLZ2fH/8PbeMo4Ic7UKrqDi57VR3LwWA81ryGz/qHelErjxbCzjLY6MUzb0Hx938XFK9X4bk2LemFhLYcyhMXJ5uYQaCxmjJqQYNSHWpf1D9lWAdWljNSHUZTlgXTYBxrwpKeZN42IeXsXBsa8A1mPUWM1wc9o4fv7QtYOsm+a4e3YZGXgTbzExRlSPCO+7Bal+WhTi+mmJm9NGyXIpVV8Q9hy0LygH9AXIHtGKlOOtiL6gfDBgNWBO2litCL6gPNAXtALGvDUp5q3/F7+endrlrCZbEjS+Ug52A0ilt1UG33d4ofvYMUDvAYy1A86fi58/tFYidbKN5z7QcqUNoVbakvSybRp8YLvo1092srrJTu1y5p8bVML6cdtbR3NWB/qCY6twegJa05Brm/ZkTUN53cLiTTtU8VsXrEbaV8HmX4cq/60V5L1D+6vLq7sOhP7akdRfOxLXoBWCAasDdcjG6khYg1YA1nlHYN53IsW8E3ENajrcjpD/WTl+r0FZvrpmDsdvoD10Z6BHAMbaAeePugZF6mQXz9eglitdCLXSlaSXXdOwBj0u+vWTVHdTfRYRegz0swiYJ3CJ3i3VPOlGyvFuRB9YMRgwE6hvNlY3gg+sCPSB3YAxP54U8+OJPtBq8jiCxh+V47cPZPW2o8H3HV7oPtYd2MeAsXbA+aP6QKRO9vDcB1qu9CDUSk+SXvZMgw88Ifr1Q/GBocdA+0CYJ3CJ3i3VPOlFyvFeRB9YKRiwJlDfbKxeBB9YCegDewFj3psU895EH2g1eQJB4xvk+O0DWb2tIfi+wwvdx/oA+xgw1g44f1QfiNTJvp77QMuVvoRa6UfSy35p8IEnRr9+KD4w9BhoHwjzBC7Ru6WaJyeRcvwkog+sHAxYG6hvNtZJBB9YGegDTwLG/GRSzE8m+kCryRMJGt84x28fyOptTcD3HV7oPtYf2MeAsXbA+aP6QKROnuK5D7RcOYVQK6eS9PLUNPjA06JfP7R3k7uB302uQXg3uQbQFwzw/L1Qm8PjwTHJJMQkExiT0wVi0h0ckyxCTLKAMRkoEJMe4JjUJMSkJjAmgwRi0hMck1qEmNQCxmSwQExOAMekNiEmtYExyRGISS9wTOoQYlIHGJMhAjHpDY7JUYSYHAWMyVCBmPQBx+RoQkyOBsZkmEBM+oJjUpcQk7rAmAwXiEk/cEzqEWJSDxiTXIGYnAiOSX1CTOoDYzJCICYngWPSgBCTBsCYjBSIycngmDQkxKQhMCZnCMSkPzgm2YSYZANjMgoYE3u+US3jv39g2876276z7XPavprt49i+ga1TbV1kPtx8n/kM62umo1a3liej4s70o58l2d8MaE94lnQmcC6L5c9lwQs1Pmtuz6ziP+NoNCP8j4sVy3sJprC8tHKW543BxGI08H5tvLOqcIqa8UdLziKI5RjSg/cxxJfTqgQDHgV86cLGGkN4Oa0KsM7HAPP+bFLMzya+nGY6fBoh/0/J8bjumS/c5OANQkYG/uWac4Av1wBj7YDzR305DamT53r+cprlyrmEWhlL0suxaXg57bzo1w/lkELoMdCHFGCewCV6t1TzZBwpx8cRfWDVYMC6QH2zscYRfGBVoA8cB4z5+aSYn0/0gVaT5xE0fmCO3z6Q1dsGge87vNB9bDywjwFj7YDzR/WBSJ2c4LkPtFyZQKiViSS9nJgGH3hB9OuH4gNDj4H2gTBP4BK9W6p5ciEpxy8k+sBqwYD1gfpmY11I8IHVgD7wQmDMLyLF/CKiD7SavICg8UNz/PaBrN42DHzf4YXuY5OAfQwYawecP6oPROrkxZ77QMuViwm1Mpmkl5PT4AMviX79UHxg6DHQPhDmCVyid0s1T6aQcnwK0QfGggEbAvXNxppC8IExoA+cAoz5VFLMpxJ9oNXkJQSNH5njtw9k9bYzwPcdXug+dimwjwFj7YDzR/WBSJ28zHMfaLlyGaFWppH0cloafOD06NcPRXfDl5aLEcZFxXaU53No7zImm8NU73sGMKd9n0ObvxkETbu86OV5h5wDFuMVvr88Hy7GCsvi6UqBl+evAL88f6XCy/PEhjPTz4ZDMdE2fzMJDecqkom+irjpwMqnWYXFwOQfaLmSkE9Xk/LpauLGZfVgQAdckNtYVxM2LqsDe+/VwF40mxTz2UQNMW80nZD/5+T43YtZmzHngu87vNAbL9cANR4YawecP+rGJVIn53i+cWm5ModQK9eS9PLaNGxczo1+/VAeYIceA/0AG+YJXKJ3SzVPriPl+HVEH1gjGLAxUN9srOsIPrAG0AdeB4z59aSYX0/0gVaTcwkaf36O3z6Q1dvGg+87vNB97AZgHwPG2gHnj+oDkTp5o+c+0HLlRkKt3ETSy5vS4ANvjn79UHxg6DHQPhDmCVyid0s1T24h5fgtRB+YGQzYFKhvNtYtBB+YCfSBtwBjPo8U83lEH2g1eTNB4y/M8dsHsnrbReD7Di90H7sV2MeAsXbA+aP6QKRO3ua5D7RcuY1QK7eT9PL2NPjAO6JfPxQfGHoMtA+EeQKX6N1SzZP5pByfT/SBWcGAzYH6ZmPNJ/jALKAPnA+M+QJSzBcQfaDV5B0Ejb8kx28fyOptU8D3HV7oPnYnsI8BY+2A80f1gUidvMtzH2i5chehVu4m6eXdafCBC6NfP7R3Y2cRcmmq5/fNep/10hyNfrMIWC/AWDv0/DHyZhEhbxYXHbxxyDlgMd7j+8GbcNFYWBZ59wocvLkHfPDmXtLBm/BCN5v7ot9saIdu7iM0myUko78kDUb//iLjshd0eQdu7iXk0lJSLi0lbqzWDAZsCdwwsLGWEjZWawJ77lJgD3qAFPMHiBur5okWEvL/ihy/FyyszaIrczS8x4PAfgGMtQPOH3VjFamTD3m+sWq58hChVpaR9HJZGvzW8ujXD+UBe+gx0A/YYZ7AJXq3VPNkBSnHVxB9YK1gwNZAfbOxVhB8YC2gD1wBjPnDpJg/TPSBVpPLGX94IMdvH8jqbbPB9x1e6D62EtjHgLF2wPmj+kCkTq7y3Adarqwi1Mpqkl6uToMPXBP9+qH4wNBjoH0gzBO4RO+Wap6sJeX4WqIPrB0M2AaobzbWWoIPrA30gWuBMV9Hivk6og+0mlxD0Pi5OX77QFZvuw583+GF7mOPAPsYMNYOOH9UH4jUyUc994GWK48SamU9SS/Xp8EHboh+/VB8YOgx0D4Q5glcondLNU82knJ8I9EH1gkGbAfUNxtrI8EH1gH6wI3AmG8ixXwT0QdaTW5g/HGNHL99IKu33Qy+7/BC97HHgH0MGGsHnD+qD0Tq5OOe+0DLlccJtbKZpJeb0+ADt0S/fmgHbu4n5NItnt83613WeTka/WYrsF6AsXbo+WPkzVZC3jxRdODGIeeAxfik7wduwkVjYVnkPSVw4OZJ8IGbp8QO3GyLfrOhHbjZRmg2T5OM/tNpMPrbi4zLXtDlHbh5ipBLO0i5tIO4sXpUMGB74IaBjbWDsLF6FLDn7gD2oJ2kmO8kbqyaJ9pCyP8FOX4vWFibRXfmaHiPZ4D9AhhrB5w/6sYqUid3eb6xarmyi1Arz5L08tk0+K3d0a8fygP20GOgH7DDPIFL9G6p5slzpBx/jugDjw4G7AjUNxvrOYIPPBroA58Dxvx5UsyfJ/pAq8ndBI1flOO3D2T1tsXg+w4vdB97AdjHgLF2wPmj+kCkTr7ouQ+0XHmRUCsvkfTypTT4wJejXz8UHxh6DLQPhHkCl+jdUs2TV0g5/grRB9YNBuwM1Dcb6xWCD6wL9IGvAGP+KinmrxJ9oNXkywSNX5Ljtw9k9bb7wfcdXug+9hqwjwFj7YDzR/WBSJ183XMfaLnyOqFW3iDp5Rtp8IFvRr9+KD4w9BhoHwjzBC7Ru6WaJ2+Rcvwtog+sFwzYFahvNtZbBB9YD+gD3wLG/G1SzN8m+kCryTcJGv9Qjt8+kNXbloHvO7zQfewdYB8DxtoB54/qA5E6+a7nPtBy5V1CrbxH0sv30uAD349+/dAO3Gwn5NJyz++b9S7rihyNfvMBsF6AsXbo+WPkzQeEvPmw6MCNQ84Bi/Ej3w/chIvGwrLI+1jgwM1H4AM3H4sduPkk+s2GduDmE0Kz+ZRk9D9Ng9H/rMi47AVd3oGbjwm59Dkplz4nbqzWDwbsBtwwsLE+J2ys1gf23M+BPegLUsy/IG6smid6n5D/a3P8XrCwNovW5Wh4jy+B/QIYawecP+rGKlInv/J8Y9Vy5StCrXxN0suv0+C3vol+/VAesIceA/2AHeYJXKJ3SzVPviXl+LdEH9ggGLA7UN9srG8JPrAB0Ad+C4z5d6SYf0f0gVaT3xA0fkOO3z6Q1ds2gu87vNB97HtgHwPG2gHnj+oDkTr5g+c+0HLlB0Kt/EjSyx/T4AN/in79UHxg6DHQPhDmCVyid0s1T34m5fjPRB/YMBiwJ1DfbKyfCT6wIdAH/gyM+S+kmP9C9IFWkz8RNH5zjt8+kNXbtoDvO7zQfexXYB8DxtoB54/qA5E6+ZvnPtBy5TdCrfxO0svf0+AD/4h+/VB8YOgx0D4Q5glcondLNU/+JOX4n0QfaG/O9QLqm431J8EHZgN94J/AmP9FivlfRB9oNfkHQeOfyvHbB7J62zbwfYcXuo/9DexjwFg74PxRfSBSJ//x3AdarvxDqJV/SXr5bxp8YEbVyNcP7cDNZ4Rcetrz+2a9y7o9R6Pf7AOsF2CsHXr+GHljc4fOm2K4eMgeuEHOAYuxOJoRnUjhorGwLPL2BQekGHjeTDDikwZx4MbumVXUdqGbzX7Rbza0Azf7EZrN/sCaiTf6Nm4sI/FC59IBRcZlL+jyDtzsS8ilA0m5dGBV3saqCwbsA9wwsLGMF91zHbDnHgjsQQeRYn5QVd7GqnmiDEL+787xe8HC2ix6LkfDexwM7BfAWDvg/FE3VpE6WaIq9p7RtWK5UoKgEYeQ9PKQNPitQ6NfP5QH7KHHQD9gh3kCl+jdUs2Tw0g5fhjRBzYKBuwH1Dcb6zCCD2wE9IGHAWN+OCnmhxN9oNXkoQSNfynHbx/I6m0vg+87vNB9rCSwjwFj7YDzR/WBSJ0s5bkPtFwpRaiV0iS9LJ0GH1gm+vVD8YGhx0D7QJgncIneLdU8OYKU40cQfWDjYMCTgPpmYx1B8IGNgT7wCGDMy5JiXpboA60myxA0/vUcv30gq7e9Ab7v8EL3sSOBfQwYawecP6oPROpkOc99oOVKOUKtlCfpZfk0+MAK0a8fig8MPQbaB8I8gUv0bqnmSUVSjlck+sAmwYD9gfpmY1Uk+MAmQB9YERjzSqSYVyL6QKvJCgSNfyfHbx/I6m3vgu87vNB9rDKwjwFj7YDzR/WBSJ2s4rkPtFypQqiVqiS9rJoGH1gt+vVDO3BzACGX3vP8vlnvsr6fo9FvYsB6AcbaoeePkTcxQt5ULzpw45BzwGKs4fuBm3DRWFgWeZkCB25qgA/cZIoduMmKfrOhHbjJIjSbmiSjXzMNRr9WkXHZC7q8AzeZhFyqTcql2sSN1abBgKcCNwxsrNqEjdWmwJ5bG9iD6pBiXoe4sWqeqBoh/z/N8XvBwtos+ixHw3scBewXwFg74PxRN1aROnm05xurlitHE2qlLkkv66bBb9WLfv1QHrCHHgP9gB3mCVyid0v5Xw0k5Xh9og9sFgw4AKhvNlZ9gg9sBvSB9YExb0CKeQOiD7SarEfQ+K9y/PaBrN72Nfi+wwvdxxoC+xgw1g44f1QfiNTJbM99oOVKNqFWHEkvXRp8YKPo1w/FB4YeA+0DYZ7AJXq3lA+vkHK8MdEHNg8GHAjUNxurMcEHNgf6wMbAmDchxbwJ0QdaTTYiaPz3OX77QFZv+wF83+GF7mNNgX0MGGsHnD+qD0TqZDPPfaDlSjNCrTQn6WXzNPjAFtGvH4oPDD0G2gfCPIFL9G6p5klLUo63JPrAFsGAg4H6ZmO1JPjAFkAf2BIY81akmLci+kCryRYEjf8lx28fyOptv4LvO7zQfaw1sI8BY+2A80f1gUidPMZzH2i5cgyhVtqQ9LJNGnxg2+jXD+3ATS1CLv3m+X2z3mX9PUej37QD1gsw1g49f4y8aUfIm2OLDtw45BywGNv7fuAmXDQWlkVeB4EDN+3BB246iB246Rj9ZkM7cNOR0Gw6kYx+pzQY/c5FxmUv6PIO3HQg5FIXUi51IW6stgwGHALcMLCxuhA2VlsCe24XYA/qSop5V+LGqnmitoT8/zfH7wULa7MoY4iG9zgO2C+AsXbA+aNurCJ1spvnG6uWK90ItXI8SS+PT4Pf6h79+qE8YA89BvoBO8wTuETvlmqe9CDleA+iD2wVDDgMqG82Vg+CD2wF9IE9gDHvSYp5T6IPtJrsTtD4fcl6lJ3aRett+4n4wBOAfQwYa7efiA9E6mQvz32g5UovQq30Jull7zT4wD7Rrx+KDww9BtoHwjyBS/RuqeZJX1KO9yX6wNbBgLlAfbOx+hJ8YGugD+wLjHk/Usz7EX2g1WQfgsYf5LkPZPW2g0V84InAPgaMtTtYxAcidfIkz32g5cpJhFo5maSXJ6fBB/aPfv1QfGDoMdA+EOYJXKJ3SzVPTiHl+ClEH3hMMOBIoL7ZWKcQfOAxQB94CjDmp5JifirRB1pN9ido/GGe+0BWbztcxAeeBuxjwFi7w0V8IFInB3juAy1XBhBq5XSSXp6eBh84MPr1Qztw05mQSyU9v2/Wu6ylRPrNIGC9AGPtSgnkzSBC3gwuOnDjkHPAYszx/cBNuGgsLIu8IQIHbnLAB26GiB24GRr9ZkM7cDOU0GyGkYz+sDQY/eFFxmUv6PIO3Awh5FIuKZdyiRurbYIBRwE3DGysXMLGahtgz80F9qARpJiPIG6smicaSMj/cp4vWFibReVFFrojgf0CGGtXHuw9wgutlUidPMPzjVXLlTMItTKKpJej0uC3zox+/VAesIceA/2AHeYJXKJ3SzVPRpNyfDTRB7YNBhwN1DcbazTBB7YF+sDRwJifRYr5WUQfaDV5JkHjK3vuA1m9rYqIDxwD7GPAWLsqIj4QqZNne+4DLVfOJtTKOSS9PCcNPvDc6NcPxQeGHgPtA2GewCV6t1TzZCwpx8cSfWC7YMAxQH2zscYSfGA7oA8cC4z5eaSYn0f0gVaT5xI0vrrnPpDV22qI+MBxwD4GjLWrIeIDkTp5vuc+0HLlfEKtjCfp5fg0+MAJ0a8fig8MPQbaB8I8gUv0bqnmyURSjk8k+sBjgwHPAeqbjTWR4AOPBfrAicCYX0CK+QVEH2g1OYGg8bU894Gs3lZbxAdeCOxjwFi72iI+EKmTF3nuAy1XLiLUyiSSXk5Kgw+8OPr1QztwM5yQS3UEDk4w3mU9SqTfTAbWCzDW7iiBvJlMyJtLig7cOOQcsBin+H7gJlw0FpZF3lSBAzdTwAdupooduLk0+s2GduDmUkKzuYxk9C9Lg9GfVmRc9oIu78DNVEIuTSfl0nTixmr7YMCxwA0DG2s6YWO1PbDnTgf2oBmkmM8gbqyaJ7qYkP8NPV+wsDaLskUWupcD+wUw1i4b7D3CC62VSJ28wvONVcuVKwi1ciVJL69Mg9+aGf36oTxgDz0G+gE7zBO4RO+Wap5cRcrxq4g+sEMw4DigvtlYVxF8YAegD7wKGPNZpJjPIvpAq8mZBI1v4rkPZPW2piI+8GpgHwPG2jUV8YFInZztuQ+0XJlNqJVrSHp5TRp84Jzo1w/FB4YeA+0DYZ7AJXq3VPPkWlKOX0v0gR2DAccD9c3GupbgAzsCfeC1wJjPJcV8LtEHWk3OIWh8S899IKu3tRLxgdcB+xgw1q6ViA9E6uT1nvtAy5XrCbVyA0kvb0iDD7wx+vVD8YGhx0D7QJgncIneLdU8uYmU4zcRfWCnYMCJQH2zsW4i+MBOQB94EzDmN5NifjPRB1pN3kjQ+Lae+0BWb2sn4gNvAfYxYKxdOxEfiNTJeZ77QMuVeYRauZWkl7emwQfeFv36oR24mUbIpWMFDk4w3mVtL9JvbgfWCzDWrr1A3txOyJs7ig7cOOQcsBjn+37gJlw0FpZF3gKBAzfzwQduFogduLkz+s2GduDmTkKzuYtk9O9Kg9G/u8i47AVd3oGbBYRcWkjKpYXEjdXOwYAXAjcMbKyFhI3VzsCeuxDYgxaRYr6IuLFqnug2Qv539XzBwtosOk5kobsY2C+AsXbHgb1HeKG1EqmT93i+sWq5cg+hVu4l6eW9afBb90W/figP2EOPgX7ADvMELtG7pZonS0g5voToA7sEA04C6puNtYTgA7sAfeASYMzvJ8X8fqIPtJq8j6DxPTz3gaze1lPEBy4F9jFgrF1PER+I1MkHPPeBlisPEGrlQZJePpgGH/hQ9OuH4gNDj4H2gTBP4BK9W6p5soyU48uIPrBrMOBkoL7ZWMsIPrAr0AcuA8Z8OSnmy4k+0GryIYLG9/HcB7J6W18RH7gC2MeAsXZ9RXwgUicf9twHWq48TKiVlSS9XJkGH7gq+vVD8YGhx0D7QJgncIneLdU8WU3K8dVEH3hcMOAUoL7ZWKsJPvA4oA9cDYz5GlLM1xB9oNXkKoLGn+y5D2T1tv4iPnAtsI8BY+36i/hApE6u89wHWq6sI9TKIyS9fCQNPvDR6NcP7cDN3YRcOkXg4ATjXdZTRfrNemC9AGPtThXIm/WEvNlQdODGIeeAxbjR9wM34aKxsCzyNgkcuNkIPnCzSezAzWPRbza0AzePEZrN4ySj/3gajP7mIuOyF3R5B242EXJpCymXthA3VrsFA14K3DCwsbYQNla7AXvuFmAP2kqK+Vbixqp5okcJ+T/Y8wULa7MoR2Sh+wSwXwBj7XLA3iO80FqJ1MknPd9YtVx5klArT5H08qk0+K1t0a8fygP20GOgH7DDPIFL9G6p5snTpBx/mugDjw8GnAbUNxvraYIPPB7oA58Gxnw7KebbiT7QanIbQeOHe+4DWb0tV8QH7gD2MWCsXa6ID0Tq5E7PfaDlyk5CrTxD0stn0uADd0W/fig+MPQYaB8I8wQu0bulmifPknL8WaIP7B4MOAOobzbWswQf2B3oA58Fxnw3Kea7iT7QanIXQeNHee4DWb3tTBEf+BywjwFj7c4U8YFInXzecx9oufI8oVZeIOnlC2nwgS9Gv34oPjD0GGgfCPMELtG7pZonL5Fy/CWiD+wRDHgFUN9srJcIPrAH0Ae+BIz5y6SYv0z0gVaTLxI0/mzPfSCrt50j4gNfAfYxYKzdOSI+EKmTr3ruAy1XXiXUymskvXwtDT7w9ejXD+3AzWZCLp0rcHCC8S7rWJF+8wawXoCxdmMF8uYNQt68WXTgxiHngMX4lu8HbsJFY2FZ5L0tcODmLfCBm7fFDty8E/1mQztw8w6h2bxLMvrvpsHov1dkXPaCLu/AzduEXHqflEvvEzdWewYDzgRuGNhY7xM2VnsCe+77wB70ASnmHxA3Vs0TvU7I/4meL1hYm0UXiCx0PwT2C2Cs3QVg7xFeaK1E6uRHnm+sWq58RKiVj0l6+XEa/NYn0a8fygP20GOgH7DDPIFL9G6p5smnpBz/lOgDTwgGnAXUNxvrU4IPPAHoAz8FxvwzUsw/I/pAq8lPCBp/sec+kNXbJov4wM+BfQwYazdZxAcidfILz32g5coXhFr5kqSXX6bBB34V/fqh+MDQY6B9IMwTuETvlmqefE3K8a+JPrBXMOBsoL7ZWF8TfGAvoA/8Ghjzb0gx/4boA60mvyJo/KWe+0BWb7tMxAd+C+xjwFi7y0R8IFInv/PcB1qufEeole9Jevl9GnzgD9GvH4oPDD0G2gfCPIFL9G6p5smPpBz/kegDewcDzgHqm431I8EH9gb6wB+BMf+JFPOfiD7QavIHgsZf7rkPZPW2K0R84M/APgaMtbtCxAcidfIXz32g5covhFr5laSXv6bBB/4W/fqhHbh5j5BLVwocnGC8yzpTpN/8DqwXYKzdTIG8+Z2QN38UHbhxyDlgMf7p+4GbcNFYWBZ5fwkcuPkTfODmL7EDN39Hv9nQDtz8TWg2/5CM/j9pMPr/FhmXvaDLO3DzFyGXzGkwcsnGjeWPi94s6BMMOBe4YWBjGS+65/YB9tz4OKV6v/uQYr5PNd7Gqnmi3wj5P8fzBQtrs+hakYVusWrAHAL2i2vB3iO80FqJ1Mni1bD3jK4VyxVjRNfKviS93Lca32/tF/36oTxgDz0G+gE7zBO4RO+Wap7sT8rx/Yk+sG8w4PVAfbOx9if4wL5AH7g/MOYHkGJ+ANEHWk3uR9D4Gzz3gazedqOIDzwQ2MeAsXY3ivhApE4e5LkPtFw5iFArB5P08uA0+MAS0a8fig8MPQbaB8I8gUv0bqnmySGkHD+E6AP7BQPeCNQ3G+sQgg/sB/SBhwBjfigp5ocSfaDVZAmCxs/z3AeyetutIj7wMGAfA8ba3SriA5E6ebjnPtBy5XBCrZQk6WXJNPjAUtGvH4oPDD0G2gfCPIFL9G6p5klpUo6XJvrAE4MBbwbqm41VmuADTwT6wNLAmJchxbwM0QdaTZYiaPx8z30gq7ctEPGBRwD7GDDWboGID0TqZFnPfaDlSllCrRxJ0ssj0+ADy0W/fijvA9t7eMh3GFnviJav5nf/svsuT6jJCsD7ttxRPIhRoZr/jBXRjOhEChcThcX8V6rmt/CaYFQE3q+NV6kap6jR9255iGzYLENUmSA8dqHNTxWkYc3BjbVPjt9N28xPFULe3OP5Ytu0ojLhvu8VWWxXBdYLMNYufv5S2+Ad5vYNxtg/LnfiL3Q+VQUvHMOrWjUicLVq+HFjwIbOuu+YiEk4PBCpWBXceOWCsapVwYtedc+NZknwPJYnzWMNz+exFHgeK5DmMdPzeSwNnseKpHnM8nwey4DnsRJpHmt6Po9HgOexMmkea3k+j2XB81iFNI+1PZ/HI8HzWJU0j3XApr9MRh7jsVXynhbZ9wFx30+P+z4w7vuguO+D477nxH0fEvd9aNz3YXHfh8d9z437PiLu+8i472fEfR8V9716tf9+rxH3PTPue1bc95px32vFfa8d971O/vejgv8eHXzqBp96wad+8GkQfBoGn+x8X8/YLIgRNgsc+YkOYkOVcd+NgJsP++bfd7hBYt83hIKUwcmHshnYuDEYjxRgLCfAWF6AsYIAY0UBxkoCjJUFGKsIMFYVYKwmwBgTYKwuwFhDgDFTgDFLgLGmAGMtAcbaAox1BBiPEmA8WoCxrgBjPQHG+gKMDQQYGwowZgswOgHGRgKMjQUYmwgwNhVgbCbA2FyAsYUAY0sBxlYCjK0FGI8RYGwjwNhWgLGdAOOxAoztBRg7CDB2FGDsJMDYWYCxiwBjVwHG4wQYuwkwHi/A2F2AsYcAY08BxhMEGHsJMPYWYOwjwNhXgLGfAOOJAownCTCeLMDYX4DxFAHGUwUYTxNgHCDAeLoA40ABxkECjIMFGHMEGIcIMA4VYBwmwDhcgDFXgHGEAONIAcYzBBhHCTCeKcA4WoDxLAHGMQKMZwswniPAeK4A41gBxvMEGMcJMJ4vwDhegHGCAONEAcYLBBgvFGC8SIBxkgDjxQKMkwUYLxFgnCLAOFWA8VIBxssEGKcJME4XYJwhwHi5AOMVAoxXCjDOFGC8SoBxlgDj1QKMswUYrxFgnCPAeK0A41wBxusEGK8XYLxBgPFGAcabBBhvFmC8RYBxngDjrQKMtwkw3i7AeIcA43wBxgUCjHcKMN4lwHi3AONCAcZFAoyLBRjvEWC8V4DxPgHGJQKM9wswLhVgfECA8UEBxocEGJcJMC4XYFwhwPiwAONKAcZVAoyrBRjXCDCuFWBcJ8D4iADjowKM6wUYNwgwbhRg3CTA+JgA4+MCjJsFGLcIMG4VYHxCgPFJAcanBBi3CTA+LcC4XYBxhwDjTgHGZwQYdwkwPivAuFuA8TkBxucFGF8QYHxRgPElAcaXBRhfEWB8VYDxNQHG1wUY3xBgfFOA8S0BxrcFGN8RYHxXgPE9Acb3BRg/EGD8UIDxIwHGjwUYPxFg/FSA8TMBxs8FGL8QYPxSgPErAcavBRi/EWD8VoDxOwHG7wUYfxBg/FGA8ScBxp8FGH8RYPxVgPE3AcbfBRj/EGD8U4DxLwHGvwUY/xFg/FeA0Qb0nXEfAcZiAozFBRj3FWDcT4BxfwHGAwQYDxRgPEiA8WABxhICjIcIMB4qwHiYAOPhAowlBRhLCTCWFmAsI8B4hABjWQHGIwUYywkwlhdgrCDAWFGAsZIAY2UBxioCjFUFGKsJMMYEGKsLMNYQYMwUYMwSYKwpwFhLgLG2AGMdAcajBBiPFmCsK8BYT4CxvgBjAwHGhgKM2QKMToCxkQBjYwHGJgKMTQUYmwkwNhdgbCHA2FKAsZUAY2sBxmMEGNsIMLYVYGwnwHisAGN7AcYOAowdBRg7CTB2FmDsIsDYVYDxOAHGbgKMxwswdhdg7CHA2FOA8QQBxl4CjL0FGPsIMPYVYOwnwHiiAONJAownCzD2F2A8RYDxVAHG0wQYBwgwni7AOFCAcZAA42ABxhwBxiECjEMFGIcJMA4XYMwVYBwhwDhSgPEMAcZRAoxnCjCOFmA8S4BxjADj2QKM5wgwnivAOFaA8TwBxnECjOcLMI4XYJwgwDhRgPECAcYLBRgvEmCcJMB4sQDjZAHGSwQYpwgwThVgvFSA8TIBxmkCjNMFGGcIMF4uwHiFAOOVAowzBRivEmCcJcB4tQDjbAHGawQY5wgwXivAOFeA8ToBxusFGG8QYLxRgPEmAcabBRhvEWCcJ8B4qwDjbQKMtwsw3iHAOF+AcYEA450CjHcJMN4twLhQgHGRAONiAcZ7BBjvFWC8T4BxiQDj/QKMSwUYHxBgfFCA8SEBxmUCjMsFGFcIMD4swLhSgHGVAONqAcY1AoxrBRjXCTA+IsD4qADjegHGDQKMGwUYNwkwPibA+LgA42YBxi0CjFsFGJ8QYHxSgPEpAcZtAoxPCzBuF2DcIcC4U4DxGQHGXQKMzwow7hZgfE6A8XkBxhcEGF8UYHxJgPFlAcZXBBhfFWB8TYDxdQHGNwQY3xRgfEuA8W0BxncEGN8VYHxPgPF9AcYPBBg/FGD8SIDxYwHGTwQYPxVg/EyA8XMBxi8EGL8UYPxKgPFrAcZvBBi/FWD8ToDxewHGHwQYfxRg/EmA8WcBxl8EGH8VYPxNgPF3AcY/BBj/FGD8S4DxbwHGfwQY/xVgzCjmP+M+AozFBBiLCzDuK8C4nwDj/gKMBwgwHijAeJAA48ECjCUEGA8RYDxUgPEwAcbDBRhLCjCWEmAsLcBYRoDxCAHGsgKMRwowlhNgLC/AWEGAsaIAYyUBxsoCjFUEGKsKMFYTYIwJMFYXYKwhwJgpwJglwFhTgLGWAGNtAcY6AoxHCTAeLcBYV4CxngBjfQHGBgKMDQUYswUYnQBjIwHGxgKMTQQYmwowNhNgbC7A2EKAsaUAYysBxtYCjMcIMLYRYGwrwNhOgPFYAcb2AowdBBg7CjB2EmDsLMDYRYCxqwDjcQKM3QQYjxdg7C7A2EOAsacA4wkCjL0EGHsLMPYRYOwrwNhPgPFEAcaTBBhPFmDsL8B4igDjqQKMpwkwDhBgPF2AcaAA4yABxsECjDkCjEMEGIcKMA4TYBwuwJgrwDhCgHGkAOMZAoyjBBjPFGAcLcB4lgDjGAHGswUYzxFgPFeAcawA43kCjOMEGM8XYBwvwDhBgHGiAOMFAowXCjBeJMA4SYDxYgHGyQKMlwgwThFgnCrAeKkA42UCjNMEGKcLMM4QYLxcgPEKAcYrBRhnCjBeJcA4S4DxagHG2QKM1wgwzhFgvFaAca4A43UCjNcLMN4gwHijAONNAow3CzDeIsA4T4DxVgHG2wQYbxdgvEOAcb4A4wIBxjsFGO8SYLxbgHGhAOMiAcbFAoz3CDDeK8B4nwDjEgHG+wUYlwowPiDA+KAA40MCjMsEGJcLMK4QYHxYgHGlAOMqAcbVAoxrBBjXCjCuE2B8RIDxUQHG9QKMGwQYNwowbhJgfEyA8XEBxs0CjFsEGLcKMD4hwPikAONTAozbBBifFmDcLsC4Q4BxpwDjMwKMuwQYnxVg3C3A+ByBkcFZ/gAOZwaSs1ET++d8/nP/JfO/N66WkdEk+DQNPs2CT/Pg0yL4tAw+rYJP6+BzTPBpE3zaBp92wefY4NM++HSoljdGx2r5gxbP/68NGivwsyZJftY0yc+aJflZ8yQ/a5HkZy2T/KxVkp+1TvKzY5L8rE2Sn7VN8rN2SX52bJKftU/ysw5JftYx/2dhsOKToHF2syZNcps3ynWN3ZDsRi2Htmia3aTp0GYtXAvXtEXT4Y1aNG6c26JJi+Yth7Zsnt3SNWmc60Y0bdk4d4RdeX8gcl6JjIxiyORy2dnxf3hybxlH5A/XqRquoOLntVPcvBYDzWvIbH/U8rYSuPFsLOMtjowT9o9vuvg4pXq/nUkx70yspTDm0Bi5vFxCjYWMURdSjLoQ69L+kOsdwLq0sboQ6hL4B2ddF2DMu5Ji3jUu5uFVHBz7eWA9Ro11HG5OG8fPH7p2kHXTDXfPLiMDb+ItJsaI6hHhfR9Pqp/jC3H9dMfNaaNkuZSqLwh7DtoX9Af6AmSP6EHK8R5EX2B/PH0BMCdtrB4EXwD8I++uBzDmPUkx7/m/+PXs1C5nNdmdoPGbh2A3gFR62xbwfYcXuo+dAPQewFg74Py5+PlDayVSJ3t57gMtV3oRaqU3SS97p8EH9ol+/WQnq5vs1C63xz9Xwfpx21tHczYG+oK+1Tg9Aa1pyLVNP7KmobxuYfGmJ1bzWxesRvpVw+bfidX+WyvIe4f2V5dXdycS+utJpP56EnENav841l1AHbKxTiKsQYH/iJc7CZj3J5NifjJxDWo63IeQ/zs8X4OyfPVOkTVof6BHAMba7RRZgyJ18hTP16CWK6cQauVUkl6emoY16GnRr5+kupvqs4jQY6CfRcA8gUv0bqnmyQBSjg8g+kD7B0gXAvXNxhpA8IHAfyjVDQDG/HRSzE8n+kCrydMIGr/bcx/I6m3PifjAgcA+Boy1e07EByJ1cpDnPtByZRChVgaT9HJwGnxgTvTrh+IDQ4+B9oEwT+ASvVuqeTKElONDiD7Q/pH3xUB9s7GGEHwg8B+jd0OAMR9KivlQog+0mswhaPxLnvtAVm97WcQHDgP2MWCs3csiPhCpk8M994GWK8MJtZJL0svcNPjAEdGvH4oPDD0G2gfCPIFL9G6p5slIUo6PJPrA04MB7wXqm401kuADTwf6wJHAmJ9BivkZRB9oNTmCoPGve+4DWb3tDREfOArYx4Cxdm+I+ECkTp7puQ+0XDmTUCujSXo5Og0+8Kzo1w/t3eQB4HeTmxDeTW4C9AVjPH8v1ObwdHBMmhJi0hQYk7MFYjIQHJNmhJg0A8bkHIGYDALHpDkhJs2BMTlXICaDwTFpQYhJC2BMxgrEJAcck5aEmLQExuQ8gZgMAcekFSEmrYAxGScQk6HgmLQmxKQ1MCbnC8RkGDgmxxBicgwwJuMFYjIcHJM2hJi0AcZkgkBMcsExaUuISVtgTCYKxGQEOCbtCDFpB4zJBQIxGQmOybGEmBwLjMmFAjE5AxyT9oSYtAfG5CKBmIwCx6QDISYdgDGZBIyJPd+okfHfP7BtZ/1t39n2OW1fzfZxbN/A1qm2LjIfbr7PfIb1NdNRq1vLk0lxZ/rRz5Lsbwb0IzxLuhg4l8Xy57LghRqfNbcXV/OfcTKaEZ1I4UswheWllUs8bwwmFpOB92vjXVKNU9SMP1pyCUEsp5AevE8hvpw2MBhwCfClCxtrCuHltIHAOp8CzPuppJhPJb6cZjp8FiH///H85TTWCzf/irycdinw5RpgrN2/Ii+nIXXyMs9fTrNcuYxQK9NIejktDS+nTY9+/VAOKYQeA31IAeYJXKJ3SzVPZpByfAbRBw4KBlwK1DcbawbBBw4C+sAZwJhfTor55UQfaDU5naDxxYf67QNZvW1f8H2HF7qPXQHsY8BYO+D8UX0gUiev9NwHWq5cSaiVmSS9nJkGH3hV9OuH4gNDj4H2gTBP4BK9W6p5MouU47OIPnBwMOCDQH2zsWYRfOBgoA+cBYz51aSYX030gVaTVxE0/kDPfSCrtx0k4gNnA/sYMNYOOH9UH4jUyWs894GWK9cQamUOSS/npMEHXhv9+qH4wNBjoH0gzBO4RO+Wap7MJeX4XKIPzAkGXAbUNxtrLsEH5gB94FxgzK8jxfw6og+0mryWoPGHeu4DWb3tMBEfeD2wjwFj7YDzR/WBSJ28wXMfaLlyA6FWbiTp5Y1p8IE3Rb9+KLobvrRcjDAuKraHez6H9i5jsjlM9b5vBua073No83czQdNuKXp53iHngMU4z/eX58PFWGFZPN0q8PL8PPDL87cqvDxPbDi3+dlwKCba5u82QsO5nWSibyduOrDy6Y7CYmDyD7TcSsin+aR8mk/cuBwSDLgCuCC3seYTNi6HAHvvfGAvWkCK+QKihpg3uomQ/2U9X7iwNmOOBN93eKE3Xu4Eajww1g44f9SNS6RO3uX5xqXlyl2EWrmbpJd3p2HjcmH064fyADv0GOgH2DBP4BK9W6p5soiU44uIPnBoMOBKoL7ZWIsIPnAo0AcuAsZ8MSnmi4k+0GpyIUHjK3ruA1m9rZKID7wH2MeAsXbA+aP6QKRO3uu5D7RcuZdQK/eR9PK+NPjAJdGvH4oPDD0G2gfCPIFL9G6p5sn9pBy/n+gDhwUDrgbqm411P8EHDgP6wPuBMV9KivlSog+0mlxC0PhqnvtAVm+LifjAB4B9DBhrB5w/qg9E6uSDnvtAy5UHCbXyEEkvH0qDD1wW/fqh+MDQY6B9IMwTuETvlmqeLCfl+HKiDxweDLgWqG821nKCDxwO9IHLgTFfQYr5CqIPtJpcRtD4LM99IKu31RTxgQ8D+xgw1g44f1QfiNTJlZ77QMuVlYRaWUXSy1Vp8IGro18/tHdj7yDkUi3P75v1PmttkX6zBlgvwFi72gJ5s4aQN2uLDt445BywGNf5fvAmXDQWlkXeIwIHb9aBD948Qjp4E17oZvNo9JsN7dDNo4Rms55k9NenwehvKDIue0GXd+DmEUIubSTl0kbixmpuMOAjwA0DG2sjYWM1F9hzNwJ70CZSzDcRN1bNE60m5H99zxcsrM2iBiIL3ceA/QIYawecP+rGKlInH/d8Y9Vy5XFCrWwm6eXmNPitLdGvH8oD9tBjoB+wwzyBS/RuqebJVlKObyX6wBHBgOuB+mZjbSX4wBFAH7gVGPMnSDF/gugDrSa3EDS+kec+kNXbGov4wCeBfQwYawecP6oPROrkU577QMuVpwi1so2kl9vS4AOfjn79UHxg6DHQPhDmCVyid0s1T7aTcnw70QeODAbcCNQ3G2s7wQeOBPrA7cCY7yDFfAfRB1pNPk3Q+Oae+0BWb2sh4gN3AvsYMNYOOH9UH4jUyWc894GWK88QamUXSS93pcEHPhv9+qH4wNBjoH0gzBO4RO+Wap7sJuX4bqIPPCMY8DGgvtlYuwk+8AygD9wNjPlzpJg/R/SBVpPPEjT+GM99IKu3tRHxgc8D+xgw1g44f1QfiNTJFzz3gZYrLxBq5UWSXr6YBh/4UvTrh3bgZgMhl9p6ft+sd1nbifSbl4H1Aoy1ayeQNy8T8uaVogM3DjkHLMZXfT9wEy4aC8si7zWBAzevgg/cvCZ24Ob16Dcb2oGb1wnN5g2S0X8jDUb/zSLjshd0eQduXiPk0lukXHqLuLE6KhhwM3DDwMZ6i7CxOgrYc98C9qC3STF/m7ixap7oJUL+d/Z8wcLaLOoistB9B9gvgLF2wPmjbqwidfJdzzdWLVfeJdTKeyS9fC8Nfuv96NcP5QF76DHQD9hhnsAlerdU8+QDUo5/QPSBZwYDbgXqm431AcEHngn0gR8AY/4hKeYfEn2g1eT7BI0/3nMfyOpt3UV84EfAPgaMtQPOH9UHInXyY899oOXKx4Ra+YSkl5+kwQd+Gv36ofjA0GOgfSDME7hE75ZqnnxGyvHPiD5wdDDgk0B9s7E+I/jA0UAf+Bkw5p+TYv450QdaTX5K0PhenvtAVm/rLeIDvwD2MWCsHXD+qD4QqZNfeu4DLVe+JNTKVyS9/CoNPvDr6NcPxQeGHgPtA2GewCV6t1Tz5BtSjn9D9IFnBQNuA+qbjfUNwQeeBfSB3wBj/i0p5t8SfaDV5NcEjT/Rcx/I6m0nifjA74B9DBhrB5w/qg9E6uT3nvtAy5XvCbXyA0kvf0iDD/wx+vVDO3DzJiGXTvb8vlnvsvYX6Tc/AesFGGvXXyBvfiLkzc9FB24ccg5YjL/4fuAmXDQWlkXerwIHbn4BH7j5VezAzW/Rbza0Aze/EZrN7ySj/3sajP4fRcZlL+jyDtz8SsilP0m59CdxY3VMMOB24IaBjfUnYWN1DLDn/gnsQX+RYv4XcWPVPNGPhPwf6PmChbVZNEhkofs3sF8AY+2A80fdWEXq5D+eb6xarvxDqJV/SXr5bxr8lv2CiNcP5QF76DHQD9hhnsAlerdU82SfGCfHbdxY/rhobTs7GHAnUN9sLONF+8CzgT4wPk6p3m8xUsyLxXg+0GrSBkdr/FDPfSCrtw0T8YHFY7i5BMbaAeeP6gOROrlvzG8faLlijOha2S/G0UsbN5aReKHrZ/9Y5OuH4gNDj4H2gTBP4BK9W6p5cgApxw+I8XzgOcGAu4D6ZmMZL9oHngP0gQcAY34gKeYHxng+0GrSNA2t8SM994Gs3naGiA88KIabS2CsHXD+qD4QqZMHx/z2gZYrBxNqpUSMo5c2biwj8ULXzyGxyNcPxQeGHgPtA2GewCV6t1Tz5FBSjh8a4/nAc4MBdwP1zcYyXrQPPBfoAw8FxvwwUswPi/F8oNWkaRr8PTzPfSCrt40R8YGHx3BzCYy1A84f1QcidbJkzG8faLlSklArpWIcvbRxYxmJF7p+SsciXz+0Azd/EJ7DnO35fbPeZT1HpN+UiQGfBwPr5RyBvLG5Q+fNEbh4yB64Qc4Bi7EsmhGdSOGisbAs8o4EB6QYeN5MMMoC79fGs3vOwHJSm025WOSbDe3Ajc0dWiPK4+KRYPRt3FhG4oXOpQqxyOcS7cDNkYRcqkjKpYox3sbq2GDA54EbBjaW8aJ77lhgz42PU6r3W4kU80ox3saqeaLShPwf7/mChbVZNEFkoVs5hptLYKwdcP6oG6tInawS89tvWa5UIdRK1RhHL23cWEbiha6farHI1w/lAXvoMdAP2GGewCV6t1TzJEbK8ViM5wPPCwZ8EahvNpbxon3geUAfGAPGvDop5tVjPB9oNWmahtb4izz3gazeNknEB9aI4eYSGGsHnD+qD0TqZGbMbx9ouZJJqJWsGEcvbdxYRuKFrp+ascjXD8UHhh4D7QNhnsAlerdU86QWKcdrxXg+cFww4MtAfbOxjBftA8cBfWAtYMxrk2JeO8bzgVaTpmlojZ/iuQ9k9bapIj6wTgw3l8BYO+D8UX0gUiePivntAy1XjiLUytExjl7auLGMxAtdP3Vjka8fig8MPQbaB8I8gUv0bqnmST1SjteL8Xzg+cGArwL1zcYyXrQPPB/oA+sBY16fFPP6MZ4PtJo0TUNr/HTPfSCrt80Q8YENYri5BMbaAeeP6gOROtkw5rcPtFxpSKiV7BhHL23cWEbiha4fF4t8/dAO3FQg5NLlnt83613WK0T6TaMYbi6BsXZXCORNI0LeNMbFQ/bADXIOWIxN0IzoRAoXjYVlkdcUHJBi4HkzwWgCvF8bz+45A8tJbTbNYpFvNrQDNzZ3aI1ojotHgtG3cWMZiRc6l1rEIp9LtAM3TQm51JKUSy1jvI3V8cGArwM3DGws40X33PHAnhsfp1TvtxUp5q1ivI1V80SOkP+zPV+wsDaLrhFZ6LaO4eYSGGsHnD/qxipSJ4+J+e23LFeOIdRKmxhHL23cWEbiha6ftrHI1w/lAXvoMdAP2GGewCV6t1TzpB0px9vFeD5wQjDgm0B9s7GMF+0DJwB9YDtgzI8lxfzYGM8HWk2apqE1/jrPfSCrt10v4gPbx3BzCYy1A84f1QcidbJDzG8faLnSgVArHWMcvbRxYxmJF7p+OsUiXz8UHxh6DLQPhHkCl+jdUs2TzqQc7xzj+cCJwYBvA/XNxjJetA+cCPSBnYEx70KKeZcYzwdaTZqmoTX+Zs99YPsYp7fdIuIDu8ZwcwmMtQPOH9UHInXyuJjfPtBy5ThCrXSLcfTSxo1lJF7o+jk+Fvn6ofjA0GOgfSDME7hE75ZqnnQn5Xj3GM8HXhAM+C5Q32ws40X7wAuAPrA7MOY9SDHvEeP5QKtJ0zS0xt/uuQ9k9bY7RHxgzxhuLoGxdsD5o/pApE6eEPPbB1qunEColV4xjl7auLGMxAtdP71jka8f2oGbFoRcmu/5fbPeZV0g0m/6xHBzCYy1WyCQN30IedMXFw/ZAzfIOWAx9kMzohMpXDQWlkXeieCAFEMnTCAY/YD3a+PZPWdgOanN5qRY5JsN7cCNzR1aI07GxSPB6Nu4sYzEC51L/WORzyXagZsTCbl0CimXTonxNlYvDAZ8H7hhYGMZL7rnXgjsufFxSvV+TyXF/NQYb2PVPFFvQv4v9nzBwtosukdkoXtaDDeXwFg74PxRN1aROjkg5rffslwZQKiV02McvbRxYxmJF7p+BsYiXz+UB+yhx0A/YId5Apfo3VLNk0GkHB8U4/nAi4IBPwTqm41lvGgfeBHQBw4CxnwwKeaDYzwfaDVpmobW+Ps994Gs3rZUxAfmxHBzCYy1A84f1QcidXJIzG8faLkyhFArQ2McvbRxYxmJF7p+hsUiXz8UHxh6DLQPhHkCl+jdUs2T4aQcHx7j+cBJwYAfA/XNxjJetA+cBPSBw4ExzyXFPDfG84FWk6ZpaI1f5rkPZPW25SI+cEQMN5fAWDvg/FF9IFInR8b89oGWKyMJtXJGjKOXNm4sI/FC18+oWOTrh+IDQ4+B9oEwT+ASvVuqeXImKcfPjPF84MXBgJ8C9c3GMl60D7wY6APPBMZ8NCnmo2M8H2g1aZqG1vhVnvtAVm9bLeIDz4rh5hIYawecP6oPROrkmJjfPtByZQyhVs6OcfTSxo1lJF7o+jknFvn6oR246U/IpTWe3zfrXda1Iv3m3BhuLoGxdmsF8uZcQt6MxcVD9sANcg5YjOehGdGJFC4aC8sibxw4IMXA82aCcR7wfm08u+cMLCe12Zwfi3yzoR24sblDa8R4XDwSjL6NG8tIvNC5NCEW+VyiHbgZR8iliaRcmhjjbaxODgb8HLhhYGMZL7rnTgb23Pg4pXyolxTzC2K8jVXzROcQ8n+j5wsW1mbRJpGF7oUx3FwCY+2A80fdWEXq5EUxv/2W5cpFhFqZFOPopY0by0i80PVzcSzy9UN5wB56DPQDdpgncIneLWVPRcrxyTGeD7wkGPBLoL7ZWMaL9oGXAH3gZGDMLyHF/JIYzwdaTZqmoTV+i+c+kNXbtor4wCkx3FwCY+2A80f1gUidnBrz2wdarkwl1MqlMY5e2rixjMQLXT+XxSJfPxQfGHoMtA+EeQKX6N1SzZNppByfFuP5wCnBgF8D9c3GMl60D5wC9IHTgDGfTor59BjPB1pNmqahNX6b5z6Q1dueFvGBM2K4uQTG2gHnj+oDkTp5ecxvH2i5cjmhVq6IcfTSxo1lJF7o+rkyFvn6ofjA0GOgfSDME7hE75Zqnswk5fjMGM8HTg0G/BaobzaW8aJ94FSgD5wJjPlVpJhfFeP5QKtJ0zS0xj/juQ9k9bZdIj5wVgw3l8BYO+D8UX0gUievjvntAy1XribUyuwYRy9t3FhG4oWun2tika8f2oGbCYRcetbz+2a9y7pbpN/MieHmEhhrt1sgb+YQ8uZaXDxkD9wg54DFOBfNiE6kcNFYWBZ514EDUgw8byYYc4H3a+PZPWdgOanN5vpY5JsN7cCNzR1aI27AxSPB6Nu4sYzEC51LN8Yin0u0AzfXEXLpJlIu3RTjbaxeGgz4PXDDwMYyXnTPvRTYc+PjlOr93kyK+c0x3saqeaJrCPn/sucLFtZm0SsiC91bYri5BMbaAeePurGK1Ml5Mb/9luXKPEKt3Brj6KWNG8tIvND1c1ss8vVDecAeegz0A3aYJ3CJ3i3VPLmdlOO3x3g+8LJgwB+B+mZjGS/aB14G9IG3A2N+Bynmd8R4PtBq0jQNrfFveO4DWb3tTREfOD+Gm0tgrB1w/qg+EKmTC2J++0DLlQWEWrkzxtFLGzeWkXih6+euWOTrh+IDQ4+B9oEwT+ASvVuqeXI3KcfvjvF84LRgwJ+B+mZjGS/aB04D+sC7gTFfSIr5whjPB1pN3hXDa/y7nvtAVm97T8QHLorh5hIYawecP6oPROrk4pjfPtByZTGhVu6JcfTSxo1lJF7o+rk3Fvn6ofjA0GOgfSDME7hE75ZqntxHyvH7YjwfOD0Y8FegvtlYxov2gdOBPvA+YMyXkGK+JMbzgVaTpmlojf/Icx/I6m0fi/jA+2O4uQTG2gHnj+oDkTq5NOa3D7RcWUqolQdiHL20cWMZiRe6fh6MRb5+aAdubiTk0iee3zfrXdZPRfrNQzHcXAJj7T4VyJuHCHmzDBcP2QM3yDlgMS5HM6ITKVw0FpZF3gpwQIqB580EYznwfm08u+cMLCe12Twci3yzoR24sblDa8RKXDwSjL6NG8tIvNC5tCoW+VyiHbhZQcil1aRcWh3jbazOCAb8HbhhYGMZL7rnzgD23Pg4pfzPl5JivibG21g1T/QgIf+/9nzBwtos+kZkobs2hptLYKwdcP6oG6tInVwX89tvWa6sI9TKIzGOXtq4sYzEC10/j8YiXz+UB+yhx0A/YId5Apfo3VLNk/WkHF8f4/nAy4MB/wTqm41lvGgfeDnQB64HxnwDKeYbYjwfaDVpmobW+B8894Gs3vajiA/cGMPNJTDWDjh/VB+I1MlNMb99oOXKJkKtPBbj6KWNG8tIvND183gs8vVD8YGhx0D7QJgncIneLdU82UzK8c0xng+8Ihjwb6C+2VjGi/aBVwB94GZgzLeQYr4lxvOBVpOmaWiN/9VzH8jqbb+J+MCtMeCeMrCPAeeP6gOROvlEzG8faLnyBKFWnoxx9NLGjWUkXuj6eSoW+fqh+MDQY6B9IMwTuETvlvK/9EbK8W0xng+8MhjwX6C+2VjGi/aBVwJ94DZgzJ8mxfzpGM8HWk2apqE1/i/PfSCrt/0t4gO3x3BzCYy1A84f1QcidXJHzG8faLmyg1ArO2McvbRxYxmJF7p+nolFvn5oB25WEXLpH8/vm/Uu678i/WZXDDeXwFi7fwXyZhchb57FxUP2wA1yDliMu9GM6EQKF42FZZH3HDggxcDzZoKxG3i/Np7dcwaWk9psno9FvtnQDtzY3KE14gVcPBKMvo0by0i80Ln0YizyuUQ7cPMcIZdeIuXSSzHexurMYMB9DsGNZ2MZL7rnzgT23Pg4pfyvupBi/nKMt7FqnugZQv7vN8zvBQtrs2j/YRre45UYbi6BsXbA+aNurCJ18tWY337LcuVVQq28FuPopY0by0i80PXzeizy9UN5wB56DPQDdpgncIneLeV/4YOU42/EeD7wqmDA4kB9s7GMF+0DrwL6wDeAMX+TFPM3YzwfaDVpmobW+IM994Gs3lZCxAe+FcPNJTDWroSID0Tq5Nsxv32g5crbhFp5J8bRSxs3lpF4oevn3Vjk64fiA0OPgfaBME/gEr1byv/SBSnH34vxfOCsYMD9gPpmYxkv2gfOAvrA94Axf58U8/djPB9oNWmahtb4wz33gazeVlLEB34Qw80lMNaupIgPROrkhzG/faDlyoeEWvkoxtFLGzeWkXih6+fjWOTrh+IDQ4+B9oEwT+ASvVvKf3GdlOOfxHg+8OpgwAOA+mZjGS/aB14N9IGfAGP+KSnmn8Z4PtBq0jQNrfFHeO4DWb2trIgP/CyGm0tgrF1ZER+I1MnPY377QMuVzwm18kWMo5c2biwj8ULXz5exyNcP7cDNi4RcOtLz+2a9y1pOpN98FcPNJTDWrpxA3nxFyJuvcfGQPXCDnAMW4zdoRnQihYvGwrLI+xYckGLgeTPB+AZ4vzae3XN4HZv/3+wUr4y4C91svotFvtnQDtzY3KE14ntcPBKMvo0by0i80Ln0QyzyuUQ7cPMtIZd+JOXSjzHexursYMCDgBsGNpbxonvubGDPjY9Tqvf7EynmP8V4G6vmib4k5H8VzxcsrM2iqiIL3Z9juLkExtpVFdlYRerkLzG//Zblyi+EWvk1xtFLGzeWkXih6+e3WOTrh/KAPfQY6AfsME/gEr1byv8SFinHf4/xfOA1wYAlgPpmYxkv2gdeA/SBvwNj/gcp5n/EeD7QatI0Da3xNTz3gazeliniA/+M4eYSGGuXKeIDkTr5V8xvH2i58hehVv6OcfTSxo1lJF7o+vknFvn6ofjA0GOgfSDME7hE75byX5wk5fi/MZ4PnBMMeChQ32ws40X7wDlAH/gvMOYZ1Tkxt3Fj+eOiNd5q0jQNrfG1PfeBrN5WR8QH7oPLVQeMtasj4gOROlmsOvae4X+cIeAzRnStFCfpZfHqfB+4b/Trh+IDQ4+B9oEwT+ASvVvKB/NIOb5fdZ4PvDYY8HCgvtlYxov2gdcCfWB8nFL+I3ykmO9P9IFWk/sSNL6e5z6Q1dvqi/jAA4B9DBhrV1/EByJ18kDPfaDlyoGEWjmIpJcHpcEHHhz9+qEduLF3GNG51EDg4ATjXdaGIv2mBLBegLF2DQXypgRBew8Baq/11hoZ//NCzitjbpFzwGI8FM2ITqRw0VhYFnmHgQNSDDxvJhiHAu/XxrN7ZhW1Xehmc3j0mw3twM3hhGZTkmT0S6bB6JcqMi57QZd34OYwQi6VJuVSaeLG6txgwFLADQMbqzRhY3UusOeWBvagMqSYlyFurJonOpiQ/009X7CwNouaiSx0jwD2C2CsXTORjVWkTpb1fGPVcqUsoVaOJOnlkWnwW+WiXz+UB+yhx0A/YId5Apfo3VLNk/KkHC9P9IHXBQOWAeqbjVWe4AOvA/rA8sCYVyDFvALRB1pNliNofCvPfSCrt7UW8YEVgX0MGGvXWsQHInWykuc+0HKlEqFWKpP0snIafGCV6NcPxQeGHgPtA2GewCV6t5T/EAcpx6sSfeD1wYBlkevcQ/J40T7weqAPrAqMeTVSzKsRfaDVZBWCxrfz3AeyetuxIj4wBuxjwFi7Y0V8IFInq3vuAy1XqhNqpQZJL2ukwQdmRr9+KD4w9BhoHwjzBC7Ru6WaJ1mkHM8i+sAbggHLAfXNxsoi+MAbgD4wCxjzmqSY1yT6QKvJTILGd/LcB7J6W2cRH1gL2MeAsXadRXwgUidre+4DLVdqE2qlDkkv66TBBx4V/fqhvA9s7+Eh32FkvSN6dHW/+5fd99GE+64LvG/LnRoZ//NCzitjbutW95+xHpoRnUjhYqKwmP/61f0WXhOMesD7tfHsnhlFjb53y0Nkw2YZogYE4bELbX4aAufyniG4se4d4nfTNvPTkJA3PQROjTYg3HdPkcV2NrBegLF28fOX2gbvMLdvMMb+cbkTf6HzCTif2fG8rjoR2FXHj9sI2NBZ991IxCRUD0SqUTXceEcFY7lqeNFr7LnRrAGex6NJ89jE83nMBM9jXdI8NvV8HrPA81iPNI/NPJ/HmuB5rE+ax+aez2Mt8Dw2IM1jC8/nsTZ4HhuS5rGl5/NYBzyP2aR5bAU2/WUy8hj7Vst7WmTfx8R9Pzvu+zlx38+N+z427vt5cd/HxX0/P+77+LjvE+K+T4z7fkHc9wvjvl8U931S3PfG1f/7vUnc96Zx35vFfW8e971F3PeWcd9b5X9vHfz3mODTJvi0DT7tLAbBp33w6VA9LxboNYNtFjQibBZ0BNchmo91352Amw/75t93uEFi3zeEgpTByYeyGdi4MRiPFGAsJ8BYXoCxggBjRQHGSgKMlQUYqwgwVhVgrCbAGBNgrC7AWEOAMVOAMUuAsaYAYy0BxtoCjHUEGI8SYDxagLGuAGM9Acb6AowNBBgbCjBmCzA6AcZGAoyNBRibCDA2FWBsJsDYXICxhQBjSwHGVgKMrQUYjxFgbCPA2FaAsZ0A47ECjO0FGDsIMHYUYOwkwNhZgLGLAGNXAcbjBBi7CTAeL8DYXYCxhwBjTwHGEwQYewkw9hZg7CPA2FeAsZ8A44kCjCcJMJ4swNhfgPEUAcZTBRhPE2AcIMB4ugDjQAHGQQKMgwUYcwQYhwgwDhVgHCbAOFyAMVeAcYQA40gBxjMEGEcJMJ4pwDhagPEsAcYxAoxnCzCeI8B4rgDjWAHG8wQYxwkwni/AOF6AcYIA40QBxgsEGC8UYLxIgHGSAOPFAoyTBRgvEWCcIsA4VYDxUgHGywQYpwkwThdgnCHAeLkA4xUCjFcKMM4UYLxKgHGWAOPVAoyzBRivEWCcI8B4rQDjXAHG6wQYrxdgvEGA8UYBxpsEGG8WYLxFgHGeAOOtAoy3CTDeLsB4hwDjfAHGBQKMdwow3iXAeLcA40IBxkUCjIsFGO8RYLxXgPE+AcYlAoz3CzAuFWB8QIDxQQHGhwQYlwkwLhdgXCHA+LAA40oBxlUCjKsFGNcIMK4VYFwnwPiIAOOjAozrBRg3CDBuFGDcJMD4mADj4wKMmwUYtwgwbhVgfEKA8UkBxqcEGLcJMD4twLhdgHGHAONOAcZnBBh3CTA+K8C4W4DxOQHG5wUYXxBgfFGA8SUBxpcFGF8RYHxVgPE1AcbXBRjfEGB8U4DxLQHGtwUY3xFgfFeA8T0BxvcFGD8QYPxQgPEjAcaPBRg/EWD8VIDxMwHGzwUYvxBg/FKA8SsBxq8FGL8RYPxWgPE7AcbvBRh/EGD8UYDxJwHGnwUYfxFg/FWA8TcBxt8FGP8QYPxTgPEvAca/BRj/EWD8V4DRBvSdcR8BxmICjMUFGPcVYNxPgHF/AcYDBBgPFGA8SIDxYAHGEgKMhwgwHirAeJgA4+ECjCUFGEsJMJYWYCwjwHiEAGNZAcYjBRjLCTCWF2CsIMBYUYCxkgBjZQHGKgKMVQUYqwkwxgQYqwsw1hBgzBRgzBJgrCnAWEuAsbYAYx0BxqMEGI8WYKwrwFhPgLG+AGMDAcaGAozZAoxOgLGRAGNjAcYmAoxNBRibCTA2F2BsIcDYUoCxlQBjawHGYwQY2wgwthVgbCfAeKwAY3sBxg4CjB0FGDsJMHYWYOwiwNhVgPE4AcZuAozHCzB2F2DsIcDYU4DxBAHGXgKMvQUY+wgw9hVg7CfAeKIA40kCjCcLMPYXYDxFgPFUAcbTBBgHCDCeLsA4UIBxkADjYAHGHAHGIQKMQwUYhwkwDhdgzBVgHCHAOFKA8QwBxlECjGcKMI4WYDxLgHGMAOPZAoznCDCeK8A4VoDxPAHGcQKM5wswjhdgnCDAOFGA8QIBxgsFGC8SYJwkwHixAONkAcZLBBinCDBOFWC8VIDxMgHGaQKM0wUYZwgwXi7AeIUA45UCjDMFGK8SYJwlwHi1AONsAcZrBBjnCDBeK8A4V4DxOgHG6wUYbxBgvFGA8SYBxpsFGG8RYJwnwHirAONtAoy3CzDeIcA4X4BxgQDjnQKMdwkw3i3AuFCAcZEA42IBxnsEGO8VYLxPgHGJAOP9AoxLBRgfEGB8UIDxIQHGZQKMywUYVwgwPizAuFKAcZUA42oBxjUCjGsFGNcJMD4iwPioAON6AcYNAowbBRg3CTA+JsD4uADjZgHGLQKMWwUYnxBgfFKA8SkBxm0CjE8LMG4XYNwhwLhTgPEZAcZdAozPCjDuFmB8ToDxeQHGFwQYXxRgfEmA8WUBxlcEGF8VYHxNgPF1AcY3BBjfFGB8S4DxbQHGdwQY3xVgfE+A8X0Bxg8EGD8UYPxIgPFjAcZPBBg/FWD8TIDxcwHGLwQYvxRg/EqA8WsBxm8EGL8VYPxOgPF7AcYfBBh/FGD8SYDxZwHGXwQYfxVg/E2A8XcBxj8EGP8UYPxLgPFvAcZ/BBj/FWDMKOY/4z4CjMUEGIsLMO4rwLifAOP+AowHCDAeKMB4kADjwQKMJQQYDxFgPFSA8TABxsMFGEsKMJYSYCwtwFhGgPEIAcayAoxHCjCWE2AsL8BYQYCxogBjJQHGygKMVQQYqwowVhNgjAkwVhdgrCHAmCnAmCXAWFOAsZYAY20BxjoCjEcJMB4twFhXgLGeAGN9AcYGAowNBRizBRidAGMjAcbGAoxNBBibCjA2E2BsLsDYQoCxpQBjKwHG1gKMxwgwthFgbCvA2E6A8VgBxvYCjB0EGDsKMHYSYOwswNhFgLGrAONxAozdBBiPF2DsLsDYQ4CxpwDjCQKMvQQYewsw9hFg7CvA2E+A8UQBxpMEGE8WYOwvwHiKAOOpAoynCTAOEGA8XYBxoADjIAHGwQKMOQKMQwQYhwowDhNgHC7AmCvAOEKAcaQA4xkCjKMEGM8UYBwtwHiWAOMYAcazBRjPEWA8V4BxrADjeQKM4wQYzxdgHC/AOEGAcaIA4wUCjBcKMF4kwDhJgPFiAcbJAoyXCDBOEWCcKsB4qQDjZQKM0wQYpwswzhBgvFyA8QoBxisFGGcKMF4lwDhLgPFqAcbZAozXCDDOEWC8VoBxrgDjdQKM1wsw3iDAeKMA400CjDcLMN4iwDhPgPFWAcbbBBhvF2C8Q4BxvgDjAgHGOwUY7xJgvFuAcaEA4yIBxsUCjPcIMN4rwHifAOMSAcb7BRiXCjA+IMD4oADjQwKMywQYlwswrhBgfFiAcaUA4yoBxtUCjGsEGNcKMK4TYHxEgPFRAcb1AowbBBg3CjBuEmB8TIDxcQHGzQKMWwQYtwowPiHA+KQA41MCjNsEGJ8WYNwuwLhDgHGnAOMzAoy7BBifFWDcLcD4HIGRwVn+AA5nBpKzUQv753z+c/8l8793rp6R0SX4dA0+xwWfbsHn+ODTPfj0CD49g88JwadX8OkdfPoEn77Bp1/wObF63hgnVc8ftHj+f23QWIGfdUnys65JfnZckp91S/Kz45P8rHuSn/VI8rOeSX52QpKf9Urys95JftYnyc/6JvlZvyQ/OzHJz07K/1kYrPgkaJzdrEmT3OaNcl1jNyS7UcuhLZpmN2k6tFkL18I1bdF0eKMWjRvntmjSonnLoS2bZ7d0TRrnuhFNWzbOHWFX3guSFQ7JyCiGTC6XnR3/4uXeMo7IH+7k6riCip/Xk+PmtRhoXkNme6mz0iG48Wws4y2OjBP25VMXH6dU77c/Keb9ibUUxhwaI5eXS6ixkDE6hRSjU4h1aS8yVwHWpY11CqEugS9cu1OAMT+VFPNT42IeXsXBsa8A1mPUWKfh5rRx/PyhawdZNwNw9+wyMvAm3mJijKgeEd736aT6Ob0Q189A3Jw2SpZLqfqCsOegfcHNQF+A7BGDSDk+iOgL7PBQNWBO2liDCL4AeMjJDQLGfDAp5oP/F7+endrlrCYHEjR+5DDsBpBKbzsDfN/hhe5jOUDvAYy1A86fi58/tFYidXKI5z7QcmUIoVaGkvRyaBp84LDo1092srrJTu1y5p/7VsP6cdtbR3N2BvqC4dU5PQGtaci1TS5Z01Bet7B40xHV/dYFq5Hc6tj8s3vOwHLivajLq7sRDA9O6q8jiWtQ++MQ1YE6ZGONJKxBgX/Ewo0E5v0ZpJifQVyDmg4PI+T/uZ6vQVm+eqzIGnQU0CMAY+3GiqxBkTp5pudrUMuVMwm1Mpqkl6PTsAY9K/r1k1R3U30WEXoM9LMImCdwid4t1TwZQ8rxMUQfaH+AKxOobzbWGIIPBP6hMDcGGPOzSTE/m+gDrSbPImj8eM99IKu3TRDxgecA+xgw1m6CiA9E6uS5nvtAy5VzGWsmkl6OTYMPPC/69UPxgaHHQPtAmCdwid4t1TwZR8rxcUQfaH/ktCZQ32yscQQfCPxjrG4cMObnk2J+PtEHWk2eR9D4izz3gazeNknEB44H9jFgrN0kER+I1MkJnvtAy5UJhFqZSNLLiWnwgRdEv34oPjD0GGgfCPMELtG7pZonF5Jy/EKiD7Q/JF8bqG821oUEHwj8g/fuQmDMLyLF/CKiD7SavICg8VM894Gs3jZVxAdOAvYxYKzdVBEfiNTJiz33gZYrFxNqZTJJLyenwQdeEv36ob2bPAb8brL9jQ80ZxegL5hS3f+YnA2OSVdCTLoCYzJVICbngGNyHCEmxwFjcqlATM4Fx6QbISbdgDG5TCAmY8ExOZ4Qk+OBMZkmEJPzwDHpTohJd2BMpgvEZBw4Jj0IMekBjMkMgZicD45JT0JMegJjcrlATMaDY3ICISYnAGNyhUBMJoBj0osQk17AmFwpEJOJ4Jj0JsSkNzAmMwVicgE4Jn0IMekDjMlVAjG5EByTvoSY9AXGZJZATC4Cx6QfISb9gDG5WiAmk8AxOZEQkxOBMZkNjIk936iZ8d8/sG1n/W3f2fY5bV/N9nFs38DWqbYuMh9uvs98hvU101GrW8sT4wqvfcDzZ38zIJfwLOka4FwWy5/LghdqfNbcXlPdf8Y5aEZ0IoUvwRSWl1au9bwxmFjMAd6vjXdtdU5RQ4sl/4+WXEsQy7mkB+9ziS+n3REMeBTwpQsbay7h5bQ7gHU+F5j315Fifh3x5TTT4UsI+b/I85fTWC/cLBZ5Oe164Ms1wFi7xSIvpyF18gbPX06zXLmBUCs3kvTyxur8l9Nuin79UA4phB4DfUgB5glcondL+R8pIeX4zUQfOD8YsC5Q32ysmwk+cD7QB94MjPktpJjfQvSBVpM3ETR+iec+kNXb7hfxgfOAfQwYa3e/iA9E6uStnvtAy5VbCbVyG0kvb0uDD7w9+vVD8YGhx0D7QJgncIneLeW9NVKO30H0gQuCAesD9c3GuoPgAxcAfeAdwJjPJ8V8PtEHWk3eTtD4hzz3gazetkzEBy4A9jFgrN0yER+I1Mk7PfeBlit3EmrlLpJe3pUGH3h39OuH4gNDj4H2gTBP4BK9W6p5spCU4wuJPvDOYMCGQH2zsRYSfOCdQB+4EBjzRaSYLyL6QKvJuwkav9JzH8jqbatEfOBiYB8DxtqtEvGBSJ28x3MfaLlyD6FW7iXp5b1p8IH3Rb9+KLobvrRcjDAuKrarPZ9De5cx2Rym/AwPmNO+z6HN3xLG80Cgpll8FV+eR84Bi3EpmhGdSOFirLAsnh4AB4TRYJYC79fGs3tmFLVKw3nQz4ZDMdE2fw8yHriQTPRDxE0HVj4tKywGJv9AywOEfFpOyqflxI3Lu4IBHXBBbmMtJ2xc3gXsvcuBvWgFKeYriBpi3ug+Qv6v93zhwtqM2SCycfkwUOOBsXYbRDYukTq50vONS8uVlYxNfpJerkrDxuXq6NcP5QF26DHQD7BhnsAlerdU82QNKcfXEH3g3cGAjYH6ZmOtIfjAu4E+cA0w5mtJMV9L9IFWk6sJGv+45z6Q1ds2i/jAdcA+Boy12yziA5E6+YjnPtBy5RFCrTxK0stH0+AD10e/fig+MPQYaB8I8wQu0bulvC9AyvENRB+4MBiwKVDfbKwNBB+4EOgDNwBjvpEU841EH2g1uZ6g8U967gNZve0pER+4CdjHgLF2T4n4QKROPua5D7RceYyxViTp5eNp8IGbo18/FB8Yegy0D4R5Apfo3VLNky2kHN9C9IGLggGbA/XNxtpC8IGLgD5wCzDmW0kx30r0gVaTmwkav8NzH8jqbTtFfOATwD4GjLXbKeIDkTr5pOc+0HLlScaaiaSXT6XBB26Lfv3Q3o1dRsilZwQOUDDeZ90l0m+eBtYLMNZul0DePE3Im+1A7bXeqnjwBjkHLMYdaEZ0IoWLxsKyyNsJDkgx8LyZYOwA3q+NZ/fMKmq70M3mmeg3G9qhm2cYJoVk9Helweg/W2Rc9oIu78DNTkIu7Sbl0m7ixuriYMCWwA0DG2s3YWN1MbDn7gb2oOdIMX+OuLFqnmgbIf9f9HzBwtoseklkofs8sF8AY+1eEtlYRerkC55vrFquvMDQCJJevpgGv/VS9OuH8oA99BjoB+wwT+ASvVuqefIyKcdfJvrAe4IBWwP1zcZ6meAD7wH6wJeBMX+FFPNXiD7QavIlgsa/5rkPZPW210V84KvAPgaMtXtdxAcidfI1z32g5cprjFoh6eXrafCBb0S/fig+MPQYaB8I8wQu0bulmidvknL8TaIPvDcYsA1Q32ysNwk+8F6gD3wTGPO3SDF/i+gDrSbfIGj82577QFZve0fEB74N7GPAWLt3RHwgUiff8dwHWq68Q6iVd0l6+W4afOB70a8fig8MPQbaB8I8gUv0bqnmyfukHH+f6APvCwZsB9Q3G+t9gg+8D+gD3wfG/ANSzD8g+kCryfcIGv+B5z6Q1ds+FPGBHwL7GDDW7kMRH4jUyY8894GWKx8RauVjkl5+nAYf+En064d24OZZQi59JHBwgvEu68ci/eZTYL0AY+0+FsibTwl58xlQe623Kh64Qc4Bi/FzNCM6kcJFY2FZ5H0BDkgx8LyZYHwOvF8bz+6ZVdR2oZvNl9FvNrQDN18Sms1XJKP/VRqM/tdFxmUv6PIO3HxByKVvSLn0DXFjdUkwYHvghoGN9Q1hY3UJsOd+A+xB35Ji/i1xY9U80SeE/P/S8wULa7PoK5GF7nfAfgGMtftKZGMVqZPfe76xarnyPaFWfiDp5Q9p8Fs/Rr9+KA/YQ4+BfsAO8wQu0bulmic/kXL8J6IPvD8YsCNQ32ysnwg+8H6gD/wJGPOfSTH/megDrSZ/JGj8d577QFZv+17EB/4C7GPAWLvvRXwgUid/9dwHWq78SqiV30h6+VsafODv0a8fig8MPQbaB8I8gUv0bqnmyR+kHP+D6AOXBgN2BuqbjfUHwQcuBfrAP4Ax/5MU8z+JPtBq8neCxv/suQ9k9bZfRHzgX8A+Boy1+0XEByJ18m/PfaDlyt+EWvmHpJf/pMEH/hv9+qH4wNBjoH0gzBO4RO+Wap5k1ODkuI0byx8XrW0PBAN2BeqbjWW8aB/4ANAHxscp1fvdhxTzfWrwfKDV5L8Ejf/Dcx/I6m1/ivjAYrhcdcBYuz9FfCBSJ4vXwN4zulYsV4wRXSv7kvRy3xp8H7hf9OuHduDma4Lu/iVwcILxLuvfIv1mf2C9AGPt/hbIm/0J2nsAUHuttyoeuEHOAYvxQDQjOpHCRWNhWeQdBA5IMfC8mWAcCLxfG8/umVXUdqGbzcHRbza0AzcHE5pNCZLRL5EGo39IkXHZC7q8AzcHEXLpUFIuHUrcWH0wGLAbcMPAxjqUsLH6ILDnHgrsQYeRYn4YcWPVPNF+hPwvPtzvBQtts2i4hvc4HNgvgLF2wPmjbqwidbKk5xurlislCbVSiqSXpdLgt0pHv34oD9hDj4F+wA7zBC7Ru6WaJ2VIOV6G6AMfCgbsDtQ3G6sMwQc+BPSBZYAxP4IU8yOIPtBqsjRB4w/03AeyettBIj6wLLCPAWPtDhLxgUidPNJzH2i5ciShVsqR9LJcGnxg+ejXD8UHhh4D7QNhnsAlerdU86QCKccrEH3gsmDAnkB9s7EqEHzgMqAPrACMeUVSzCsSfaDVZHnGfrjnPpDV2w4T8YGVgH0MGGt3mIgPROpkZc99oOVKZUKtVCHpZZU0+MCq0a8fig8MPQbaB8I8gUv0bqnmSTVSjlcj+sDlwYC9gPpmY1Uj+MDlQB9YDRjzGCnmMaIPtJqsStD40p77QFZvKyPiA6sD+xgw1q6MiA9E6mQNz32g5UoNQq1kkvQyMw0+MCv69UM7cHMIIZeO8Py+We+ylhXpNzWB9QKMtSsrkDc1CXlTC6i91lsVD9wg54DFWBvNiE6kcNFYWBZ5dcABKQaeNxOM2sD7tfHsnllFbRe62RwV/WZDO3BzFKHZHE0y+kenwejXLTIue0GXd+CmDiGX6pFyqR5xY3VFMGAf4IaBjVWPsLG6Athz6wF7UH1SzOsTN1bNE2UR8r+S5wsW1mZRZZGFbgNgvwDG2lUW2VhF6mRDzzdWLVcaEmolm6SX2WnwWy769UN5wB56DPQDdpgncIneLdU8aUTK8UZEH/hwMGA/oL7ZWI0IPvBhoA9sBIx5Y1LMGxN9oNWkI2h8zHMfyOpt1UV8YBNgHwPG2lUX8YFInWzquQ+0XGlKqJVmJL1slgYf2Dz69UPxgaHHQPtAmCdwid4t1TxpQcrxFkQfuDIY8CSgvtlYLQg+cCXQB7YAxrwlKeYtiT7QarI5QeNreu4DWb2tlogPbAXsY8BYu1oiPhCpk60994GWK60JtXIMSS+PSYMPbBP9+qH4wNBjoH0gzBO4RO+Wap60JeV4W6IPXBUM2B+obzZWW4IPXAX0gW2BMW9Hink7og+0mmxD0PijPfeBrN5WV8QHHgvsY8BYu7oiPhCpk+0994GWK+0JtdKBpJcd0uADO0a/fmgHbuoScqmewMEJxrus9UX6TSdgvQBj7eoL5E0nQt50Bmqv9VbFAzfIOWAxdkEzohMpXDQWlkVeV3BAioHnzQSjC/B+bTy7Z1ZR24VuNsdFv9nQDtwcR2g23UhGv1sajP7xRcZlL+jyDtx0JeRSd1IudSdurK4OBjwVuGFgY3UnbKyuBvbc7sAe1IMU8x7EjVXzRB0J+d/Y8wULa7OoichCtyewXwBj7ZqIbKwidfIEzzdWLVdOINRKL5Je9kqD3+od/fqhPGAPPQb6ATvME7hE75bywTxSjvch+sA1wYADgPpmY/Uh+MA1QB/YBxjzvqSY9yX6QKvJ3gSNb+G5D2T1tpYiPrAfsI8BY+1aivhApE6e6LkPtFw5kVArJ5H08qQ0+MCTo18/FB8Yegy0D4R5Apfo3VJ+EYeU4/2JPnBtMOBAoL7ZWP0JPnAt0Af2B8b8FFLMTyH6QKvJkwka38ZzH8jqbW1FfOCpwD4GjLVrK+IDkTp5muc+0HLlNEKtDCDp5YA0+MDTo18/FB8Yegy0D4R5Apfo3VLWCVKODyT6wHXBgIOB+mZjDST4wHVAHzgQGPNBpJgPIvpAq8nTCRrfwXMfyOptHUV84GBgHwPG2nUU8YFInczx3AdaruQQamUISS+HpMEHDo1+/dAO3BxPyKVOAgcnGO+ydhbpN8OA9QKMtesskDfDCHkzHKi91lsVD9wg54DFmItmRCdSuGgsLIu8ETWwASmGTphAMOKTBnHgxu6ZVdR2oZvNyBqRbza0Azc2d2iNOANYM/FG38aNZSRe6FwaFf1coh24GUHIpTNJuXRmDd7G6iPBgEOAGwY2lvGie65xosY6E9iDRpNiProGb2PVPNFQQv5393zBwtos6iGy0D0L2C+AsXY9RDZWkTo5pgb2ntG1YrkyhlArZ5P08uw0+K1zol8/lAfsocdAP2CHeQKX6N1SzZNzSTl+LtEHPhoMOAyobzbWuQQf+CjQB54LjPlYUszHEn2g1eQ5BI3v7bkPZPW2PiI+8DxgHwPG2vUR8YFInRznuQ+0XBlHqJXzSXp5fhp84Pjo1w/FB4YeA+0DYZ7AJXq3VPNkAinHJxB94PpgwFygvtlYEwg+cD3QB04AxnwiKeYTiT7QanI8QeNP8twHsnrbySI+8AJgHwPG2p0s4gOROnmh5z7QcuVCQq1cRNLLi9LgAydFv34oPjD0GGgfCPMELtG7pZonF5Ny/GKiD9wQDDgSqG821sUEH7gB6AMvBsZ8Minmk4k+0GpyEkHjT/PcB7J62wARH3gJsI8BY+0GiPhApE5O8dwHWq5MIdTKVJJeTk2DD7w0+vVDO3AzipBLpwscnGC8yzpQpN9cBqwXYKzdQIG8uYyQN9OA2mu9VfHADXIOWIzT0YzoRAoXjYVlkTcDHJBi4HkzwZgOvF8bz+6ZVdR2oZvN5dFvNrQDN5cTms0VJKN/RRqM/pVFxmUv6PIO3Mwg5NJMUi7NJG6sbgwGHAXcMLCxZhI2VjcCe+5MYA+6ihTzq4gbq+aJLiXk/zDPFyyszaLhIgvdWcB+AYy1Gy6ysYrUyas931i1XLmaUCuzSXo5Ow1+65ro1w/lAXvoMdAP2GGewCV6t1TzZA4px+cQfeCmYMDRQH2zseYQfOAmoA+cA4z5taSYX0v0gVaT1xA0/gzPfSCrt40S8YFzgX0MGGs3SsQHInXyOs99oOXKdYRauZ6kl9enwQfeEP36ofjA0GOgfSDME7hE75ZqntxIyvEbiT7wsWDAMcg/LHFIHi/aBz4G9IE3AmN+EynmNxF9oNXkDQSNH+O5D2T1trNFfODNwD4GjLU7W8QHInXyFs99oOXKLYRamUfSy3lp8IG3Rr9+KD4w9BhoHwjzBC7Ru6WaJ7eRcvw2og98PBjwHKC+2Vi3EXzg40AfeBsw5reTYn470QdaTd5K0PjzPPeBrN42TsQH3gHsY8BYu3EiPhCpk/M994GWK/MJtbKApJcL0uAD74x+/dAO3FxJyKXzBQ5OMN5lHS/Sb+4C1gsw1m68QN7cRcibu4Haa71V8cANcg5YjAvRjOhECheNhWWRtwgckGLgeTPBWAi8XxvP7plV1Hahm83i6Dcb2oGbxYRmcw/J6N+TBqN/b5Fx2Qu6vAM3iwi5dB8pl+4jbqxuDgYcC9wwsLHuI2ysbgb23PuAPWgJKeZLiBur5onuJOT/JM8XLKzNootFFrr3A/sFMNbuYpGNVaROLvV8Y9VyZSmhVh4g6eUDafBbD0a/figP2EOPgX7ADvMELtG7pZonD5Fy/CGiD9wSDDgO+S83HJLHi/aBW4A+8CFgzJeRYr6M6AOtJh8kaPxUz30gq7ddKuIDlwP7GDDW7lIRH4jUyRWe+0DLlRWEWnmYpJcPp8EHrox+/VB8YOgx0D4Q5glcondLNU9WkXJ8FdEHbg0GHA/UNxtrFcEHbgX6wFXAmK8mxXw10QdaTa4kaPwMz30gq7ddLuID1wD7GDDW7nIRH4jUybWe+0DLlbWEWllH0st1afCBj0S/fig+MPQYaB8I8wQu0bulmiePknL8UaIPfCIYcCJQ32ysRwk+8AmgD3wUGPP1pJivJ/pAq8lHCBp/lec+kNXbZon4wA3APgaMtZsl4gOROrnRcx9oubKRUCubSHq5KQ0+8LHo1w/twM29hFy6WuDgBONd1tki/eZxYL0AY+1mC+TN44S82QzUXuutigdukHPAYtyCZkQnUrhoLCyLvK3ggBQDz5sJxhbg/dp4ds+sorYL3WyeiH6zoR24eYLQbJ4kGf0n02D0nyoyLntBl3fgZishl7aRcmkbcWP1yWDAC4EbBjbWNsLG6pPAnrsN2IOeJsX8aeLGqnmixwj5f73nCxbWZtENIgvd7cB+AYy1u0FkYxWpkzs831i1XNlBqJWdJL3cmQa/9Uz064fygD30GOgH7DBP4BK9W6p5souU47uIPvCpYMBJQH2zsXYRfOBTQB+4CxjzZ0kxf5boA60mnyFo/C2e+0BWb5sn4gN3A/sYMNZunogPROrkc577QMuV5wi18jxJL59Pgw98Ifr1Q/GBocdA+0CYJ3CJ3i3VPHmRlOMvEn3gtmDAyUB9s7FeJPjAbUAf+CIw5i+RYv4S0QdaTb5A0Pg7PPeBrN42X8QHvgzsY8BYu/kiPhCpk6947gMtV14h1MqrJL18NQ0+8LXo1w/FB4YeA+0DYZ7AJXq3VPPkdVKOv070gU8HA04B6puN9TrBBz4N9IGvA2P+BinmbxB9oNXkawSNv9tzH8jqbQtFfOCbwD4GjLVbKOIDkTr5luc+0HLlLUKtvE3Sy7fT4APfiX790A7cPEXIpUUCBycY77IuFuk37wLrBRhrt1ggb94l5M17QO213qp44AY5ByzG99GM6EQKF42FZZH3ATggxcDzZoLxPvB+bTy7Z1ZR24VuNh9Gv9nQDtx8SGg2H5GM/kdpMPofFxmXvaDLO3DzASGXPiHl0ifEjdXtwYCXAjcMbKxPCBur24E99xNgD/qUFPNPiRur5oneIeT/Us8XLKzNogdEFrqfAfsFMNbuAZGNVaROfu75xqrlyueEWvmCpJdfpMFvfRn9+qE8YA89BvoBO8wTuETvlmqefEXK8a+IPnBHMOA0oL7ZWF8RfOAOoA/8Chjzr0kx/5roA60mvyRo/HLPfSCrt60Q8YHfAPsYMNZuhYgPROrkt577QMuVbwm18h1JL79Lgw/8Pvr1Q/GBocdA+0CYJ3CJ3i3VPPmBlOM/EH3gzmDAGUB9s7F+IPjAnUAf+AMw5j+SYv4j0QdaTX5P0PjVnvtAVm9bI+IDfwL2MWCs3RoRH4jUyZ8994GWKz8TauUXkl7+kgYf+Gv064fiA0OPgfaBME/gEr1bqnnyGynHfyP6wGeCAa8A6puN9RvBBz4D9IG/AWP+OynmvxN9oNXkrwSNf9RzH8jqbetFfOAfwD4GjLVbL+IDkTr5p+c+0HLlT0Kt/EXSy7/S4AP/jn790A7cfEzIpQ0CBycY77JuFOk3/wDrBRhrt1Egb/4h5M2/QO213qp44AY5ByzGjEwwIzqRwkVjYVnk7QMOSDHwvJlgxCcN4sCN3TOrqO1CN5timZFvNrQDNzZ3aI0oDqyZeKNv48YyEi90Lu0b/VyiHbjZh5BL+5Fyab9M3sbqrmDAmcANAxvLeNE9dxew5+4H7EH7k2K+fyZvY9U80d8E477V8wULa7PoCZGF7gHAfgGMtXtCZGMVqZMHZmLvGV0rlisHEnrkQSS9PCgNfuvg6NcP5QF76DHQD9hhnsAlerdU86QEKcdLEH3gs8GAs4D6ZmOVIPjAZ4E+sAQw5oeQYn4I0QdaTR5M0PinPfeBrN62XcQHHgrsY8BYu+0iPhCpk4d57gMtVw4j1MrhJL08PA0+sGT064fiA0OPgfaBME/gEr1bqnlSipTjpYg+cHcw4GygvtlYpQg+cDfQB5YCxrw0KealiT7QarIkQeN3ee4DWb3tWREfWAbYx4Cxds+K+ECkTh7huQ+0XDmCUCtlSXpZNg0+8Mjo1w/FB4YeA+0DYZ7AJXq3VPOkHCnHyxF94HPBgHOA+mZjlSP4wOeAPrAcMOblSTEvT/SBVpNHEjT+Bc99IKu3vSjiAysA+xgw1u5FER+I1MmKnvtAy5WKhFqpRNLLSmnwgZWjXz+U94HtPTzkO4ysd0SrZPrdv+y+qxDuuyrwvi13FA9iVM30n7Ga7wcxwsVEYTH/MYGDGNXABzFipIMY6Hu3PEQ2bJYhqk4QHrvQ5qcGcC57DMON1RM3Vva+wRj7xeVi/IUWc1bcM7CcTeLnIjO/9rPi6oDickBjJawQDL5q/vfwZ1lxO1XhhW5ewPtxWUAxr4lLwMbxc1ozbk4ZuVGdIMJvkFdQqe2kjxhu950JbuRZmfj4IOexSIz/x5UgxrXyxbh2ZkaiqNVKInT2f1RwItFCVz0Tl/C1gMleOxOblPtnxHW/DF5SIrnjeetkEoHrEFTlKGAysO77KNKyKLzQe9m1gXN6NC5RmySLD6LbHZXJWV6jGOt6vvdoMa5LcF71SM8D6uU/D0inYB+Na4C58bz1M4nA9TPhdjW3PnCvoIHn4m9z2ABYGOEcNhB1LcAiGBHP25BZBA3xRTCiIbAIsgWKIBtfBCOyyV0R0bUbEJxFXWC8ncfOYoRBBnwOPYcu8b5TncNGnruzTJI7a1z0ZNg1zvSfsQn7yXD23l4u7z91wS4pTNC3PX/l0ESoEeG+3xF55bAp0AQBY+3eAW9Up8tdA+czYU+wWSYRuBlhT7C5547Y7rs5aU8QzVqXxJrOJzjoDghzowUaIOp+w8aCjll8rFrkj98yk/i4vy5Y0cINwBb5G4DxP2uZ/7P4a78C94PcyE11rJbAsVoVgk4cH+tWmfwXwlsXgjnNyMDXvNVma8K2CbJejvG1oeRde3SzSSZWt44RMiwtRVjDrRmftwjbkHpwm7iHcAWNIPqBdjjPyPnNzORwosYC3K8Lv2QkuVBjx8e9bX7dtiv42lLbfJcZ/7N2SZr4viIB2cuxGuWP5doCudqBE4XxXmdbwjbZsZ7v2w+3N0jStPIuElyvBDfhpDIo/kkFt31+fnUoKLjtkwhuh0IsuO2BXB3AicIQ3PYEwe3oueBOCe67Y5Hg2lXYBLdRRpILNHaC4HbKz6/OBQW3UxLB7VyIBbcTkKszOFEYgtuJILhdPBfcqcF9dykSXLsKm+A2zkhygcZOENyu+fl1XEHB7ZpEcI8rxILbFch1HDhRGILblSC43TwX3EuD++5WJLh2FTbBbZKR5AKNnSC4x+fnV/eCgnt8EsHtXogF93ggV3dwojAE93iC4PbwXHAvC+67R5Hg2lXYBLdpRpILNHaC4PbMz68TCgpuzySCe0IhFtyeQK4TwInCENyeBMHt5bngTgvuu1eR4NpV2AS3WUaSCzR2guD2zs+vPgUFt3cSwe1TiAW3N5CrDzhRGILbmyC4fT0X3OnBffctEly7CpvgNs9IcoHGThDcfvn5dWJBwe2XRHBPLMSC2w/IdSI4URiC248guCd5Lrgzgvs+qUhw7SpsgtsiI8kFGjtBcE/Oz6/+BQX35CSC278QC+7JQK7+4ERhCO7JBME9xXPBvTy471OKBNeuwia4LTOSXKCxEwT31Pz8Oq2g4J6aRHBPK8SCeyqQ6zRwojAE91SC4A7wXHCvCO57QJHg2lXYBHdIRpILNHaC4J6en18DCwru6UkEd2AhFtzTgVwDwYnCENzTCYI7yHPBvTK470FFgmtXYRPcoRlJLtDYCYI7OD+/cgoK7uAkgptTiAV3MJArB5woDMEdTBDcIZ4L7szgvocUCa5dhU1wh2UkuUBjJwju0Pz8GlZQcIcmEdxhhVhwhwK5hoEThSG4QwmCO9xzwb0quO/hRYJrV2ET3OEZSS7Q2AmCm5ufXyMKCm5uEsEdUYgFNxfINQKcKAzBzSUI7kjPBXdWcN8jiwTXrsImuLkZSS7Q2AmCe0Z+fo0qKLhnJBHcUYVYcM8Aco0CJwpDcM8gCO6Zngvu1cF9n1kkuHYVNsEdkZHkAo2dILij8/PrrIKCOzqJ4J5ViAV3NJDrLHCiMAR3NEFwx3guuLOD+x5DEFwGa4VDMjJqEGL0gci/NHM2sLkA/xlzFz9/e3uPef8c3jCXzn9pBjifCf/SzDmZROBzMvHjngsUetZ9n0sSqfBCuyzknI4FFn78PaMF6jwBgcpO8Uq2kkDnu8X7PHK+g8duEj8f4/LZzy/osO1/qFrgZ+fHLXFYE4kq7vx/tHX4OGBxnw/sQnafiv8A5bhM/xnHIxmLVCTplaAiE/LZJxZUkQlJVGSioIpMAKrIxExOgNG2aCLwni/A3XOT+Fy6IH/PJ53/uB/sXhyxQF3iRtqF+QV6UcECtf+hfIGf2f/RgQWgihMnMbXizHYXAhP1ImBw07lAvghXYAkL5EmZROBJhAXyxZ4vkO2+LyY9Nvm/SLZU5ziedzIz2SYTns9MBq6iLxFI3EsIW7qXZGKLIF02ALrISHJBxi5gA6bkF9jUuDjCA3oxsCjibcmUJFbFbuSgAhOH3ipD3s9UYJFfCrQq8XN6adyconNjfH73Q4/7Ifi5UMFGkZ3K5fJyaEom1uVYLu2L5Cwgaqna8inAXJ8KnLsPhxde15W/nzEinvcypuu6DL8ZM+IyYDJME3Bd04CCGc7hNM9fdrg4320ymznSuaY61nRgThe54ERG+3/i52JGvuBd/r+54OzULgcMaII7M/iSGYku2G6kVIGJQ2/YIRP0cmDhXAHiCrtiOKdXxM0pei6taKaDunl2fmxmgMXo8qI9qrBZ5sbzXsl0S1fi3VLulcDCnSnglmbi3VLuTLJbSnUup+ULCnTZWkD0U2W8qmifj+Nw8l+2jp+LWfkidTXT4SADGt95Z+U/foz/md1IhQITh+7KwPtxVwMLZzaE67/r/nBOZ8fNKcPhXAXpwHnj2VizwGJ0NcHhMOpsZv5copvGNZ5vAYRNDX3fczy/b8vzawj3fa3nJibc8kGbGOQ2zVzwHKLv1VaBwPzeo7vXEnLxOpKpQj/gR24XXg+MCyN37HkNML/3LB6uI+TODT7rt8uL8w2E+/5e5OzbjcBniMBndQ49f+i+b7V3IyFvbiKt02zcWEbihc6lm4G7pLBccvhaROeSeYCbCbl0CymXbklDLs0DrkdBubRn68b3XLK1yDxCLt1KyqVb43JJZS5u83xdYesAICNNn27P1PBIdwDXFR8mnOkP/m+HNGrSLLdpdrPcFi1b5LZsPqJp8+xhQ0aMGN48u8mwodlDhzZplt3YNR4xtHmj7KGNWga/tmVu02F7pAjukRgPJIAxpnmu+SLrW+QZrwW4e24cr+cLMtN/xgt2L2k843Vn/n72XZkZiQ9P7H8o+OL0XZn8M14LgAvBO4GJehcwuOl8peGuTKxhCq+7M4nAd2fix13o+WsIdt8LM/87waBx/8+SDXnGaxEz2RZl4lvkIqDdWCyQuIsJdmhxZuEtgmSv3N/DLIJ7MvGv3N8DLIJ7BYrgXvxLZCPu9fy588L84kevdZHdGimg9wFzWlSUEt5sXcIUpSV4UcpdAgzg/QKidD9elHLv9/ylEBPN+wgvhdwHjPdST4W9Rf5/LcZLCa7uAW83rfPuPMwdVM7YHD5AmMcHRTYLkY38IfLLMKnoYos4M4RitDx8EKxjluVIQ7QMnIfFgfeanX8m9A5gTOxFHeBGvbOcXgbvVS2gdbec9NB1ef4mvd078c9a/udv4qL9lcKftVyOZkQDhn99Ed0gVwCLND5pV+zFkyUP7iX/wE/jFklwQWMnPll6OH9luLLgk6WH84Md/7OVmfxXeVakroj/+aczHgaq60pScNFJuAqoJGTFp6npKgHFX01aGcATag1QoVUTao1AQq1VSah1ONBGqgm1TiChHlFJqEeBbyepJtSjAgm1XiWhNuBAm6gm1AaBhNqoklCbcKBNVRNqk0BCPaaSUI/jQJupJtTjAgm1WSWhtuBAm6sm1BaBhNqqklBP4EBbqCbUEwIJ9aRKQj2FA22pmlBPCSTUNpWEehoHOkQ1oZ4WSKjtKgm1Awc6VDWhdggk1E6VhHoGBzpMNaGeEUioXSoJ9SwOdLhqQj0rkFC7VRLqORxormpCPSeQUM+rJNQLONARqgn1gkBCvYhmLAYGbFw9I6NTddx4rYOxOlbHJ/xL3p602HO5JuB5PIY0jy97Po9NwfPYhjSPr3g+j83A89iWNI+vej6PzcHz2I40j695Po8twPN4LGkeX/d8HluC57E9aR7f8HweW4HnsQNpHt8En1Yqk5HHuDr/jIJ9Xxv3/ZG47+vjvm+M+/5Y3PfNcd+3xn1/Mu77trjv2+O+74z7vivu++6478/HfX8x7vtLcd9fjvv+Stz3V+O+vxb3/fW472/EfX8z//tbwX/fDj7vBJ93g897wef94PNB8PkwM++wjOVj8fy4xC+g0AsIO5uxIv/wCXDchNUpmrn8AdicDRlL5n//KJiPj4PPJ8Hn0+DzWfD5PPh8EXy+DD5fBZ+vg883wefb4PNd8Pk++PwQfH4seIDno7gECH/2cZKffZLkZ58m+dlnSX72eZKffZHkZ18m+dlXSX72dZKffZPkZ98m+dl3SX72fZKf/ZDkZz/m/8z+/7WRAclIfgJNsZjAYzeJn4+f8tl/LpjE9j9ULfAz+z8qRppIm8SHM+F/z2T4T5m4zvkzsHMWJWfSKyE5f8ln/7Vgcv6SJDl/FUzOX4DJ+Ss4OdP1l5eQ3PG8v2USgW1w9Li/A5OBdd+/k9SExVq8wLjIIku1+JHx/gNXRE3iRfWPfHv2/48geCRkLp73z0wi8J+Z+A2FP4ET8RdZXBBz+BdBVP/6P+qKHhVBo3jev5lF8De+CBr9DSyCfwSK4B98ETT6J9Pvbv17fvGjuzWywyIF9F9gTqPjYf+sl+XLv+hadon3nXL9ZXFzOlW+n/IdKNoUIPcz9gHOod1n7Yz/eSFjhM71bHOIWf4zFkMzopI9/Jfbfv9/uLdUE/SwXL8blwmaCRH6vg/PxSelXfui7j//D2ohm2JxXJI7YN44ZCzSua8GnM+EfbV9s4jA+2bhx90vy+99Nbvv/bL+O8GgcSmuxoR+P3KMslO80vlPmqE7M+4BQx5f2JhR9/v/anjZe3slaSTZKV7xcd8/v64OiGOmFAVqguM3Xw0+lpH4lOuA/J8pJQvMdWT/l5OReKnmwQHARnMgcKz4/DkwLn/Cy2dXeFAhcIUZGfjGZNphc4fefkDm+MGEpbddKF1kbCOWAOYzI2/M0JQgrGhLkesFkYslCMa2lOc6cUD+fWdgx6Ww2tZnCYKmlQBq2iHgVXfYtw/J+u+D+IKLG7TehfOMGs/08yfC7iBAS//zl/kzklyoseNjdWh+rR2WlZFo7A/NF5/4nx0WZ9ZYzyfQ45bxXOjD5EaPewRpy3Y/MCegsP/zrzwcChSJw4DGCJiDDhDXBJFBN0V7Uf5QQgMvajSURuMyklygsRMazeH5OVGyYKM5PEmjKZlkV8Bn4TkcmDQloy88lJWinc45vEh49lwCwtMoI8kFGjtBeErl50TpgsJTKonwlBYTnlLApCkdfeHZk3Ro4bEjgaWKhGfPJSA8jTOSXKCxE4SnTH5OHFFQeMokEZ4jxISnDDBpjoi+8OxJOrTw2DnkMkXCs+cSEJ4mGUku0NgJwlM2PyeOLCg8ZZMIz5FiwlMWmDRHRl949iQdWnjsjx+ULRKePZeA8DTNSHKBxk4QnnL5OVG+oPCUSyI85cWEpxwwacpHX3j2JB1aeOwvrpQrEp49l4DwNMtIcoHGThCeCvk5UbGg8FRIIjwVxYSnAjBpKkZfePYkHVp47M88VSgSnj2XgPA0z0hygcZOEJ5K+TlRuaDwVEoiPJXFhKcSMGkqR1949iQdWnjsb8tVKhKePZeA8LTISHKBxk4Qnir5OVG1oPBUSSI8VcWEpwowaapGX3j2JB1aeOwPWlYpEp49l4DwtMxIcoHGThCeavk5ESsoPNWSCE9MTHiqAZMmFn3h2ZN0aOGxv6JbrUh49lwCwjMkI8kFGjtBeKrn50SNgsJTPYnw1BATnurApKkRfeHZk3Ro4bE/3V29SHj2XALCMzQjyQUaO0F4MvNzIqug8GQmEZ4sMeHJBCZNVvSFZ0/SoYXH/r2AzCLh2XMJCM+wjCQXaOwE4amZnxO1CgpPzSTCU0tMeGoCk6ZW9IVnT9Khhcf+kZKaRcKz5xIQnuEZSS7Q2AnCUzs/J+oUFJ7aSYSnjpjw1AYmTZ3oC8+epEMLj/3LSLUJwsNgZR3QPgqXO3uKt2bG/7yQ88qYW+QcsBiPRjOiAdH/GBDy3xYJx6qb5XeRW4HXJRR5PeB9xzfdeln/77/EkZ3a9Z98Qs9FfeBcJHOYGaT5OJogUvEXZGyX6OAa5DfXhln/y9+ZzE7tciVIyW3w5TMSXabdyEEFJq64v/fjGgJdZjaMa8SI+DnNjptTRm4cTRDUTPCftUE1zbx/RCvvvhsAY2/jNczCxwc5j0VinMho/0/8XLh8MW6kKMYGXzIjUYztRkoVmDifxbgRsCAbg7hMLuLntHHcnCJFKZxLBxalRkWi9B9u70UpfzMnfi6a5ItSU0VRMvgDMxJFyW6kQoGJ81mUmgILshmEK+/fAY2f02Zxc4oTpez/zGUTsCg1jZAoIbdvsvfuSvtfI22eL0otCj54aJ7kwUOLJA8eihMnMdUHD82Byd4C91QprZ0SuA/I+HMa/xk7fi5a5idlq4JJaf9DwX/13f6Piv1/Scrs1K6ESUxtvTpieEtgUrYiBRe9sd0KeM+tcfec9G8EIbpi8yy//0b5MZ4/HLAYH0PYy2pDcsdt8htjOoUdVgcufZvkbfOFvV1BYW+bZAO6Xf6SI/5CC3trmLBnu7bAAm0HDK4lZbr+ycF24AL7TzJmMYEJa5j2wGRg3Xf7rLgJxoz7f5ZsiH8hK7w6MJOtQxbeXnUAbpJ0FEjcjgRr0JFsiRCWrT3BVh4DjHenrMIrJPnLuxHxvJ2ZQtI5C/0sdcSIzkAh6SIgJF2AQhLOYRfPhcSErhNBSDoB4921SEhy43mPYwrJcXghyT0OKCTdBISkG15Icrt5LiQmdF0JQtIVGO/jPd/oshgfT3Cz3T2/7zB30Pfdw/P7tsev3Qn33dPz+w5NB/q+TwDfN1rL7B0gYE4604qehHns5Xn+hKtf9H339jx/7MVWYI7v6a29CPPYB2zY/7+dZc1O7dqzWAEyO8ujownbqRlJLsjYBR7M9M1n71fwwUzfJA9m+sU9mEEHxiYRWJT/CTR2gZPt+gJNaj/Pxbdu/tNYn7ceTyQ92T0x/8lu/IXevkfOw0nA2mHUtx36Bx5Lox0jPNnnmnR5OdOPcN/9Pdcii3d/wn2fQtKPU7J4x0ZZOXAq2cxl/D/mw6P3b9P2jzSflm+8BhQ0Xqdl/c/3bwdkab1/exqwsQ3IwgU3HSuM0DShxrPGfnIWR0RAY/FWKwXeDz49v2gGFiwa+x8Kvh88MM65spwxWska5frdhf9fyZjyUb9cTjLuB75/hGMP3wc/HSiSA4GCA8xBx4oreiU2EBiLQbhY0N5TPy3L7/fUB3u+GrEYDyboYA5pNZKTlf731GF1kMb31IfkG4yhBQ3GkCTboUOz+O+pD4I1nGw3BFigQ4HBtaRM14s6Q8EFFl7DsojAwwj2f7jnL9fYfQ/P+u8Eg8b9P0s25Hvqucxky83C26tcoD0dIZC4IwjWYATZEiEs23CCrRwMjPfIrMIrJMneUz+DKSRnZOHfUz8DKCSjBIRkFFBIwjkc5bmQmNCNJAjJSGC8zywSkoT31EczhWQ0XkhyRwOF5CwBITkLLyS5Z3kuJCZ0ZxKE5ExgvMd4vtFlMR5DcLNne37fYe6g7/scz+/b3lM/m3Df53p+36HpQN/3WPB9o7XM3lMH5qQzrTiXMI/neZ4/4eoXfd/jPM8fe08dmON7eut5hHk8n/xqE2OxAmR2lkfK76mPz2efUPDBzPgkD2YmZHHfUwcW5X8CjV3gZLvxQJM6wXPx7U96Gtva87dx7J4nEO77GNJbG+hXFicC6xAYa4ecv3hdm5j/FD/+Qj+qQW63XwCMT7J7zU7t2nMmAfjOM+0d9QuzOPW4L3g+kedZLor+G217cprREy4i5OAk0ptJk5Joms95eXH085Jybsl6wYWEvGyXmx5tTJVzMvCFKZhXcVCv59p57petP08m5OAlJG285P8HbUyVfYqAh26cHdzDkEZNmuU2zW6W26Jli9yWzUc0bZ49bMiIEcObZzcZNjR76NAmzbIbu8YjhjZvlD20UctgOlrmNh225+QPNC+Tbf6El8fn2holwUWNnbBRMzV/o+bSghs1U7P+57m2S7O0zrVNBRqJS7NwwU3HjmRoLFHjmSG4WGlHssBZtMvy2acVTHT7HwqeRZuWxTuLxnL8x3rezcMEQt93e88dZXh+7DKgGE0DFjYwb1x7kfNj04CxmI6LBe382NQsv8+PzfD8iYXFeAZBuy4nrUQuz0r/+TFYHaTx/NgV+abgyoKm4IokjymvzOKfH5sOe+Ez210BLNArgcG1pEzXC7RXggssvGZmEYFnZuHHvQqYDKz7voqwvPi/Sjbk+bFZzGSblYW3V7OA9vRqgcS9mmANriZbIoRlu4pgK2cA4z07q/AKSbLzY9cwheSaLPz5sWuAQjJHQEjmAIUknMM5nguJCd1sgpDMBsb72iIhSTg/NpcpJHPxQpI7Fygk1wkIyXV4Icm9znMhMaG7liAk1wLjfb3nG10W4+sJbvYGz+87zB30fd/o+X3b+bEbCPd9k+f3HZoO9H3fDL5vtJbZ+TFgTjrTipsI83iL5/kTrn7R9z3P8/yx82PAHN/TW28hzOOtYMPOflvDtAjI7CyPlM+P3ZbPfnvBBzO3JXkwc3sW9/wYsCj/E2jsAifb3QY0qbd7Lr6TSU9jj/P8DRq759sJ991N5PzYHcA6BMbadSOdH7sj/yl+/IV+VIPcbp8PjE+ye81O7dpzfgz5/jTr/fQFWRr1eGf030KjnPmymruTkDd3kd4muiuL/9r33dHPJco5LdPcBYRc6iFyTmsh8MWk44DntICewPUQOKe1kJCDi0h6tiiLf05rsYBXTfWcVo+ic1qNk+Cixk7YELknf0Pk3oIbIvdk/c9zWvemoWEjz2ndA1yE3JuFC246dv5CM4gazwzB3Uo7fwXOad2Xz76kYKLb/1DwnNaSuJ00lcCAX20Yfh+weJaQVp7oXYslwHu+H3fPtPM792T5fX5nqec7xhbjpQSH+gDJoT6Qlf7zO7A6SOP5nQfzm8VDBZvFg0keEz2UxT+/cz/shbts9yCwQB8CBteSMl0vMD4ELrDwWpZFBF6WhR93uecvHdp9LyfYzv+rZEOe31nBTLYVWXh7tQJoex8WSNyHCdbgYbIlQli25QRbuRQY75VZhVdIkp3fWcUUklX4temIVUAhWS0gJKuBQhLO4WrPhcSEbiVBSFYC472mSEgSzu+sZQrJWryQ5K4FCsk6ASFZhxeS3HWeC4kJ3RqCkKwBxvsRzze6LMaPENzso57fd5g76Pte7/l92/mdRwn3vcHz+w5NB/q+N4LvG61ldn4HmJPOtGIDYR43eZ4/4eoXfd+PeZ4/dn4HmON7eusmwjw+Djbs7Kf4pkVAZmd5pHx+Z3M++5aCD2Y2J3kws+X/w95/wMdVnPv/uCztWHLvcqXZlrus7QVw7zbV4F6wtLsy1WAbU001mJJKCiGkkEpySSCNVHK5CamkEoItq1fbuNuY6vqfA+t818eK8l/2/YDnlzl5zesi6Wr0mWfPfJ73mXl8Zqjsv98BJ+W/Pmj2Acfr+zUIqS+c5ub7daHd2HmneZ2kM+YXBMY935B/v/MbcB6Cn7VvvtC/3/lNahc//aK3asjl9t+Cn09rY/Vmd73773fIulqpuuXfneb+63zOjkZ6fv/+v2B+t/Z5EBVevxeoGehhaH3261x9tgTwtlqf/YcU8P7RDbx/GHpqffYfh8rXZ78O1mf/AUwyfxzKfgBFOfgH/K/rRH/0xHx2yOmv8UU4ieHk0zLkvclFDdjp60WB7YeWIdyYyQ/FUEf3tSJXxNH/lHL0P7sd/U+tOPqfDXP0P4GO/mfO0X2mOvpPDHD0v5zujr51yHuTixqw09dfBBx9K+jof7GO/oGddffXlKP/ze3of23F0f9mmKP/FXT0v3GO7jfV0X9mgKP//XR39G1D3ptc1ICdvv4u4OjbQEf/u3X0D+xfxb+UcvR/uB39pVYc/R+GOfpLoKP/g3P0gKmO/gsDHP3l093Rtw95b3JRA3b6elnA0beDjv6ydfRgK3JFHP2fKUd/xe3o/2zF0V8xzNH/CTr6K5yjB0119F8a4OibTndHf3XIe5OLGrDT1yYBR38VdPRN1tFDrcgVcfTNKUevcDv65lYcvcIwR98MOnoF5+ghUx39eQMcfcvp7ug7hrw3uagBO31tEXD0HaCjb7GOHm5FroijV6Ycvcrt6JWtOHqVYY5eCTp6FefoYVMd/VcGOHr16e7oO4e8N7moATt9VQs4+k7Q0auto0dakSvi6DUpR691O3pNK45ea5ij14COXss5esRUR3/BAEevO90dfdeQ9yYXNWCnrzoBR98FOnqddfRoK3JFHL0+5egNbkevb8XRGwxz9HrQ0Rs4R4+a6ui/NcDRG093R9895L3JRQ3Y6atRwNF3g47eaB091opcEUdvSjl6s9vRm1px9GbDHL0JdPRmztFjpjr67w1w9JbT3dH3DHlvclEDdvpqEXD0PaCjt1hHL21Froijb005+ja3o29txdG3GeboW0FH38Y5eqmpjv5HAxx9++nu6HuHvDe5qAE7fW0XcPS9oKNvt45e1opcEUd/NeXoO9yO/morjr7DMEd/FXT0HZyjl5nq6H8ywNF3nu6Ovm/Ie5OLGrDT104BR98HOvpO6+jxVuSKOPqulKPvdjv6rlYcfbdhjr4LdPTdnKPHTXX0vxjg6HtOd0ffP+S9yUUN2Olrj4Cj7wcdfY919EQrckUcfW/K0fe5HX1vK46+zzBH3ws6+j7O0ROmOvrfDHD0/ae7ox8Y8t7kogbs9LVfwNEPgI6OfyipCxrzv5zxNXDMB8Axp5twer8nLvrg1oNDwPsINOHXhGL6WisxhedTtF8+F4eDQnE4KB8H32tDT884SIz1h3oevQJ6itNfzRBeZw2o8XUDPpNN8GdSK/CZ1IIa3zDgM9kMfyZ1Ap9JHajxTQM+kwr4M6kX+EzqQY1vGfCZbIE/kwaBz6QB1Pi2AZ9JJfyZNAp8Jo2gxncM+Eyq4M+kSeAzaQI1HjLgM6mGP5Nmgc+kGdR4GH5O65Xz3nOa8xb1s1P/vTXtv7el/ff2tP9+Ne2/d6T99860/96V9t+70/57T9p/7037731p/70/7b8PpP33a2n/fTDtv18f+v/++420/34z7b/fSvvvt9P++520/z6U9t+HU/99RP/fo7od0+24s6qtV1rb6ZarW55uzo6AfhT/15pJ+kUvRh4RWvfKYXVKvM/svcv33n17Irae1H979OegdGuvW35Rzsm7DM4PC1zfU618r30r38sv+n+H5524FBuskz7UbA3CGWu2fZ04NE9BfTljbI/09V688ovY7bwPavIetZO31clboD/PDrp11K2Te/IWtDIpO7TyvY6tfK/TBzB5j4KTtwCcvB3AydsRnLydDJ28x+zkbXXydtafZxfduurWzT15O7cyKbu08r2urXyv2wcweY+Bk7czOHm7gJO3Kzh5uxk6eY/bydvq5O2uP88euvXUrZd78nZvZVL2aOV7PVv5Xq8PYPIeBydvd3Dy9gAnb09w8vYydPLmFNnJ29rk7a3j0ke3Qt36uidv71YmZZ9WvlfYyvf6fgCTN6eIm7y9wcnbB5y8heDk7Wvo5G1nJ2+rk7efjkt/3QboNtA9efu1Min7t/K9Aa18b+AHMHnbgZO3Hzh5+4OTdwA4eQcaOnlz7eRtdfIO0nE5Q7czdTvLPXkHtTIpz2jle2e28r2zPoDJmwtO3kHg5D0DnLxngpP3LEMnb56dvK1O3rN1XM7RbbBuQ9yT9+xWJuU5rXxvcCvfG/IBTN48cPKeDU7ec8DJOxicvEPgyds+5/9N1PSLnrz/VNRnU55M1zu0SFCw07m7eCJb8UO5D9BXBE4eqRg6GtvBMSz6L58ETmfpeodJToJh8CRwOh4GToLhBkyC4fAkcDoeDuMQpe9ELJ1JOryIrz4rOk3vHcdIHHJyE1P6Bel+d/L3dPVN37dbFY/btMYWAzQ2G6CxyQCNjQZobDBAY70BGusM0FhrgMYaAzRWG6CxygCNlQZo3GKAxgoDNG42QOMmAzS+nMsy+dCcky9a79sGxPQdAzQeMkDjYQM0HjFA41EDNB4zQONxAzQ6K7mnu8Z2BmjMNUBjngEaPQZoVAZobG+AxnwDNBYYoLGDARo7GqCxkwEaOxugsYsBGrsaoLGbARq7G6CxhwEaexqgsZcBGnsboLGPARoLDdDY1wCN/QzQ2N8AjQMM0DgQ1Ohom5lz8mXXxk9PjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjf9ta+M5rsv2a/u1/dp+bb+2X9uv7df2a/u1/dp+3+/V2rtictm/4Tsni+chn+vrEZn05Wv7x1LjLQHHG86or/I2L6nxjgPHO9WA8c4BxzvXgPEuAse7woDxrgTHu8qA8a4Dx7vegPFuAMf7sAHjfQQc72MGjPcJcLxPGjDep8HxPmvAeJ8Dx/uCAeN9ERzvSwaMtwIcb50B490Kjne3AeM9CI73kAHjbZfPjbcg//QfbzdwvIVpfWX7Dt4P4r24bxlQ6/+mARrfMEDj6wZoPGiAxtcM0HjAAI37DdC4zwCNew3QuMcAjbsN0LjLAI07DdC4wwCNrxqgcbsBGreBGltj8m6Z621zp++3mepto7ffZT72f9vb799PHP9Nb394f59Jq7398f1+vq309uL7v1dO6e1P2dx3rt7+nN09fFJvf8l2PqT19tfs59a/evsbMU9Tvf2dmfPv9vYS5R+6t39wXuR7WcB7aS/7MehlPwG97Kegl/0M9LKfg172C9DLngO97Jegl/0v6GXPg172f6CX/Qr0sl+DXvYC6GW/McDLngS97Fugl30b9LL/Ab3sKdDLvgN62XdBL3sa9LJnQC/7Huhl3we97Aegl/0Q9LIfgV72rAFe9jnQyx4DvezzoJc9DnrZF0Av+yLoZV8CvezLoJc9AXrZV0Av+yroZV8DvezroJd9A/SybxrgZQ+CXvYQ6GUPg172EdDLPgp62cdAL/s46GWfAL3sk6CXPQJ62adAL/s06GWfAb3ss6CXPWqAl90KetltoJfdDnrZetDL7gC97E7Qy+4Cvexu0MvuAb3sXtDLNoBedh/oZfeDXrYR9LIHDPCyq0Evuwb0smtBL7sO9LJVoJddD3rZDaCXrQa9bA3oZWtBL7sR9LJ1oJfdBHrZzaCX3WKAly0BvWwp6GXLQC9bDnrZFaCXrQC9rBT0sjLQy+KglyVAL0uCXlYOetlK0MuuBL3sKgO87ALQyy4Evewi0MsuBr3sEtDLLgW9bC7oZZeBXnY56GXzQC+bD3rZAtDLFoJetgj0ssUGeNk40MvGg142AfSyiaCXTQK9bDLoZVNAL5sKetk00Mumg142A/SymaCXzQK9bDboZXMM8LKxoJeVgF7mBb3MB3qZH/SyAOhlQdDLQqCXhUEvi4BeFgW9LAZ62bmgl50Hetn5BnjZWaCXnQ162Tmglw0GvWwI6GVDQS8rAr1sGOhlw0EvGwF62UjQy0aBXjYa9LIxoJcVG+Bl3UEv6wF6WU/Qy3qBXtYb9LI+oJcVgl7WF/SyfqCX9Qe9bADoZQNBLxsEetkZoJedaYCXtQO9LBf0sjzQyzyglynQy9qDXpYPelkB6GUdQC/rCHpZJ9DLOoNe1gX0sq6gl3UzwMte83BedtDDednrHs7L3vBwXvamh/Oytzycl73t4bzsHQ/nZYc8nJcd9uRgXnbEk4N52VGir1Rvx5i+3u3tONWX7i3HAC9rBr2sBfSyraCXbQO9bDvoZa+CXrYD9LKdoJftAr1sN+hle0Av2wt62T7Qy/aDXnbAc/p72Sugl20CvWwz6GUVoJdtAb2sEvSyKtDLqkEvqwG9rBb0sjrQy+pBL2sAvawR9LImAS+j3x35T1CjfXdkhnH8N73Zd0dm1pt9d2Rmvdl3R2Z2SXmZfXdkZr3Zd0dm1pt9d2Rmvdl3R7ato60f2ndHZtabfXdkZr3Zd0dm1pt9d2TbOtr6oX13ZGa92XdHZtabfXdkZr3Zd0e2raOtH9p3R2bWm313ZGa92XdHZtabfXdk2zra+qF9d2Rmvdl3R2bWm313ZGa92XdHtq2jrR/ad0dm1pt9d2Rmvdl3R2bWm313ZNs62vqhfXdkZr3Zd0dm1pt9d2Rmvdl3R7ato60f2ndHZtabfXdkZr3Zd0dm1pt9d2TbOtr6oX13ZGa92XdHZtabfXdkZr3Zd0e2raOtH9p3R/7bq9Xe7LsjM+vNvjsys97suyPb1tHWD+27IzPrzb47MrPe7LsjM+vNvjuybR1t/dC+OzKz3uy7IzPrzb47MrPe7Lsj29bR1g/tuyMz682+OzKz3uy7IzPrzb47sm0dbf3Qvjsys97suyMz682+OzKz3uy7I9vW0dYP7bsjM+vNvjsys97suyMz682+O7JtHW390L47MrPe7LsjM+vNvjsys97suyPfv0b63ZEnNJ54h+SIopyckbqN0m20bmN0K9ZtrG4lunl18+nm1y2gW1C3kG5h3SK6RXWL6ZbjSbXOOf/+mggOxP0STDrwW9Xpf3O0GKCx2QCNTQZobDRAY4MBGusN0FhngMZaAzTWGKCx2gCNVQZorDRA4xYDNFYYoHGzARo3GaDx5VyWyYfmnHzRet82IKbvGKDxkAEaDxug8YgBGo8aoPGYARqPG6Axp/3pr7GdARpzDdCYZ4BGjwEalQEa2xugMd8AjQUGaOxggMaOBmjsZIDGzgZo7GKAxq4GaOxmgMbuBmjsYYDGngZo7GWAxt4GaOxjgMZCAzT2NUBjPwM09jdA4wADNA4ENTraZuacfNm18dNTo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFG43/b2niO67L92n5tv7Zf26/t1/Zr+7X92n5tv7bf93u19q6YXPZv+M7J4nnI/darEZn05Wv7x1LjLQHHG86or/I2L6nxjgPHO9WA8c4BxzvXgPEuAse7woDxrgTHu8qA8a4Dx7vegPFuAMf7sAHjfQQc72MGjPcJcLxPGjDep8HxPmvAeJ8Dx/uCAeN9ERzvSwaMtwIcb50B490Kjne3AeM9CI73kAHjbZfPjbcg//QfbzdwvIVpfQW84WAwGfEnfQFfqdcfK4uGvMFQWTjqi/pC0VDCHw0EktFgNBIri0W8MV8wkPSVh2KB8lRfH8R7cd8yoNb/TQM0vmGAxtcN0HjQAI2vGaDxgAEa9xugcZ8BGvcaoHGPARp3G6BxlwEadxqgcYcBGl81QON2AzRuAzW2xuT0gUe/BQ/V/R14qO7vwUN1/wAeqvtH8FDdF8FDdf8EHqr7Z/BQ3b+Ah+r+FTxU92/gobp/Bw/VfQk8VPcf4KG6LxtwEOWPQS/7CehlPwW97Gegl/0c9LJfgF72HOhlvwS97H9BL3se9LL/A73sV6CX/Rr0shdAL/uNAV72JOhl3wK97Nugl/0P6GVPgV72HdDLvgt62dOglz0Detn3QC/7PuhlPwC97Iegl/0I9LJnDfCyz4Fe9hjoZZ8Hvexx0Mu+AHrZF0Ev+xLoZV8GvewJ0Mu+AnrZV0Ev+xroZV8HvewboJd90wAvexD0sodAL3sY9LKPgF72UdDLPgZ62cdBL/sE6GWfBL3sEdDLPgV62adBL/sM6GWfBb3sUQO87FbQy24Dvex20MvWg152B+hld4JedhfoZXeDXnYP6GX3gl62AfSy+0Avux/0so2glz1ggJddDXrZNaCXXQt62XWgl60Cvex60MtuAL1sNehla0AvWwt62Y2gl60Dvewm0MtuBr3sFgO8bAnoZUtBL1sGetly0MuuAL1sBehlpaCXlYFeFge9LAF6WRL0snLQy1aCXnYl6GVXGeBlF4BediHoZReBXnYx6GWXgF52Kehlc0Evuwz0sstBL5sHetl80MsWgF62EPSyRaCXLTbAy8aBXjYe9LIJoJdNBL1sEuhlk0EvmwJ62VTQy6aBXjYd9LIZoJfNBL1sFuhls0Evm2OAl40FvawE9DIv6GU+0Mv8oJcFQC8Lgl4WAr0sDHpZBPSyKOhlMdDLzgW97DzQy843wMvOAr3sbNDLzgG9bDDoZUNALxsKelkR6GXDQC8bDnrZCNDLRoJeNgr0stGgl40BvazYAC/rDnpZD9DLeoJe1gv0st6gl/UBvawQ9LK+oJf1A72sP+hlA0AvGwh62SDQy84AvexMA7ysHehluaCX5YFe5gG9TIFe1h70snzQywpAL+sAellH0Ms6gV7WGfSyLqCXdQW9rJsBXvaah/Oygx7Oy173cF72hofzsjc9nJe95eG87G0P52XveDgvO+ThvOywJwfzsiOeHMzLjhJ9pXo7xvT1bm/Hqb50bzkGeFkz6GUtoJdtBb1sG+hl20EvexX0sh2gl+0EvWwX6GW7QS/bA3rZXtDL9oFeth/0sgOe09/LXgG9bBPoZZtBL6sAvWwL6GWVoJdVgV5WDXpZDehltaCX1YFeVg96WQPoZY2glzUJeBn97sh/ghrbpelzX+TfsO+nzN7f7fspM+vNvp8ys97s+ykzu6S8zL6fMrPe7PspM+vNvp8ys97s+ynb1tHWD+37KTPrzb6fMrPe7PspM+vNvp+ybR1t/dC+nzKz3uz7KTPrzb6fMrPe7Psp29bR1g/t+ykz682+nzKz3uz7KTPrzb6fsm0dbf3Qvp8ys97s+ykz682+nzKz3uz7KdvW0dYP7fspM+vNvp8ys97s+ykz682+n7JtHW390L6fMrPe7PspM+vNvp8ys97s+ynb1tHWD+37KTPrzb6fMrPe7PspM+vNvp+ybR1t/dC+nzKz3uz7KTPrzb6fMrPe7Psp29bR1g/t+ykz682+nzKz3uz7KTPrzb6fsm0dbf3Qvp8ys97s+ykz682+nzKz3uz7KdvW0dYP7fspM+vNvp8ys97s+ykz682+n7JtHW390L6fMrPe7PspM+vNvp8ys97s+ynb1tHWD+37KTPrzb6fMrPe7PspM+vNvp+ybR1t/dC+nzKz3uz7KTPrzb6fMrPe7Psp29bR1g/t+ykz682+nzKz3uz7KTPrzb6f8v1r/P/C+ynpmIwoOv0/t5EGaBxlgMbRBmgcY4DGYgM0jjVAY4kBGr0GaPQZoNFvgMaAARqDBmgMGaAxbIDGiAEaowZojIEaPwDu9+WlxeEE/5+rx3CebufrNk638bpNcMal2yTdJus2Rbepuk3TbbpuM3Sbqdss3WbrNqfo5D4v0F9fqNtFul2s2yW6XarbXN0u0+1y3ebpNl+3Bbot1G2Rbot1W6LbUt2Wpfocmupzuf76Ct1W6FaqW5lucd0SuiV1K9dtpW5X6naVblfrdo1u1+p2nW6rdLtetxt0W63bGt3W6najbut0u0m3m3W7RbdbdbtNt9t1W6/bHbrdqdtdut2t2z1FqSDmpf6vE8RbXN87r5Xvnd/K98a18r3xrXxvQivfm9jK9ya18r3JrXxvSivfm9rK96a18r3prXxvRivfm9nK92a18r3ZrXzPuam65px8dc98QrS5CGkPUcisN3uIQma92UMUMuvNhEMUAt5wMJiM+JO+gK/U64+VRUPeYKgsHPVFfaFoKOGPBgLJaDAaiZXFIt6YLxhI+spDsUB5qrN7i3iwkfBGeyhDZr3ZQxky680eypBZbyYcypCtNz5qiDfaQx4y680e8pBZb/aQh8x6M+GQh2y98SlDvNEeGpFZb/bQiMx6s4dGZNabCYdGZOuNzxvijfYQisx6s4dQZNabPYQis95MOIQiW2982RBvtIdaZNabPdQis97soRaZ9WbCoRbZeuM2Q7zRHpKRWW/2kIzMerOHZGTWmwmHZGTrjYcM8UZ76EZmvdlDNzLrzR66kVlvJhy6ka03dh1mhjfaQzwy680e4pFZb/YQj8x6M+EQj2y9cbAh3mgPBcmsN3soSGa92UNBMuvNhENBsvXGsCHeaA8Zyaw3e8hIZr3ZQ0Yy682EQ0ay9cbZhnijPbQks97soSWZ9WYPLcmsNxMOLcnWG5cb4o32EJTMerOHoGTWmz0EJbPeTDgEJVtvXGOIN9pDVTLrzR6qkllv9lCVzHoz4VCVbL1xoyHeaA9pyaw3e0hLZr3ZQ1oy682EQ1qy9cbHDfFGe+hLZr3ZQ18y680e+pJZbyYc+pKtNz5jiDfaQ2Qy680eIpNZb/YQmcx6M+EQmWy98QXQG9Pfd+u84PjES6BPfO+KVr63opXvlbbyvbJWvhdv5XuJVr6XbOV75a18b2Ur37uyle9d1cr3rm7le9e08r1rW/neda18b1Ur37u+le/d0Mr3VrfyvTWtfG9tK9+7sZXvrWvleze18r2bW/neLa1879ZWvndbK9+7vZXvrW/le3e08r07W/neXanvOVdu6v9OTP1fX7g8HC4tDSVKY95QJBIMxeKhUCQc9Qf0dArFY6FIwBuJBhKhUHlZvDQe9SVi/lg8Uloa9gdivnB4q3rvvdn/6i8WTiQD8YQ3XOoLRstCoWS0NJkMJkPJSEJP00DC5w1EvN4yf6AsUar794eDelr6YsFYIh5Oxsqc96o6Tbl1ZtnvOe3T5nu0LFIe8MWTeqjhZCgcjcXL4v6w/gtBfzSYSMb93lh5NBosL/dFkmFvoDQU8kb9wWR5LKz/ZDw4oj0Xv0wOWAr+h58vL+L8sYLzR1/6vej0e2eq3x6uzzjg9Qa0NB2pcHkgnoyFg4ny0pC/zBeMJEOh0rhzB0S9kUgyGg+VJ8q8fl+oVI8uGo/63/07zrtu7z05BoFkorQ0GAyWJfRtEImUxxMhX6g87NOfTag0EonEYpGktzTmj0YSvmTYX1YeTiR0oBNOj76fnNqfjqnP74vGgmWl4Yi+LcrL/cFQ0lseSpaFSv2haMCfKI/6fMloojyW0PekNxHwxv1xn9Oj76eu/vyloUg8WBr0B4P+eHkgWZZM+sv1TRL0lnlLfclg1OsvLSuNhnylvtKIT/8wUu5PhPT/V2nA6TH2M1d/+kaLxcrL9K0a8Sf8gVAslgjo+60sor8ZDjkffKlX3w6JqI5qqDQW9ZZHykPlgXJ9Fzg9hn7u1hePBGKJ0oA/7gQlEY364mVRPW/0kMvKIlF9U5UngvpDKg0F4/qT0tMlVJ4siye98ZjTY+IX7v70NEqUhXTIdLBKvXqSJcPl3ljCr38h6feG9Twpi0YCoag/lIgmYnpm6iAnyssi+sPTPZY95+rPmd3+UCzhTfoD+v+nvDQR9sXK/NFwMhwtj8dLw/FQWSAQCCbiZeVlIX2Th2Nl3jJfIKHDo3uM/dLdn56RpVpbQgfHp92lNKr/K1EaiWmHiASipXpya6PRH0giEQ6VlZdHysJh7RexWCzs9Jj4X/fnEda3bjSUDJfGyiP6hir1J8r05xyKlQXLAlFtMOF4sMxXXh7zebVd6GCWxQP6G1FfIOz0mHzeHb9IWbQ8Vqrj7g+Fgomg/nCCZcHyZLIsEdGCguWBoE9P4UQkEC7ze6ORZCxa5tN3VcRf7vQY/T/3eOPJQDASTSS0N8T07IrFSvV08MVCZQmv/vgSeh74fQE9e0JlsaieNfFoIFIWTCZjwXKnx9JfndJfJFIa01NOBzwcjOjZqwX4Q9peAolYabg0on06ENdB0N2FfREnOMmYE75EwOkx+Gt3/Pxhn79M3wW+cFzf/uFwLBrQcdeW7SsLJsqS8aiegX5feUw7fzBWGtVTKeAP65HrIekeAy+c0p8z4/0RPR+95b6gzxuMh7SlhwP6Zi7V90tE34rlkXhC/8+n7cWn84RODDE93cqcHkO/cY83S+9vcedOIBc751Xku3w129xZAubOMJg7RwL5LlnuXHHfcjAPXwHyUHoezjanbxmGxT6SntO3pOX0Xq57L9uc/iSc078F5/Rvwzn9f+Cc/hSc078D5/Tvwjn9aTinPwPn9O/BOf37cE7/AZzTfwjn9B/BOf1ZOKc3wzm9JZXTqf4cRjgfzE/Ou/4fFWCOcSBzTAWZYxTIHFeAzLEC/Ey3gMxRKcQclWnMMdh172XLHJ+DmeMxmDk+DzPH4zBzfAFmji/CzPElmDm+DDPHEzBzfAVmjq/CzPE1mDm+DjPHN2Dm+OYpfpD9M9Kj8DPSo/Az0qPwM9Kj8DPSo/Az0qPwM9Kj8DPSo/Az0qPwM9Kj8DPSo/Az0qPwM9Kj8DPSo/Az0qPgM0gT/IzUDD8jtbifkYBnrnECz0hzwGekueAz0mjwGWkF+IxUCj4jVYLPSFVCz0hVac9IQ133XrbM8SD8jPQQ/Iz0MPyM9BH4Gemj8DPSx+BnpI/Dz0ifgJ+RPgk/Iz0CPyN9Cn5G+jT8jPQZ+Bnps/Az0qPwM9Ln4Gekx+BnpM/Dz0iPw89IX4Cfkb4IPyN9CX5G+jL8jPQE/Iz0FfgZ6avwM9LX4Gekr8PPSN+An5G+CT8jNcLPSE3wM1Iz/IzUknpGovpznrnGg7zvnNv6lMAz3CLwGW4F+Aw3BnyGKwWf4crAz7QKfIarFnqGq057hgu47r1smehW+BnuNvgZ7nb4GW49/Ax3B/wMdyf8DHcX/Ax3N/wMdw/8DHcv/Ay3AX6Guw9+hrsffobbCD/DPQA/wz0IP8M9BD/DPQw/w30Efob7KPwM9zH4Ge7j8DPcJ+BnuE/Cz3CPwM9wn4Kf4T4NP8N9Bn6G+yz8DPfoKX6Q/ZrTU/Ca01PwmtNT8JrTU/Ca01PwmtNT8JrTU/Ca01PwmtNT8JrTU/Ca01PwmtNT8JrTU/Ca01PwmtNT4JpJA7zm1AivOTXBa07N8JpTi3vNCVjDmiCw5rQSXHNaBa45FYNrTmXgmlMcXHOqBtecaoTWnGrS1pxCrnsvWya6Gl5zugZec7oWXnO6Dl5zWgWvOV0PrzndAK85rYbXnNbAa05r4TWnG+E1p3XwmtNN8JrTzfCa0y3wmtOt8JrTbfCa0+3wmtN6eM3pDnjN6U54zekueM3pbnjN6R54zeleeM1pA7zmdB+85nQ/vOa0EV5zegBec3oQXnN6CF5zehhec/oIvOb0UXjN6WPwmtPH4TWnT8BrTp+E15wegdecPgWvOX0aXnP6DLzm9Fl4zelReM2pHl5zaoDXnBrhNacmeM2pGV5zakmtOVH9OWtYE8H1k+d1X88LrImtA9fE1oNrYmPBNbE4uCaWAD/TGnBNrFZoTaw2bU1squvey5bZlsBrYkvhNbFl8JrYcnhN7Ap4TWwFvCZWCq+JlcFrYnF4TSwBr4kl4TWxcnhNbCW8JnYlvCZ2FbwmdjW8JnYNvCZ2Lbwmdh28JrYKXhO7Hl4TuwFeE1sNr4mtgdfE1sJrYjfCa2Lr4DWxm+A1sZvhNbFb4DWxW+E1sdvgNbHb4TWx9fCa2B3wmtid8JrYXfCa2N3wmtg98JrYvfCa2AZ4Tew+eE3sfnhNbCO8JvbAKX6Q/Rr+86BfPXRqf1mv4T8P+tVHXP0Ra/jPg371MXd/wBr+86BffcLdH7CG/zzoV4+44wes4T8P+tWnT+kv+zX850G/+uwp/WW/hv88uMZbp9g1fGdPgFzDd/YEyDV8Z0+AXMN39gTINXxnT4Bcw3f2BCaC/Tl7ApOK+DX8DeAa/sPgGn5JEbeGn77u7s1yDT9ZxMW+FlzDrxNaw69LW8Of7rr3smW2CxS7hn+hYtfwL1LsGv7Fil3Dv0Sxa/iXKnYNf65i1/AvU+wa/uWKXcOfp9g1/PmKXcNfoNg1/IWKXcNfpNg1/MWKXcN39hzJNfylil3DX6bYNfzlil3Dv0Kxa/grFLuGX6rYNfwyxa7hxxW7hp9Q7Bp+UrFr+OWKXcNfqdg1/CsVu4Z/lWLX8J09R3IN/xrFruFfq9g1/OsUu4a/SrFr+Ncrdg3/BsWu4a9W7Br+GsWu4a9V7Br+jYpdw1+n2DX8mxS7hn+zYtfwb1HsGr6z50iu4d+m2DX82xW7hr9esWv4dyh2Df9Oxa7h36XYNfy7FbuGf49i1/DvVewa/gbFruHfp9g1/PsVu4a/UbFr+A8odg2/VrFr+M6eALmG7+wJkGv4zp4AuYbv7AmQa/jOngC5hu/sCZBr+M6ewCSwP2dPYHIRtx79su7LafQewyPgHsNj4B6Dt4jbY0jfF/BmucdQDn6mdeAeQ73QHkN92h7DPNe9ly1TjlPsHsN4xe4xTFDsHsNExe4xTFLsHsNkxe4xTFHsHsNUxe4xTFPsHsN0xe4xzFDsHsNMxe4xzFLsHsNsxe4xzFHsHsMFit1juFCxewwXKXaP4WLF7jFcotg9hksVu8cwV7F7DJcpdo/hcsXuMcxT7B7DfMXuMSxQ7B7DQsXuMSxS7B7DYsXuMSxR7B7DUsXuMSxT7B7DcsXuMVyh2D2GFYrdYyhV7B5DmWL3GOKK3WNIKHaPIanYPYZyxe4xrFTsHsOVit1juEqxewxXK3aP4RrF7jFcq9g9husUu8ewSrF7DNcrdo/hBsXuMaxW7B7DGsXuMaxV7B7DjYrdY1in2D2GmxS7x3CzYvcYbjnFD7LfE30Z9KvbTu0v6z3Rl0G/Wu/qj9gTfRn0qzvd/QF7oi+DfnW3uz9gT/Rl0K/udccP2BN9GfSr+07pL/s90ZdBv9p4Sn/Z74meNN4s91RqFLsn6uyxknuizh4ruSfq7LGSe6LOHiu5J+rssZJ7os4eK7kn6uyxknuizh7rZLA/Z491ShG/J/oEuCf6JLgn6ivi9kTT9zG9We6JriziYl8P7ok2CO2JNqTtiS5w3XvZMuVYxe6Jlih2T9Sr2D1Rn2L3RP2K3RMNKHZPNKjYPdGQYvdEw4rdE40odk80qtg90Zhi90TPVeye6HmK3RM9X7F7ok4NB7knOl6xe6ITFLsnOlGxe6KTFLsnOlmxe6JTFLsnOlWxe6LTFLsnOl2xe6IzFLsnOlOxe6KzFLsnOluxe6JzFLsn6tRwkHuiFyp2T/Qixe6JXqzYPdFLFLsneqli90TnKnZP9DLF7olertg90XmK3ROdr9g90QWK3RNdqNg90UWK3RNdrNg9UaeGg9wTXarYPdFlit0TXa7YPdErFLsnukKxe6Klit0TLVPsnmhcsXuiCcXuiSYVuydartg90ZWK3RO9UrF7olcpdk/UqeEg90SvUeye6LWK3RO9TrF7oqsUuyd6vWL3RG9Q7J7oasXuia5R7J7oWsXuid6o2D3RdYrdE71JsXuiNyt2T/QWxe6JVit2T9TZYyX3RJ09VnJP1NljJfdEnT1Wck/U2WMl90SdPVZyT9TZYyX3RJ09VnJP1NljnQL25+yxTi3i9ve26b6cRu/ZPg3u2T4L7tn6i7g92/R9Vm+We7ZXgp9pA7hn2yi0Z9uYtmdb7rr3smXesxS7Z3u2Yvdsz1Hsnu1gxe7ZDlHsnu1Qxe7ZFil2z3aYYvdshyt2z3aEYvdsRyp2z3aUYvdsRyt2z3aMYvdsixW7Z+vUmJB7tiWK3bP1KnbP1qfYPVu/YvdsA4rdsw0qds82pNg927Bi92wjit2zjSp2zzam2D3bcxW7Z3ueYvdsz1fsnq1TY0Lu2Y5X7J7tBMXu2U5U7J7tJMXu2U5W7J7tFMXu2U5V7J7tNMXu2U5X7J7tDMXu2c5U7J7tLMXu2c5W7J7tHMXu2To1JuSe7YWK3bO9SLF7thcrds/2EsXu2V6q2D3buYrds71MsXu2lyt2z3aeYvds5yt2z3aBYvdsFyp2z3aRYvdsFyt2z9apMSH3bJcqds92mWL3bJcrds/2CsXu2a5Q7J5tqWL3bMsUu2cbV+yebUKxe7ZJxe7Zlit2z3alYvdsr1Tsnu1Vp/hB9jUm20C/uubU/rKuMdkG+tV1rv6IGpNtoF9d7+4PqDHZBvrVand/QI3JNtCv1rrjB9SYbAP9at0p/WVfY7IN9KubT+kv+xqTk8ab5R5wlWJrTJyaFbLGxKlZIWtMnJoVssbEqVkha0ycmhWyxsSpWSFrTJyaFbLGxKlZIWtMnJoVssbEqVmZCvbn1KxMK+JrTJ4Da0xeAGtMAkVcjUl6XYg3yxqTq4q42DeCNSZNQjUmTWk1Jle67r1smbe7YmtMeii2xqSnYmtMeim2xqS3YmtM+ii2xqRQsTUmfRVbY9JPsTUm/RVbYzJAsTUmAxVbYzJIsTUmZyi2xuRMxdaYODVxZI3J2YqtMTlHsTUmgxVbYzJEsTUmQxVbY1Kk2BqTYYqtMRmu2BqTEYqtMRmp2BqTUYqtMRmt2BqTMYqtMSlWbI2JUxNH1piUKLbGxKvYGhOfYmtM/IqtMQkotsYkqNgak5Bia0zCiq0xiSi2xiSq2BqTmGJrTM5VbI3JeYqtMTlfsTUmTk0cWWMyXrE1JhMUW2MyUbE1JpMUW2MyWbE1JlMUW2MyVbE1JtMUW2MyXbE1JjMUW2MyU7E1JrMUW2MyW7E1JnMUW2Pi1MSRNSYXKrbG5CLF1phcrNgak0sUW2NyqWJrTOYqtsbkMsXWmFyu2BqTeYqtMZmv2BqTBYqtMVmo2BqTRYqtMVms2BoTpyaOrDFZqtgak2WKrTFZrtgakysUW2OyQrE1JqWKrTEpU2yNSVyxNSYJxdaYJBVbY1Ku2BqTlYqtMblSsTUmVym2xqRSsTUmTs0KWWPi1KyQNSZOzQpZY+LUrJA1Jk7NCllj4tSskDUmTs0KWWPi1KyQNSZOzQpZY+LUrJA1Jk7NyjSwP6dmZXoRVy9xSPflNLoG5kWwBuYlsAYmWMTVwKTXrXizrIG5GvxMm8AamGahGpjmtBqYm133XrZM3k6xNTC5iq2ByVNsDYxHsTUwSrE1MO0VWwOTr9gamALF1sB0UGwNTEfF1sB0UmwNTGfF1sB0UWwNTFfF1sB0U2wNjFOzR9bA9FBsDUxPxdbA9FJsDUxvxdbA9FFsDUyhYmtg+iq2BqafYmtg+iu2BmaAYmtgBiq2BmaQYmtgzlBsDcyZiq2BcWr2yBqYsxVbA3OOYmtgBiu2BmaIYmtghiq2BqZIsTUwwxRbAzNcsTUwIxRbAzNSsTUwoxRbAzNasTUwYxRbA1Os2BoYp2aPrIEpUWwNjFexNTA+xdbA+BVbAxNQbA1MULE1MCHF1sCEFVsDE1FsDUxUsTUwMcXWwJyr2BqY8xRbA3O+YmtgnJo9sgZmvGJrYCYotgZmomJrYCYptgZmsmJrYKYotgZmqmJrYKYptgZmumJrYGYotgZmpmJrYGYptgZmtmJrYOYotgbGqdkja2AuVGwNzEWKrYG5WLE1MJcotgbmUsXWwMxVbA3MZYqtgblcsTUw8xRbAzNfsTUwCxRbA7NQsTUwixRbA7P4FD/IvmbvEOhXS0/tL+uavUOgXy139UfU7B0C/WqFuz+gZu8Q6Fdl7v6Amr1DoF8l3PEDavYOgX5Vfkp/2dfsHQL96spT+su+Zu+k8WZZs7JFsTV7Tg0gWbPn1ACSNXtODSBZs+fUAJI1e04NIFmz59QAkjV7Tg0gWbPn1ACSNXtODSBZs+fUAJI1e04NIFmz59QATgf7c2oAZxTxNXsVYM1eHVizFyriavbS6+y8WdbsXVPExb4ZrNlrEarZa0mr2bvVde9ly+SvediavYMetmbvdQ9bs/eGh63Ze9PD1uy95WFr9t72sDV773jYmr1DHrZm77CHrdk74mFr9o562Jq9Yx62Zu+4h63Zy1FszZ5TY0zW7OUqtmYvT7E1ex7F1uwpxdbstVdszV6+Ymv2ChRbs9dBsTV7HRVbs9dJsTV7nRVbs9dFsTV7XRVbs9dNsTV7To0xWbPXQ7E1ez0VW7PXS7E1e70VW7PXR7E1e4WKrdnrq9iavX6Krdnrr9iavQGKrdkbqNiavUGKrdk7Q7E1e2cqtmbPqTEma/bOVmzN3jmKrdkbrNiavSGKrdkbqtiavSLF1uwNU2zN3nDF1uyNUGzN3kjF1uyNUmzN3mjF1uyNUWzNXrFia/acGmOyZq9EsTV7XsXW7PkUW7PnV2zNXkCxNXtBxdbshRRbsxdWbM1eRLE1e1HF1uzFFFuzd65ia/bOU2zN3vmKrdlzaozJmr3xiq3Zm6DYmr2Jiq3Zm6TYmr3Jiq3Zm6LYmr2piq3Zm6bYmr3piq3Zm6HYmr2Ziq3Zm6XYmr3Ziq3Zm6PYmj2nxpis2btQsTV7Fym2Zu9ixdbsXaLYmr1LFVuzN1exNXuXKbZm73LF1uzNU2zN3nzF1uwtUGzN3kLF1uwtUmzN3mLF1uxVKLZmz6kBJGv2nBpAsmbPqQEka/acGkCyZs+pASRr9pwaQLJmz6kBJGv2nBpAsmbPqQEka/acGkCyZs+pASRr9pwaQLJmz6kBnAH259QAzizi6s+6DsvJcRpdU7gVrCncDdYUhouyr7c7UVOYXgfozbKm8FrwM20Bawq3CtUUbk2rKXzQde9l+8zQDNcUtsA1hVvhmsJtcE3hdrim8FW4pnAHXFO4E64p3AXXFO6Gawr3wDWFe+Gawn1wTeF+uKbwgIetKXRqoMmawoMetqbwdQ9bU/iGh60pfNPD1hS+5WFrCt/2sDWF73jYmsJDHram8LCHrSk84mFrCo962JrCYx62pvC4h60pdGqgyZpCpwaarCnMVWxNYZ5iawo9iq0pVIqtKWyv2JrCfMXWFBYotqawg2JrCjsqtqawk2JrCjsrtqawi2JrCrsqtqawm2JrCp0aaLKmsIdiawp7KramsJdiawp7K7amsI9iawoLFVtT2FexNYX9FFtT2F+xNYUDFFtTOFCxNYWDFFtTeIZiawrPVGxNoVMDTdYUnq3YmsJzFFtTOFixNYVDFFtTOFSxNYVFiq0pHKbYmsLhiq0pHKHYmsKRiq0pHKXYmsLRiq0pHKPYmsJixdYUOjXQZE1hiWJrCr2KrSn0Kbam0K/YmsKAYmsKg4qtKQwptqYwrNiawohiawqjiq0pjCm2pvBcxdYUnqfYmsLzFVtT6NRAkzWF4xVbUzhBsTWFExVbUzhJsTWFkxVbUzhFsTWFUxVbUzhNsTWF0xVbUzhDsTWFMxVbUzhLsTWFsxVbUzjnFD/Ivga66zDOry48tb+sa6DT+yNqoNP7I2qgT9IH1ECf1B9QA53eH1EDfVJ/QA30SZ8HUAN9UvyAGuiTxgvUQJ/cX/Y10CfFD6iBPrm/7Gugu3J1XuHNiq2BdmqqyRpop6aarIF2aqrJGminppqsgXZqqskaaKemmqyBdmqqyRpop6aarIF2aqrJGminppqsgXZqqskaaKemmqyBdmqqyRpop6Z6JtifU1M9q4ivgT4I1kAfAmugI6c8q77/Guj0umVvljXQ1xVxsd8K1kBvE6qB3pZWA/2w697L9pnhFbgGehNcA70ZroGugGugt8A10JVwDXQVXANdDddA18A10LVwDXQdXANdD9dAN8A10I1wDXQTXAPdDNdAt8A10FvhGuhtcA30drgG+lW4BnoHXAO9E66B3gXXQO+Ga6D3wDXQe+Ea6H1wDfR+uAb6gIetgXb+zQZZA33Qw9ZAv+5ha6Df8LA10G962BrotzxsDfTbHrYG+h0PWwN9yMPWQB/2sDXQRzxsDfRRD1sDfczD1kAf97A10M6/2SBroJ1/s0HWQOcqtgY6T7E10B7F1kArxdZAt1dsDXS+YmugCxRbA91BsTXQHRVbA91JsTXQnRVbA91FsTXQXRVbA91NsTXQzr/ZIGugeyi2BrqnYmugeym2Brq3Ymug+yi2BrpQsTXQfRVbA91PsTXQ/RVbAz1AsTXQAxVbAz1IsTXQZyi2BvpMxdZAO/9mg6yBPluxNdDnKLYGerBia6CHKLYGeqhia6CLFFsDPUyxNdDDFVsDPUKxNdAjFVsDPUqxNdCjFVsDPUaxNdDFiq2Bdv7NBlkDXaLYGmivYmugfYqtgfYrtgY6oNga6KBia6BDiq2BDiu2Bjqi2BroqGJroGOKrYE+V7E10Ocptgb6fMXWQDv/ZoOsgR6v2BroCYqtgZ6o2BroSYqtgZ6s2BroKYqtgZ6q2BroaYqtgZ6u2BroGYqtgZ6p2BroWYqtgZ6t2BroOYqtgd6k2Bpop6aarIF2aqrJGminppqsgXZqqskaaKemmqyBdmqqyRpop6aarIF2aqrJGminppqsgXZqqskaaKemmqyBdmqqyRpop6aarIF2aqrJGminpnoW2J9TUz37pOeP7Op5B2tvHizwnup2+Wk5JMsa7YJ8Ln7RU56l33+NdnpdtTfLGu1V4Ge6DazR3i5Uo709rUb7I+57L8vP+OXckxkhW4b5J1yT+Qpck7kJrsncDNdkVsA1mVvgmsxKuCazCq7JrIZrMmvgmsxauCazDq7JrIdrMhvgmsxGuCazCa7JbIZrMlvgmsytcE3mNrgmcztck/kqXJO5A67J3AnXZO6CazJ3wzWZe+CazL1wTeY+uCZzP1yTecDD1mQ6NeRkTeZBD1uT+bqHrcl8w8PWZL7pYWsy3/KwNZlve9iazHc8bE3mIQ9bk3nYw9ZkHvGwNZlHPWxN5jEPW5N53MPWZDo15GRNplNDTtZk5iq2JjNPsTWZHsXWZCrF1mS2V2xNZr5iazILFFuT2UGxNZkdFVuT2UmxNZmdFVuT2UWxNZldFVuT2U2xNZlODTlZk9lDsTWZPRVbk9lLsTWZvRVbk9lHsTWZhYqtyeyr2JrMfoqtyeyv2JrMAYqtyRyo2JrMQYqtyTxDsTWZZyq2JtOpISdrMs9WbE3mOYqtyRys2JrMIYqtyRyq2JrMIsXWZA5TbE3mcMXWZI5QbE3mSMXWZI5SbE3maMXWZI5RbE1msWJrMp0acrIms0SxNZlexdZk+hRbk+lXbE1mQLE1mUHF1mSGFFuTGVZsTWZEsTWZUcXWZMYUW5N5rmJrMs9TbE3m+af4QfY15IPhGvLBcA35YLiGfDBcQz4YriEfDNeQD4ZryAfDNeSD4RrywXAN+WC4hnwwXEM+GK4hHwzXkA+Ga8jJmm+nhpys+XZqyMmab6eGnKz5dmrIyZpvp4acrPl2asjJmm+nhpys+XZqyMmab6eGnKz5dmrIyZpvp4acrPl2asjJmm+nhpys+XZqyMmab6eGfDbYn1NDPqeIr/nuBtZ8F4I137FT1uref813ep22N8ua7+uLuNhvB2u+XwVzbXrN96tpNd/r3fceUPN9Hrim80+4hvIVuIZyE1xDuRmuoayAayi3wDWUlXANZRVcQ1kN11DWwDWUtXANZR1cQ1kP11A2wDWUjXANZRNcQ9kM11C2wDWUW+Eaym1wDeV2uIbyVbiGcgdcQ7kTrqHcBddQ7oZrKPfANZR74RrKfXAN5X64hvKAh62hdGq+yRrKgx62hvJ1D1tD+YaHraF808PWUL7lYWso3/awNZTveNgaykMetobysIetoTziYWsoj3rYGspjHraG8riHraF0ar7JGkqn5pusocxVbA1lnmJrKD2KraFUiq2hbK/YGsp8xdZQFii2hrKDYmsoOyq2hrKTYmsoOyu2hrKLYmsouyq2hrKbYmsonZpvsoayh2JrKHsqtoayl2JrKHsrtoayj2JrKAsVW0PZV7E1lP0UW0PZX7E1lAMUW0M5ULE1lIMUW0N5hmJrKM9UbA2lU/NN1lCerdgaynMUW0M5WLE1lEMUW0M5VLE1lEWKraEcptgayuGKraEcodgaypGKraEcpdgaytGKraEco9gaymLF1lA6Nd9kDWWJYmsovYqtofQptobSr9gayoBiayiDiq2hDCm2hjKs2BrKiGJrKKOKraGMKbaG8lzF1lCep9gayvMVX0NJ1jw6NZRkzaNTQ0nWPDo1lGTNo1NDSdY8OjWUZM2jU0NJ1jw6NZRkzaNTQ0nWPDo1lGTNo1NDSdY8OjWUZM2jU0NJ1jw6NZRkzaNTQ0nWPDo1lHOKuHq7sPZSp3lS/Z3oN9v6wvSaQG+W9YU3gON9Fawv3DHs//8x/qcrvb5wR1p94W2uz4WoLzwfXO/4J1yv8wpcr7MJrtfZDNfrVMD1Olvgep1KuF6nCq7XqYbrdWrgep1auF6nDq7XqYfrdRrgep1GuF6nCa7XaYbrdVrgep2tcL3ONrheZztcr/MqXK+zA67X2QnX6+yC63V2w/U6e+B6nb1wvc4+uF5nP1yvc8DD1us49YVkvc5BD1uv87qHrdd5w8PW67zpYet13vKw9Tpve9h6nXc8bL3OIQ9br3PYw9brHPGw9TpHPWy9zjEPW69z3MPW6zj1hWS9TjvF1uvkKrZeJ0+x9ToexdbrKMXW67RXbL1OvmLrdQoUW6/TQbH1Oh0VW6/TSbH1Op0VW6/TRbH1Ol0VW6/TTbH1Ot0VW6/TQ7H1Oj0VW6/TS7H1Or0VW6/TR7H1OoWKrdfpq9h6nX6Krdfpr9h6nQGKrdcZqNh6nUGKrdc5Q7H1Omcqtl7nLMXW65yt2HqdcxRbrzNYsfU6QxRbrzNUsfU6RYqt1xmm2Hqd4Yqt1xmh2HqdkYqt1xml2Hqd0Yqt1xmj2Hqd4lP8IPv6wjBcXxiG6wvDcH1hGK4vDMP1hWG4vjAM1xeG4frCMFxfGIbrC8NwfWEYri8Mw/WFYbi+MAzXF5L1gE59IVkP6NQXkvWATn0hWQ/o1BeS9YBOfSFZD+jUF5L1gE59IVkP6NQXkvWATn0hWQ/o1BeS9YBOfSFZD+jUF5L1gE59IVkP6NQXOvWAdP1ees3df6pd+0/1e6uLuPq9HWD93k6h+r2dafV717g+F6J+bxy4/vlPuB7mFbgeZhNcD7MZroepgOthtsD1MJVwPUwVXA9TDdfD1MD1MLVwPUwdXA9TD9fDNMD1MI1wPUwTXA/TDNfDtMD1MFvhephtcD3Mdrge5lW4HmYHXA+zE66H2QXXw+yG62H2wPUwe+F6mH1wPcx+uB7mgIeth3Hq98h6mIMeth7mdQ9bD/OGh62HedPD1sO85WHrYd72sPUw73jYephDHrYe5rCHrYc54mHrYY562HqYYx62Hua4h62HyYHrYdrB9TC5cD1MnmLrYTyKrYdRcD1Me7geJl+x9TAFcD1MB7gepiNcD9NJsfUwnRVbD9NFsfUwXeF6mG5wPUx3uB6mB1wP01Ox9TC9FFsP01ux9TB94HqYQsXWw/SF62H6KbYepj9cDzNAsfUwAxVbDzNIsfUwZ8D1MGcqth7mLLge5my4HuYcxdbDDFZsPcwQxdbDDIXrYYoUWw8zDK6HGa7YepgRcD3MSMXWw4xSbD3MaMXWw4yB62GKFV8PQ9avbIbrVyrg+pUtcP1KJVy/UgXXr1TD9Ss1cP1KLVy/UgfXr9TD9SsNcP1KI1y/0qTY91nN1l41W+B9VqvBepg14Hh3gvUwu4TqYXal1cNc5fpciHqY8XA9DLm//Aq8v7wJ3l/eDO8vV8D7y1vg/eVKeH+5Ct5frob3l2vg/eVaeH+5Dt5frof3lxvg/eVGeH+5Cd5fbob3l1vg/eWt8P7yNnh/eTu8v/wqvL+8A95f3gnvL++C95d3w/vLe+D95b3w/vI+eH95P7y/fMDD7i879TDk/vJBD7u//LqH3V9+w8PuL7/pYfeX3/Kw+8tve9j95Xc87P7yIQ+7v3zYw+4vH/Gw+8tHPez+8jEPu7983MPuL+fA+8vt4P3lXHh/OQ/eX/bA+8sK3l9uD+8v58P7ywXw/nIHeH+5I7y/3AneX+4M7y93gfeXu8L7y93g/eXu8P5yD3h/uSe8v9wL3l/uDe8v94H3lwvh/eW+8P5yP3h/uT+8vzwA3l8eCO8vD4L3l8+A95fPPMUPsq+HmQ3Xw8yG62Fmw/Uws+F6mNlwPcxsuB5mNlwPMxuuh5kN18PMhuthZsP1MLPhepjZcD3MbLgeZjZcD0PWr2yG61cq4PqVLXD9SiVcv1IF169Uw/UrNXD9Si1cv1IH16/Uw/UrDXD9SqOSef/KGrDeZC1Yb7ILrDfZLVRvsjut3mSx63Mh6k0mwPUm5P7tK/D+7SZ4/3YzvH9bAe/fboH3byvh/dsqeP+2Gt6/rYH3b2vh/ds6eP+2Ht6/bYD3bxvh/dsmeP+2Gd6/bYH3b7fC+7fb4P3b7fD+7avw/u0OeP92J7x/uwvev90N79/ugfdv98L7t/vg/dv98P7tAQ+7f+vUm5D7twc97P7t6x52//YND7t/+6aH3b99y8Pu377tYfdv3/Gw+7eHPOz+7WEPu397xMPu3x71sPu3xzzs/u1xD7t/mwPv37aD929z4f3bPHj/1gPv3yp4/7Y9vH+bD+/fFsD7tx3g/duO8P5tJ3j/tjO8f9sF3r/tCu/fdoP3b7vD+7c94P3bnvD+bS94/7Y3vH/bB96/LYT3b/vC+7f94P3b/vD+7QB4/3YgvH87CN6/PQPevz1TYP+W3G/dDO+3VsD7rVvg/dZKeL+1Ct5vrYb3W2vg/dZaeL+1Dt5vrYf3WxsU+76A5doLlgu8L2AtuH97Izje3eD+7R6h/ds9afu3C12fC7F/OxHevyX3Q16B90M2wfshm+H9kAp4P2QLvB9SCe+HVMH7IdXwfkgNvB9SC++H1MH7IfXwfkgDvB/SCO+HNMH7Ic3wfkgLvB+yFd4P2Qbvh2yH90NehfdDdsD7ITvh/ZBd8H7Ibng/ZA+8H7IX3g/ZB++H7If3Qw542P0QZ/+W3A856GH3Q173sPshb3jY/ZA3Pex+yFsedj/kbQ+7H/KOh90POeRh90MOe9j9kCMedj/kqIfdDznmYfdDjnvY/ZAceD+kHbwfkgvvh+TB+yEeeD9Ewfsh7eH9kHx4P6QA3g/pAO+HdIT3QzrB+yGd4f2QLvB+SFd4P6TbKX6Q/f7tcnj/djm8f7sc3r9dDu/fLof3b5fD+7fL4f3b5fD+7XJ4/3Y5vH+7HN6/XQ7v3y6H92+Xw/u3y+H9W3K/dTO831oB77dugfdbK+H91ip4v7Ua3m+tgfdba+H91jp4v7Veyfz71hvB/dF14P7oHnB/dK/Q/ujetP3RWa7PhdgfnQTvj5L7Da/A+w2b4P2GzfB+QwW837AF3m+ohPcbquD9hmp4v6EG3m+ohfcb6uD9hnp4v6EB3m9ohPcbmuD9hmZ4v6EF3m/YCu83bIP3G7bD+w2vwvsNO+D9hp3wfsMueL9hN7zfsAfeb9gL7zfsg/cb9sP7DQc87H6Dsz9K7jcc9LD7Da972P2GNzzsfsObHna/4S0Pu9/wtofdb3jHw+43HPKw+w2HPex+wxEPu99w1MPuNxzzsPsNxz3sfkMOvN/QDt5vyIX3G/Lg/QYPvN+g4P2G9vB+Qz6831AA7zd0gPcbOsL7DZ3g/YbO8H5DF3i/oSu839BNYL+B3B/YDO8PVMD7A1vg/YFKeH+gCt4fqIb3B2rg/YFaeH+gTrH/HmuNnmtOo/cb1oH7DTeB490L7jfsE9pv2Je23zDD9bkQ+w2T4f0Gcv3uFXj9bhO8frcZXr+rgNfvtsDrd5Xw+l0VvH5XDa/f1cDrd7Xw+l0dvH5XD6/fNcDrd43w+l0TvH7XDK/ftcDrd1vh9btt8Prddnj97lV4/W4HvH63E16/2wWv3+2G1+/2wOt3e+H1u33w+t1+eP3ugIddv3P2G8j1u4Medv3udQ+7fveGh12/e9PDrt+95WHX7972sOt373jY9btDHnb97rCHXb874mHX74562PW7Yx52/e64h12/yzllPT/7/YY18H7DGni/YQ2837AG3m9YA+83rIH3G9bA+w1r4P2GNfB+wxp4v2ENvN+wBt5vWAPvN6yB9xvWwPsN5P7AZnh/oALeH9gC7w9UwvsDVfD+QDW8P1AD7w/UCv37gZvA9fybwfX8feB6/n6h9fz9aev5UdfnQqznT4HX88n1sVfg9bFN8PrYZnh9rAJeH9sCr49VwutjVfD6WDW8PlYDr4/VwutjdfD6WD28PtYAr481wutjTfD6WDO8PtYCr49thdfHtsHrY9vh9bFX4fWxHfD62E54fWwXvD62G14f2wOvj+2F18f2wetj++H1sQMedn3MWc8n18cOetj1sdc97PrYGx52fexND7s+9paHXR9728Ouj73jYdfHDnnY9bHDHnZ97IiHXR876mHXx4552PWx4x52fSxHYH1sKrw+Ng1eH5sOr4/NgNfHZsLrY7Pg9bHZ8PoYWe+6Ud/LGwXqXW8G18duAce7H1wfOyC0PnYgbX0s7PpciPWxqfD6GPm8+Qr8vLkJft7cDD9vVsDPm1vg581K+HmzCn7erIafN2vg581a+HmzDn7erIefNxvg581G+HmzCX7ebIafN1vg582t8PPmNvh5czv8vPkq/Ly5A37e3Ak/b+6Cnzd3w8+be+Dnzb3w8+Y++HlzP/y8eeAUP8h+fWwjvD62EV4f2wivj22E18c2wutjG+H1sY3w+thGeH1sI7w+thFeH9sIr49thNfHNsLrYxvh9bGN8PrYNHh9bDq8PjYDXh+bCa+PzYLXx2bD62MS9Vm3gOtPt4LrTwfA9afXhNafXktbfxru+lyI9adp8PoT+Tz3Cvw8twl+ntsMP89VwM9zW+DnuUr4ea4Kfp6rhp/nauDnuVr4ea4Ofp6rh5/nGuDnuUb4ea4Jfp5rhp/nWuDnua3w89w2+HluO/w89yr8PLcDfp7bCT/P7YKf53bDz3N74Oe5vfDz3D74eW4//Dx3wMM/z02Hn+dmwM9zM+HnuVnw89xs+HmOrCd4XN8rjwvUE9wKPs/dBo73NfB57qDQ89zBtOe5ItfnQjzPTYef50g+egXmo00wH22G+agC5qMtMB9VwnxUBfNRNcxHNTAf1cJ8VAfzUT3MRw0wHzXCfNR0ih9k/zz3OPw89zj8PPc4/Dz3OPw89zj8PPc4/Dz3OPw89zj8PPc4/Dz3OPw89zj8PPc4/Dz3OPw89zj8PPc4/Dw3A36emwk/z82Cn+dmw89zEvtft4HPS7eDz0sHweel14Wel15Pe14qdH0uxPPSDPh5ieSPV2D+2ATzx2aYPypg/tgC80clzB9VMH9Uw/xRA/NHLcwfdTB/1MP80QDzRyPMH00C/DET5o9ZMH/MhvmDXK99Rn8Wzwis194O8sd6cLyvg/zxhhB/vJHGH71dnwvBHzNh/ngc5o9nYP54BuaPZ2D+eAbmj2dg/ngG5o9nYP54BuaPZ2D+eAbmj2dg/ngG5o9nYP54BuaPZ2D+mAXzx2yYPyTWF9aD+f0OML+/Aeb3N4Xy+5tp+V25Phciv8+C8zs9X2bD84Xk4Rf0WF8Q4OE7wPlyJzjeN8H58pbQfHkrbb7kCcyX2fB8eQGeLxL+fSd4P94F3o9vgffj20L349tp92Mu9Lmc0Ozcj3OKMN0+5350WoY648m2dfruAjWSn5Mn9TkV5Pz7i/pbzr3Q09V3O/Zv+LYqTq+UxhYDNDYboLHJAI2NBmhsMEBjvQEa6wzQWGuAxhoDNFYboLHKAI2VBmjcYoDGCgM0bjZA4yYDNDrPPJRGR9vQnJMvWu/bBsT0HQM0HjJA42EDNB4xQONRAzQeM0DjcQM05rQ//TW2M0BjrgEa8wzQ6DFAozJAY3sDNOYboLHAAI0dDNDY0QCNnQzQ2NkAjV0M0NjVAI3dDNDY3QCNPQzQ2NMAjb0M0NjbAI19DNBYaIDGvgZo7GeAxv4GaBxggMaBoEZH28ycky+7Nn56arRr44xGuzbOaLRr44xGuzbOaLRr44xGuzbOaLRr44xGuzbOaLRr44xGuzbOaLRr44xGuzbOaLRr44xGuzbOaLRr44xGuzbOaPxvWxvPcV22X9uv7df2a/u1/dp+bb+2X9uv7df2+36v1t4Vk8v+Dd85WTwP+Vxfj8ikL1/bP5Yabwk43nBGfZW3eUmNdxw43qkGjHcOON65Box3ETjeFQaMdyU43lUGjHcdON71Box3Azjehw0Y7yPgeB8zYLxPgON90oDxPg2O91kDxvscON4XDBjvi+B4XzJgvBXgeOsMGO9WcLy7DRjvQXC8hwwYb7t8brwF+af/eLuB4y1M6yvbdxh/EO/FfcuAWv83DdD4hgEaXzdA40EDNL5mgMYDBmjcb4DGfQZo3GuAxj0GaNxtgMZdBmjcaYDGHQZofNUAjdsN0LgN1PhBMPmIotM/piMN0DjKAI2jDdA4xgCNxQZoHGuAxhIDNHoN0OgzQKPfAI0BAzQGDdAYMkBj2ACNEQM0Rg3QGAM1WiZ/T6NlckajZXJGo2VyRqNlckajZXJGo2VyRqNlckajZXJGI83kJzSeYPN3huXkHNLtsG5HdDuq2zHdjuuWM1z//+qWq1uebh7dlG7tdcvXrUC3Drp1HP7/xo0HYDgYAOcAbad1zvn3F/W3PogHIHuANqPRHqDNaLQHaDMa7QHajEZ7gDaj0R6gzWi0B2gzGu0B2oxGe4C2PSTEm+UlpdEeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHqBt18a9WV5SGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu0B2rZf26/t1/Zr+7X92n5tv7Zf26/t1/b7/q7W3hWTy/4Ne4B2Jr/s+toeoN3W9eGM1x6gncEvu762B2i3dX0447UHaGfwy66v7QHabV0fznjtAdoZ/LLra3uAdlvXhzNee4B2Br/s+toeoN3W9eGM1x6gncEvu762B2jbA7S92V32AG1Ioz1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7QZjfYAbV6jPayP0WgP62M02sP6GI32sD5Goz2sj9FoD+tjNNrD+hiN9rA+RiN9WN8Jfe6L/BuW+y33Uxot9zMaLfczGi33Mxot9zMaLfczGi33Mxot9zMaLfefcvmcg8UpvVIaDxmg8bABGo8YoPGoARqPGaDxuAEac4af/hrbGaAx1wCNeQZo9BigURmgsb0BGvMN0FhggMYOBmjsCGr8ALjfl5cWhxP830mPobNuXXTrqls33brr1kO3nrr10q23bn10K9Str279dOuv2wDdBuo2aPjJfZ6hvz5Tt7N0O1u3c3QbrNsQ3YbqVqTbMN2G6zZCt5G6jdJttG5jdCvWbWyqzxPndZfor726+XTz6xbQLahbSLewbhHdorrFdDtXt/N0O1+3cbqN122C81npNkm3ybpN0W2qbtN0m67bDN1m6jZLt9m6zdHtAt0u1O0i3S7W7RLdLtVt7vC0z4q+qYbDD7wS+joNP7XfbP9hyGXwZMpLjd3p9xbBz6qzQCwuF4rF5cKx6CIQi3lCsZgnHIuuArGYLxSL+cKx6CYQiwVCsVggHIvuArFYKBSLhcKx6CEQi0VCsVgkHIueArFYLBSLxcKx6CUQiyVCsVgiHIveArFYKhSLpcKx6CMQi2VCsVgmHItCgVgsF4rFcuFY9BWIxRVCsbhCOBb9BGKxQigWK4Rj0V8gFqVCsSgVjsUAgViUCcWiTDgWAwViEReKRVw4FoMEYpEQioXTb9dUv7mw5pdz34sFFVunKMRpdGy/PeL0Xx8sEbin/meEzD3l9NtOcH55BWLxlFAsnhKOhU8gFt8RisV3hGPhF4jFd4Vi8V3hWAQEYvG0UCyeFo5FUCAWzwjF4hnhWIQEYvE9oVh8TzgWYYFYfF8oFt8XjkVEIBY/EIrFD4RjERWIxQ+FYvFD4VjEBGLxI6FY/Eg4FucKxOJZoVg8KxyL8wRi8WOhWPxYOBbnC8TiJ0Kx+IlwLMYJxOKnQrH4qXAsxgvE4mdCsfiZcCwmCMTi50Kx+LlwLCYKxOIXQrH4hXAsJgnE4jmhWDwnHIvJArH4pVAsfikciykCsfhfoVj8r3AspgrE4nmhWDwvHItpArH4P6FY/J9wLKYLxOJXQrH4lXAsZgjE4tdCsfi1cCxmCsTiBaFYvCAci1kCsfiNUCx+IxyL2QKx+K1QLH4rHIs5ArH4nVAsficciwsEYvF7oVj8XjgWFwrE4g9CsfiDcCwuEojFH4Vi8UfhWFwsEIsXhWLxonAsLhGIxZ+EYvGntFi465t84fJwuLQ0lCiNeUORSDAUi4dCkXDUH9DSQ/FYKBLwRqKBRChUXhYvjUd9iZg/Fo+Ulob9gZgvHN6q3vt3e//qLxZOJAPxhDdc6gtGy0KhZLQ0mQwmQ8lIQockkPB5AxGvt8wfKEuU6v794aAOgS8WjCXi4WSszHmxo9OUW2eW/Z50UHW0LFIe8MWTeqjhZCgcjcXL4v6w/gtBfzSYSMb93lh5NBosL/dFkmFvoDQU8kb9wWR5LKz/ZDyYflB1tvHL5IU2wf/w85Lh3L34Z+5e9EnNwT+P4OfgX4TmoNPvnal+8+A52OKeg8Cc7pxes+iPRCIxf8Qf93nLfUGfNxgP6akQDpRFoqXxeGkklvCXR+IJ/T9foszr0/NLT6hYsjRQFk0kAiFnPjsvQ82H53QJOKfD4JxOfwHU+70fk+8e4xf3lQzn/MEL+nS6P2Q75/46Aot9RMpr/irgNX8T8pq/pXmNgr2mGfaaFpfXEN7VBfau9JckZztvRgp54TjQC6eCXngY9EIv6IU+0Av/Cnrh3w3wwr8LeOFLQl74UpoXts9hvbAJ9sJm2AtbXF5IeGtX2FtPerl7lv2NTHk17a1zQG+dC3rrEdBbfaC3+kFv/Tvorf8wwFv/IeCtLwt568tp3lrgnnNZ3tuNsLc2wd7aDHtri8tbCa/uBnv1GNirR4NcPUrI+xeB3r8C9P6joPf7Qe8PgN7/D9D7/2mA9/9TwPtfEfL+V9K8v4N7zmV5bzfA3t8Ie38T7P3NsPe3uLyfyCXd4VxSDOcSMjeNSuUmOpesBHPJKjCXHANzSQDMJUEwl/wTzCWbDMglmwRyyWahXLI5LZd0cs+5LO/tejiXNMC5pBHOJU1wLmmGc0mLK5cQuakHnJvGwrmpGM5NY8DnptFCuW4dmOvWg7nuOJjrgmCuC4G5bhOY6yoMyHUVArlui1Cu25KW6zq751yW93YdnOvq4VzXAOe6RjjXNcG5rhnOdS2uXEfkzp5w7iyBc+dYOHeSuXh0KhfTuXMDmDsfBnNnznAud4bA3BkGc2cFmDsrDcidlQK5s0ood1al5c6u7jmX5b1dC+fOOjh31sO5swHOnY1w7myCc2cznDtbXLmTyMW94FzshXNxCZyLx8K5uBh8Lh4jlNsfAXP7Y2Bubwfm9jCY2yNgbq8Ec3u1Abm9WiC31wjl9pq03N7NPeeyvLdr4NxeC+f2Oji318O5vQHO7Y1wbm+Cc3sznNtbXLmdYIXeMCv4YFbwwqxQArMCyR5jUuxBs8ITICs8CbJCLsgKEZAVoiArVIOsUGsAK9QKsEKdECvUpbFCD/ecy/LeroZZoQZmhVqYFepgVqiHWaEBZoVGmBWaYFZohlmhxcUKBHv0gdnDD7OHD2YPL8weJTB7jAXXPYqFWOZpkGWeBVkmD2SZKMgyMZBlakGWqTeAZeoFWKZBiGUa0limp3vOZXlvV8EsUw2zTA3MMrUwy9TBLFMPs0wDzDKNMMs0wSzTDLNMi4tlCDYqhNkoALORH2YjH8xGXpiNSNYqTrEWzUbPgWz0AshGHpCNYiAbnQuyUT3IRo0GsFGjABs1CbFRUxob9XbPuSzv7UqYjapgNqqG2agGZqNamI3qYDaqh9moAWajRpiNmmA2aobZqMXFRgRr9YVZKwizVgBmLT/MWj6Ytbwwa5WA61pjhdjtRZDdXgLZTYHsdi7IbueB7NYIsluzAezWLMBuLULs1pLGbn3ccy7Le3sLzG6VMLtVwexWDbNbDcxutTC71cHsVg+zWwPMbo0wuzXB7NYMs1uLi90IFuwHs2AIZsEgzIIBmAX9MAv6YBYk2XJsii1pFqwAWbAOZMH2IAueB7Lg+SALNoMsuNUAFtwqwILbhFhwWxoL9nXPuSzv7QqYBbfALFgJs2AVzILVMAvWwCxYC7NgHcyC9TALNsAs2AizYBPMgs0wC7a4WJBgy/4wW4ZhtgzBbBmE2TIAs6UfZksfzJZecN2yRIhVt4Ksuhtk1XyQVc8HWXUcyKpbQVbdbgCrbhdg1VeFWPXVNFbt555zWd7bm2FWrYBZdQvMqpUwq1bBrFoNs2oNzKq1MKvWwaxaD7NqA8yqjTCrNsGs2gyzaouLVQn2HQCzbwRm3zDMviGYfYMw+wZg9vXD7EuydEmKpWn2PQiy7yGQfQtA9h0Hsu94kH23g+y7wwD23SHAvjuF2HdnGvsOcM+5LO/tTTD7bobZtwJm3y0w+1bC7FsFs281zL41MPvWwuxbB7NvPcy+DTD7NsLs2wSzbzPMvi0u9iVYeiDM0lGYpUk2HwWz+WiYzcfAbF4Ms/lYmM1LXGyeLcd5hdi8XT7H5gX53PztALL5eJDNJ4BsvgNk810GsPkuATbfLcTmu9PYfKB7zmV5b7+cy7L5JpjNN8NsXgGz+RaYzSthNq+C2bwaZvMamM1rYTavg9m8HmbzBpjNG2E2b4LZvBlm8xYXmxOsPwhm/RjM+uSzwyj42WE0/OwwBn52KIafHcbCzw4l8LODN/XsQLN+N5D1C0HW7wiy/gSQ9SeCrL8LZP09HOuHnT4kWH+PAOvvFWL9vYLr8A7rd4ZZvwvM+l1h1u8Gs353mPV7wKzfE2b9XjDr94ZZvw/M+oUw6/eFWb8fzPr9YdYfALP+QJj1STYfCbP5KJjNR8NsPgZm82KYzcfCbF4Cs7nXxebZcpwvxeaeVH8n+s2WWyeC3DoJ5NY9ILfuA/nN6UOCW/cJcOt+IW7dL1g77XBrF5hbu8Lc2g3m1u4wt/aAubUnzK29YG7tDXNrH5hbC2Fu7Qtzaz+YW/vD3DoA5taBMLeSnDkK5szRMGeOgTmzGObMsTBnlsCc6YU505fiTJoLJ4FcOBnkwn0gFx4wgAsPCHDha0Jc+Jrg+x8cLuwKc2E3mAu7w1zYA+bCnjAX9oK5sDfMhX1gLiyEubAvzIX9YC7sD3PhAJgLB8JcSHLcaJjjxsAcVwxz3FiY40pgjvPCHOdzcVy2XOMX4rjJIMdNATnuAMhxBw3guIMCHPe6EMe9LvhOV4fjusEc1x3muB4wx/WEOa4XzHG9YY7rA3NcIcxxfWGO6wdzXH+Y4wbAHDcQ5jiSu8bA3FUMc9dYmLtKYO7ywtzlg7nLn+IumpOmgJw0FeSkgyAnvWEAJ70hwElvCnHSm4LnFjmc1B3mpB4wJ/WEOakXzEm9YU7qA3NSIcxJfWFO6gdzUn+YkwbAnDQQ5iSSa4phrhkLc00JzDVemGt8MNf4XVyTbZ4PCHHNVJBrpoFc8wbINW8ZwDVvCXDN20Jc87bgWdUO1/SAuaYnzDW9YK7pDXNNH5hrCmGu6QtzTT+Ya/rDXDMA5pqBMNeQHDIW5pASmEO8MIf4YA7xwxwSSHEIzQ3TQG6YDnLDWyA3vGMAN7wjwA2HhLjhUBo39HBpJrihJ8wNvWBu6A1zQx+YGwphbugLc0M/mBv6w9wwAOaGgTA3kHm+BM7zXjjP++A874fzfMCV57PNe0GhPD8dzPMzwDz/DpjnDxuQ5w8L5PkjQnn+SFqe7+bSTOT5XnCe7w3n+T5wni+E83xfOM/3g/N8fzjPD4Dz/EA4z5N52QvnZR+cl/1wXg7AeTmYyst0Hp0B5tGZYB49DObRowbk0aMCefSYUB49lpZHu7o0E3m0N5xH+8B5tBDOo33hPNoPzqP94Tw6AM6jA+E8SuY9H5z3/HDeC8B5L+jKe9nmgZBQ3psJ5r1ZYN47Cua94wbkveMCeS9npEzec/o9kfc6uzQTea8PnPcK4bzXF857/eC81x/OewPgvDcQzntknvLDeSoA56kgnKdCqTxF55VZYF6ZDeaV42BeaTfy9M8rjkY6r+QK5ZXctLzSyaWZyCuFcF7pC+eVfnBe6Q/nlQFwXhkI5xUyDwTgPBCE80DIlQey9cWwUB6YDeaBOWAeSPfubP0wz4A8kCeQBzxCecCTlgc6uDQTeaAvnAf6wXmgP5wHBsB5YCCcB0jfDsK+HYJ9O5zybdpn54A+ewHos3mgzyoDfFYJ+Gx7IZ9tn+azBS7NhM/2g322P+yzA2CfHQj7LOmLIdgXwy5fzNYnIkK+eAHoixeCvqhAX8w3wBfzBXyxQMgXC9J8sX0O74v9YV8cAPviQNgXSR8Lwz4WSfkY7TsXgr5zEeg7+aDvdDDAdzoI+E5HId/pmOY7SsB3BsC+MxD2HdInIi6fyHbeRIV84iLQJy4GfaID6BOdDPCJTgI+0VnIJzqn+USegE8MhH2CnNfR1Lym5+HF4Dy8BJyHncB52MWAedhFYB52FZqHXduYh/9BczzZtuZ3Y3HJcDa23x7Bf1Y57D3g9aRiWZDz7y/qbzmfYU9X3/Q97ZwxTemV0thigMZmAzQ2GaCx0QCNDQZorDdAY50BGmsN0FhjgMZqAzRWGaCx0gCNWwzQWGGAxs0GaNxkgEZnzYDS6GgbmnPyRet924CYvmOAxkMGaDxsgMYjBmg8aoDGYwZoPG6ARmfT+3TX2M4AjbkGaMwzQKPHAI3KAI3tDdCYb4DGAgM0djBAY0cDNHYyQGNnAzR2MUBjVwM0djNAY3cDNPYwQGNPAzT2MkBjbwM09jFAY6EBGvsaoLGfARr7G6BxgAEaB4IaHW0zc06+7Nr46anRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPxv21tPMd12X5tv7Zf26/t1/Zr+7X92n5tv7Zf2+/7vVp7V0wu+zd852TxPORzfT0ik758bf9Yarwl4HjDGfVV3uYlNd5x4HinGjDeOeB45xow3kXgeFcYMN6V4HhXGTDedeB41xsw3g3geB82YLyPgON9zIDxPgGO90kDxvs0ON5nDRjvc+B4XzBgvC+C433JgPFWgOOtM2C8W8Hx7jZgvAfB8R4yYLzt8rnxFuSf/uPtBo63MK2vrM+1zZF/L+5bBtT6v2mAxjcM0Pi6ARoPGqDxNQM0HjBA434DNO4zQONeAzTuMUDjbgM07jJA404DNO4wQOOrBmjcboDGbaDGD4LJ3xl2+sf0kAEaDxug8YgBGo8aoPGYARqPG6AxZ/jpr7GdARpzDdCYZ4BGjwEalQEa2xugMd8AjQUGaOxggMaOoEbL5O9ptEzOaLRMzmi0TM5otEzOaLRMzmi0TM5otEzOaLRMzmikmfyExhNs3m1kTk533Xro1lO3Xrr11q2PboW69dWtn279dRug20DdBul2hm5n6naWbmennUuOB8A5TJsKgHOAttM65/z7i/pbH8QDkD1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7QZjfYAbUajPUDbHhLizfKS0mgPCWE02kNCGI32kBBGoz0khNFoDwlhNNpDQhiN9pAQRqM9JITRaA8JYTTaQ0IYjfaQEEajPSSE0WgPCWE02kNCGI32kBBGoz0khNFoD9C2a+PeLC8pjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjfYAbduv7df2a/u1/dp+bb+2X9uv7df2a/t9f1dr74rJZf+GPUA7k192fW0P0G7r+nDGaw/QzuCXXV/bA7Tbuj6c8doDtDP4ZdfX9gDttq4PZ7z2AO0Mftn1tT1Au63rwxmvPUA7g192fW0P0G7r+nDGaw/QzuCXXV/bA7TtAdre7C57gDak0R6gzWi0B2gzGu0B2oxGe4A2o9EeoM1otAdoMxrtAdqMRnuAtsC/q7eH9SEa7WF9jEZ7WB+j0R7Wx2i0h/UxGu1hfYxGe1gfo9Ee1sdopA/rO6HPfZF/w3K/5X5Ko+V+RqPlfkaj5X5Go+V+RqPlfkaj5X5Go+V+RqPl/lMun3OwOKVXSmN3AzT2MEBjTwM09jJAY28DNPYxQGOhARr7GqCxnwEa+xugcYABGgcaoHGQARrPMEDjmQZoPMsAjWeDGj8A7vflpcXhBP+fo8cwWLchug3VrUi3YboN122EbiN1G6XbaN3G6Fas21jdSnTz6ubTzT/y5D4D+uugbiHdwrpFdIvqFtPtXN3O0+183cbpNl63CU4cdZuk22Tdpug2NdXnifO6p+mvp+s2Q7eZus3SbbZuc3S7QLcLdbtIt4t1u0S3S3Wbq9tlul2u2zzd5uu2QLeFui3SbbFuS3Rbqtsy3ZbrdoVuK3Qr1a1Mt7huCd2SupXrtlK3K0emfVb0TTW8iL3xJfSdM/LUfrP9hyFXwZMpLzV2p99bBD+rwQKxuFooFlcLx2KIQCyuEYrFNcKxGCoQi2uFYnGtcCyKBGJxnVAsrhOOxTCBWKwSisUq4VgMF4jF9UKxuF44FiMEYnGDUCxuEI7FSIFYrBaKxWrhWIwSiMUaoVisEY7FaIFYrBWKxVrhWIwRiMWNQrG4UTgWxQKxWCcUi3XCsRgrEIubhGJxk3AsSgRicbNQLG4WjoVXIBa3CMXiFuFY+ARicatQLG4VjoVfIBa3CcXC6bdrqt9cWPPLue/FgoqtUxTiNDq2z486/dcHpwncU/83SuaecvptJzi/pgvE4ldCsfiVcCxmCMTi10Kx+LVwLGYKxOIFoVi8IByLWQKx+I1QLH4jHIvZArH4rVAsfiscizkCsfidUCx+JxyLCwRi8XuhWPxeOBYXCsTiD0Kx+INwLC4SiMUfhWLxR+FYXCwQixeFYvGicCwuEYjFn4Ri8SfhWFwqEIs/C8Xiz8KxmCsQi78IxeIvwrG4TCAWfxWKxV+FY3G5QCz+JhSLvwnHYp5ALP4uFIu/C8divkAsXhKKxUvCsVggEIt/CMXiH8KxWCgQi5eFYvGycCwWCcTin0Kx+KdwLBYLxOIVoVi8IhyLJQKx2CQUi03CsVgqEIvNQrHYLByLZQKxqBCKRYVwLJYLxGKLUCy2CMfiCoFYVArFolI4FisEYlElFIsq4ViUCsSiWigW1cKxKBOIRY1QLGqEYxEXiEWtUCxqhWOREIhFnVAs6oRjkRSIRb1QLOqFY1EuEIsGoVg0pMXCXd/kC5eHw6WloURpzBuKRIKhWDwUioSj/oCWHorHQpGANxINJEKh8rJ4aTzqS8T8sXiktDTsD8R84fBW9d6/2/tXf7FwIhmIJ7zhUl8wWhYKJaOlyWQwGUpGEjokgYTPG4h4vWX+QFmiVPfvDwd1CHyxYCwRDydjZc6LHZ2m3Dqz7Pekg6qjZZHygC+e1EMNJ0PhaCxeFveH9V8I+qPBRDLu98bKo9Fgebkvkgx7A6WhkDfqDybLY2H9J+PB9IOqs41fJi+0Cf6Hn08byd2Ljdy96JOag42j+DnYJDQHnX7vTPWbB8/BFvccBOb04PT70h+JRGL+iD/u85b7gj5vMB7SUyEcKItES+Px0kgs4S+PxBP6f75Emden55eeULFkaaAsmkgEQs58dl6Gmg/P6RJwTofBOd0dmIfJd4/xi/umgf4wHfTpdH/Ids41j8JiH5HymmYBr2kR8pqWNK9RsNc0w17T4vIawruGwN6V/pLkbOfNISEvHAd64VTQC3uAXjgd9MIZoBc2g1641QAv3CrghduEvHBbmhe2z2G9sAn2wmbYC1tcXkh461DYW096uXuW/R1KeTXtrXNAb50LemtP0FtngN46E/TWraC3bjfAW7cLeOurQt76apq3FrjnXJb3diPsrU2wtzbD3tri8lbCq4tgrz4Ke/URkKsPC3n/ItD7V4De3wv0/pmg988CvX876P07DPD+HQLev1PI+3emeX8H95zL8t5ugL2/Efb+Jtj7m2Hvb3F5P5FLhsG55BicS8jcdDiVm+hcshLMJavAXNIbzCWzwFwyG8wlO8BcssuAXLJLIJfsFsolu9NySSf3nMvy3q6Hc0kDnEsa4VzSBOeSZjiXtLhyCZGbhsO56Ticm47Bueko+Nx0RCjXrQNz3Xow1/UBc91sMNfNAXPdLjDX7TEg1+0RyHV7hXLd3rRc19k957K8t+vgXFcP57oGONc1wrmuCc51zXCua3HlOiJ3joBz50mHowK58zicO8lcfCSVi+ncuQHMnQ+DubMQzJ1zwNx5AZg794C5c58BuXOfQO7cL5Q796flzq7uOZflvV0L5846OHfWw7mzAc6djXDubIJzZzOcO1tcuZPIxSPhXNwOzsVkbj8M5/YjrtyebR44KpTbHwFz+2Ngbu8L5vYLwNx+IZjb94G5/YABuf2AQG5/TSi3v5aW27u551yW93YNnNtr4dxeB+f2eji3N8C5vRHO7U1wbm+Gc3uLK7cTrDAKZoVcmBXawaxAsscRmD2OptiDZoUnQFZ4EmSFfiArXAiywkUgKxwAWeGgAaxwUIAVXhdihdfTWKGHe85leW9Xw6xQA7NCLcwKdTAr1MOs0ACzQiPMCk0wKzTDrNDiYgWCPUbD7JEHs0cuzB7tYPYgWeaoi2WyzXvHhFjmaZBlngVZpj/IMheBLHMxyDIHQZZ5wwCWeUOAZd4UYpk301imp3vOZXlvV8EsUw2zTA3MMrUwy9TBLFMPs0wDzDKNMMs0wSzTDLNMi4tlCDYaA7ORB2ajPJiNcmE2agezEclax1KsRbPRcyAbvQCy0QCQjS4G2egSkI3eANnoLQPY6C0BNnpbiI3eTmOj3u45l+W9XQmzURXMRtUwG9XAbFQLs1EdzEb1MBs1wGzUCLNRE8xGzTAbtbjYiGCtYpi1FMxaHpi18mDWyoVZqx3MWunslm2ePy7Ebi+C7PYSyG4DQXa7BGS3S0F2ewtkt3cMYLd3BNjtkBC7HUpjtz7uOZflvb0FZrdKmN2qYHarhtmtBma3Wpjd6mB2q4fZrQFmt0aY3ZpgdmuG2a3FxW4EC46FWbA9zIIKZkEPzIJ5MAvmwixIsuXxFFvSLFgBsmAdyIKDQBa8FGTBuSALvgOy4GEDWPCwAAseEWLBI2ks2Nc957K8tytgFtwCs2AlzIJVMAtWwyxYA7NgLcyCdTAL1sMs2ACzYCPMgk0wCzbDLNjiYkGCLUtgtsyH2bI9zJYKZksPzJZ5MFvmwmzZDly3dDhVglW3gqy6G2TVM0BWnQuy6mUgqx4GWfWoAax6VIBVjwmx6rE0Vu3nnnNZ3tubYVatgFl1C8yqlTCrVsGsWg2zag3MqrUwq9bBrFoPs2oDzKqNMKs2wazaDLNqi4tVCfb1wuxbALNvPsy+7WH2VTD7emD2zYPZl2Rph3vbCbDvQZB9D4HseybIvpeB7Hs5yL5HQfY9bgD7Hhdg35zRMuzr9HuCfQe451yW9/YmmH03w+xbAbPvFph9K2H2rYLZtxpm3xqYfWth9q2D2bceZt8GmH0bYfZtgtm3GWbfFhf7Eiztg1m6A8zSBTBL58Ms3R5maQWztAdm6TyYpXPBdel2QmzeLp9j84J8bv6eBbL55SCbzwPZ/DjI5u1Gn/5s7mik2TxXiM1z09h8oHvOZXlvv5zLsvkmmM03w2xeAbP5FpjNK2E2r4LZvBpm8xqYzWthNq+D2bweZvMGmM0bYTZvgtm8GWbzFhebE6zvh1m/I8z6HWDWL4BZPx9m/fYw6yuY9T0w65PPDu1Szw4063cDWb8QZP2zQdafB7L+fJD10/k8W+bN41g/7PQhwfp5AqzvEWJ9j+A6vMP6g2HWHwKz/lCY9Ytg1h8Gs/5wmPVHwKw/Emb9UTDrj4ZZfwzM+sUw64+FWb8EZn0vzPo+mPVJNj8Es/lhmM2PwGx+FGbzYzCbH4fZ3GFpD8zSeeA6fG6KzT2p/k70my23zge5dQHIrXkgtyqQ35w+JLhVCXBreyFubT9arnba4dYhMLcOhbm1CObWYTC3Doe5dQTMrSNhbh0Fc+tomFvHwNxaDHPrWJhbS2Bu9cLc6oO5leTMwzBnHoE58yjMmcdgzjwOc6bDhQrmQpIzc1OcSXPhApALF4JcqEAuzDeAC/MFuLBAiAsLRsu9/8HhwqEwFxbBXDgM5sLhMBeOgLlwJMyFo2AuHA1z4RiYC4thLhwLc2EJzIVemAt9MBeSHHcE5rijMMcdgznuOMxxDne1h7lLwdzlAdf38oQ4biHIcYtAjssHOa6DARzXQYDjOgpxXMfRcu90dTiuCOa4YTDHDYc5bgTMcSNhjhsFc9xomOPGwBxXDHPcWJjjSmCO88Ic54M5juSuozB3HYO56zjMXe++MwrmpPYwJ5HclZfiLpqTFoGctBjkpA4gJ3UygJM6CXBSZyFO6jxa7twih5OGwZw0HOakETAnjYQ5aRTMSaNhThoDc1IxzEljYU4qgTnJC3OSD+YkkmuOwVxzHOYah0MKYA7JhzmkPcwhClz/8QhxzWKQa5aM5MbbCeSaLgZwTRcBrukqxDVdR8udVe1wDckhm2AO2QxzSAXMIVtgDqmEOaQK5pBqmENqYA6phTmkDuaQephDjsMc4nBDB5gbCmBuyIe5geQQT4pDaG5Iz/X/KXf8J25YCnJDF5AbuhnADd0EuKG7EDd0T+OGHi7NBDeMgLlhJMwNo2BuGA1zwxiYG4phbhgLc0MJzA1emBt8MDeQed7Jyx3hvNwBzssFcF7Oh/Nye3B9QAnl+aVgnl8G5vluYJ7vYUCe7yGQ53sK5fmeaXm+m0szkedHwnl+FJznR8N5fgyc54vhPD8WzvMlcJ73wnneB+d5Mi+3g/NyLpyX8+C87IHzskrlZTqPLgPz6HIwj/YA82gvA/JoL4E82lsoj/ZOy6NdXZqJPDoKzqOj4Tw6Bs6jxXAeHQvn0RI4j3rhPOqD8yiZ93LhvJcH5z0PnPeUK+9lmwfaC+W95WDeuwLMe73AvNfHgLzXRyDvFQrlvcK0vNfZpZnIe6PhvDcGznvFcN4bC+e9EjjveeG854PzHpmn8uA85YHzlILzVPtUnqLzyhVgXlkB5pU+YF7pa0Be6SuQV/oJ5ZV+aXmlk0szkVfGwHmlGM4rY+G8UgLnFS+cV3xwXiHzgAfOAwrOA+1deSDrf88rlAdWgHmgFMwDfcE80N+APNBfIA8MEMoDA9LyQAeXZiIPFMN5YCycB0rgPOCF84APzgOkbyvYt9vDvp2f8m3aZ0tBny0DfbY/6LMDDfDZgQI+O0jIZwel+WyBSzPhs2Nhny2BfdYL+6wP9lnSF9vDvpjv8sVsfaJAyBfLQF+Mg744EPTFMwzwxTMEfPFMIV88M80X2+fwvlgC+6IX9kUf7Iukj+XDPlaQ8jHad+Kg7yRA3zkD9J2zDPCdswR852wh3zk7zXeUgO94Yd/xwb5D+kSByyeyfo+LkE8kQJ9Igj5xFugT5xjgE+cI+MRgIZ8YnOYTeQI+4YN9gpzXHVLzmp6HSXAeloPz8BxwHg4xYB4OEZiHQ4Xm4dA25uF/0BxPtq353ViUj2Rj+/wo/rPKYe8BrycVy4Kcf39Rf+vdfwvj6pu+p50zpim9UhpbDNDYbIDGJgM0NhqgscEAjfUGaKwzQGOtARprDNBYbYDGKgM0VhqgcYsBGisM0LjZAI2bDNDorBlQGt99rso5+aL1vm1ATN8xQOMhAzQeNkDjEQM0HjVA4zEDNB43QKOz6X26a2xngMZcAzTmGaDRY4BGZYDG9gZozDdAY4EBGjsYoLGjARo7GaCxswEauxigsasBGrsZoLG7ARp7GKCxpwEaexmgsbcBGvsYoLHQAI19DdDYzwCN/Q3QOMAAjQNBjY62mTknX3Zt/PTUaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzR+N+2Np7jumy/tl/br+3X9mv7tf3afm2/tl/br+33/V6tvSsml/0bvnOyeB7yub4ekUlfvrZ/LDXeEnC84Yz6Km/zkhrvOHC8Uw0Y7xxwvHMNGO8icLwrDBjvSnC8qwwY7zpwvOsNGO8GcLwPGzDeR8DxPmbAeJ8Ax/ukAeN9GhzvswaM9zlwvC8YMN4XwfG+ZMB4K8Dx1hkw3q3geHcbMN6D4HgPGTDedvnceAvyT//xdgPHW5jWV7bvS/4g3ov7lgG1/m8aoPENAzS+boDGgwZofM0AjQcM0LjfAI37DNC41wCNewzQuNsAjbsM0LjTAI07DND4qgEatxugcRuo8YNg8m4jT/+YdjdAYw8DNPY0QGMvAzT2NkBjHwM0Fhqgsa8BGvsZoLG/ARoHGKBxoAEaBxmg8QwDNJ5pgMazDNB4NqjRMvl7Gi2TMxotkzMaLZMzGi2TMxotkzMaLZMzGi2TMxotkzMaaSY/ofEEmxeNzskZpttw3UboNlK3UbqN1m2MbsW6jdWtRDevbj7d/LoFdAvqFtItnHYuOR4A5zBtKgDOAdpO65zz7y/qb30QD0D2AG1Goz1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7QZjfYAbXtIiDfLS0qjPSSE0WgPCWE02kNCGI32kBBGoz0khNFoDwlhNNpDQhiN9pAQRqM9JITRaA8JYTTaQ0IYjfaQEEajPSSE0WgPCWE02kNCGI32kBBGoz1A266Ne7O8pDTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTatXFGo10bZzTaA7Rtv7Zf26/t1/Zr+7X92n5tv7Zf26/t9/1drb0rJpf9G/YA7Ux+2fW1PUC7revDGa89QDuDX3Z9bQ/Qbuv6cMZrD9DO4JddX9sDtNu6Ppzx2gO0M/hl19f2AO22rg9nvPYA7Qx+2fW1PUC7revDGa89QDuDX3Z9bQ/Qtgdoe7O77AHakEZ7gDaj0R6gzWi0B2gzGu0B2oxGe4A2o9EeoM1otAdoMxrtAdoC/37CHtaHaLSH9TEa7WF9jEZ7WB+j0R7Wx2i0h/UxGu1hfYxGe1gfo5E+rO+EPvdF/g3L/V7L/ZBGy/2MRsv9jEbL/YxGy/2MRsv9jEbL/YxGy/2MRsv9p1w+52BxSq+UxmEGaBxugMYRBmgcaYDGUQZoHG2AxjEGaCw2QONYAzSWGKDRa4BGnwEa/QZoDBigMWiAxpABGsOgxg+A+315aXE4wf8RPYaobjHdztXtPN3O122cbuN1m+CMUbdJuk3WbYpuU3Wbptt03WboNnP0yX3O0l/P1m2ObhfodqFuF+l2sW6X6HapbnN1u0y3y3Wbp9t83RbotlC3RbotTvV54rzuJfrrpbot0225blfotkK3Ut3KdIvrltAtqVu5bit1u1K3q3S7WrdrdLtWt+t0W6Xb9brdoNtq3dbotla3G3Vbp9tNut2s2y263arbbbrdrtt63e7Q7c7RaZ8VDvxF7I0voS8y+tR+s/2HIXfBkykvNXan31sEP6uoQCzuForF3cKxiAnE4h6hWNwjHItzBWJxr1As7hWOxXkCsdggFIsNwrE4XyAW9wnF4j7hWIwTiMX9QrG4XzgW4wVisVEoFhuFYzFBIBYPCMXiAeFYTBSIxYNCsXhQOBaTBGLxkFAsHhKOxWSBWDwsFIuHhWMxRSAWHxGKxUeEYzFVIBYfFYrFR4VjMU0gFh8TisXHhGMxXSAWHxeKxceFYzFDIBafEIrFJ4RjMVMgFp8UioXTb9dUv7mw5pdz34sFFVunKMRpdGxfGXP6rw8uEbinNo2RuaecftsJzq+lArHYLBSLzcKxWCYQiwqhWFQIx2K5QCy2CMVii3AsrhCIRaVQLCqFY7FCIBZVQrGoEo5FqUAsqoViUS0cizKBWNQIxaJGOBZxgVjUCsWiVjgWCYFY1AnFok44FkmBWNQLxaJeOBblArFoEIpFg3AsVgrEolEoFo3CsbhSIBZNQrFoEo7FVQKxaBaKRbNwLK4WiEWLUCxahGNxjUAstgrFYqtwLK4ViMU2oVhsE47FdQKx2C4Ui+3CsVglEItXhWLxqnAsrheIxQ6hWOwQjsUNArHYKRSLncKxWC0Qi11CsdglHIs1ArHYLRSL3cKxWCsQiz1CsdgjHIsbBWKxVygWe4VjsU4gFvuEYrFPOBY3CcRiv1As9gvH4maBWBwQisUB4VjcIhCL14Ri8ZpwLG4ViMVBoVgcFI7FbQKxeF0oFq8Lx+J2gVi8IRSLN4RjsV4gFm8KxeLNtFi465t84fJwuLQ0lCiNeUORSDAUi4dCkXDUH9DSQ/FYKBLwRqKBRChUXhYvjUd9iZg/Fo+Ulob9gZgvHN6q3vt3e//qLxZOJAPxhDdc6gtGy0KhZLQ0mQwmQ8lIQockkPB5AxGvt8wfKEuU6v794aAOgS8WjCXi4WSszHmxo9OUW2eW/Z50UHW0LFIe8MWTeqjhZCgcjcXL4v6w/gtBfzSYSMb93lh5NBosL/dFkmFvoDQU8kb9wWR5LKz/ZDyYflB1tvHL5IU2wf/w8yWjuXvxLe5e9EnNwbfG8HPwbaE56PR7Z6rfPHgOtrjnIDCno+n3pT8SicT8EX/c5y33BX3eYDykp0I4UBaJlsbjpZFYwl8eiSf0/3yJMq9Pzy89oWLJ0kBZNJEIhJz57LwMNR+e0yXgnA6Dc3oYMA+T7x7jF/ctAf1hKejT6f6Q7Zx7ZwwW+4iU17wj4DWHhLzmUJrXKNhrmmGvaXF5DeFdMdi70l+SnO286S7kheNAL5wKeuFw0AuXgl64DPTCd0AvPGyAFx4W8MIjQl54JM0L2+ewXtgEe2Ez7IUtLi8kvPVc2FtPerl7lv11T3k17a1zQG+dC3rrCNBbl4Heuhz01sOgtx41wFuPCnjrMSFvPZbmrQXuOZflvd0Ie2sT7K3NsLe2uLyV8OrzYK/uBXt1T5Crewh5/yLQ+1eA3j8S9P7loPdfAXr/UdD7jxvg/ccFvD+nWMb7nX5PeH8H95zL8t5ugL2/Efb+Jtj7m2Hvb3F5P5FLzodzSW84l5C5qUcqN9G5ZCWYS1aBuWQUmEuuAHPJCjCXHAdzSbvi0z+XOBrpXJIrlEty03JJJ/ecy/LerodzSQOcSxrhXNIE55JmOJe0uHIJkZvGwbmpD5ybesO5qRf43NRTKNetA3PdejDXjQZz3Qow15WCuS49P2Xr+XkG5Lo8gVznEcp1nrRc19k957K8t+vgXFcP57oGONc1wrmuCc51zXCua3HlOiJ3jodzZyGcO/vAuZPMxT1TuZjOnRvA3PkwmDvHgLmzFMydZWDuzANzpzIgdyqB3NleKHe2T8udXd1zLst7uxbOnXVw7qyHc2cDnDsb4dzZBOfOZjh3trhyJ5GLJ8C5uC+ciwvhXNwHzsW9wefiXkK5/REwtz8G5vZiMLeXgbk9DuZ2Beb2fANye75Abi8Qyu0Fabm9m3vOZXlv18C5vRbO7XVwbq+Hc3sDnNsb4dzeBOf2Zji3t7hyO8EKE2FW6AezQl+YFQphViDZo1eKPWhWeAJkhSdBVhgLskIcZIUEyAr5ICt0MIAVOgiwQkchVuiYxgo93HMuy3u7GmaFGpgVamFWqINZoR5mhQaYFRphVmiCWaEZZoUWFysQ7DEJZo/+MHv0g9mjL8wehTB79AHXPXoLsczTIMs8C7JMCcgyCZBlkiDLdABZppMBLNNJgGU6C7FM5zSW6emec1ne21Uwy1TDLFMDs0wtzDJ1MMvUwyzTALNMI8wyTTDLNMMs0+JiGYKNJsNsNABmo/4wG/WD2agvzEYka/VOsRbNRs+BbPQCyEZekI2SIBuVg2zUCWSjLgawURcBNuoqxEZd09iot3vOZXlvV8JsVAWzUTXMRjUwG9XCbFQHs1E9zEYNMBs1wmzUBLNRM8xGLS42IlhrCsxaA2HWGgCzVn+YtfrBrNUXZq1CcF2rjxC7vQiy20sgu/lAdisH2W0lyG5dQHbrZgC7dRNgt+5C7NY9jd36uOdclvf2FpjdKmF2q4LZrRpmtxqY3WphdquD2a0eZrcGmN0aYXZrgtmtGWa3Fhe7ESw4FWbBQTALDoRZcADMgv1hFuwHsyDJln1SbEmzYAXIgnUgC/pBFlwJsuCVIAt2A1mwhwEs2EOABXsKsWDPNBbs655zWd7bFTALboFZsBJmwSqYBathFqyBWbAWZsE6mAXrYRZsgFmwEWbBJpgFm2EWbHGxIMGW02C2PANmy0EwWw6E2XIAzJb9YbbsB7NlX3DdslCIVbeCrLobZNUAyKpXgqx6FciqPUBW7WUAq/YSYNXeQqzaO41V+7nnXJb39maYVStgVt0Cs2olzKpVMKtWw6xaA7NqLcyqdTCr1sOs2gCzaiPMqk0wqzbDrNriYlWCfafD7HsmzL5nwOw7CGbfgTD7DoDZtz/MviRLF6ZYmmbfgyD7HgLZNwiy71Ug+14Nsm8vkH37GMC+fQTYt1CIfQvT2HeAe85leW9vgtl3M8y+FTD7boHZtxJm3yqYfath9q2B2bcWZt86mH3rYfZtgNm3EWbfJph9m2H2bXGxL8HSM2CWPgtm6TNhlj4DZulBMEsPhFl6AMzS/WGW7geuS/cVYvN2+RybF+Rz8zcEsvnVIJtfA7J5H5DN+xrA5n0F2LyfEJv3S2Pzge45l+W9/XIuy+abYDbfDLN5BczmW2A2r4TZvApm82qYzWtgNq+F2bwOZvN6mM0bYDZvhNm8CWbzZpjNW1xsTrD+TJj1z4ZZ/yyY9c+EWf8MmPUHwaw/EGb9ATDrk88OfVPPDjTrdwNZvxBk/TDI+teArH8tyPp9Qdbvz7F+2OlDgvX7C7D+ACHWHyC4Du+wfhRm/RjM+ufCrH8ezPrnw6w/Dmb98TDrT4BZfyLM+pNg1p8Ms/4UmPWnwqw/DWb96TDrz4BZn2Tz7jCb94DZvCfM5r1gNu8Ns3kfmM0LYTbv62LzbDmuX4rNPan+TvSbLbdeC3LrdSC39ge5dSDIb04fEtw6UIBbBwlx6yDB2mmHW2Mwt54Lc+t5MLeeD3PrOJhbx8PcOgHm1okwt06CuXUyzK1TYG6dCnPrNJhbp8PcOgPmVpIze8Cc2RPmzF4wZ/aGObMPzJmFMGf2hTmzX4ozaS68DuTCVSAXDgS58AwDuPAMAS48U4gLzxR8/4PDhefCXHgezIXnw1w4DubC8TAXToC5cCLMhZNgLpwMc+EUmAunwlw4DebC6TAXzoC5kOS4njDH9YI5rjfMcX1gjiuEOa4vzHH9XByX9XqXEMetAjnuepDjzgA57iwDOO4sAY47W4jjzhZ8p6vDcefBHHc+zHHjYI4bD3PcBJjjJsIcNwnmuMkwx02BOW4qzHHTYI6bDnPcDJjjSO7qBXNXb5i7+sDcVQhzV1+Yu/rB3NU/xV00J10PctINICedBXLSOQZw0jkCnDRYiJMGC55b5HDS+TAnjYM5aTzMSRNgTpoIc9IkmJMmw5w0BeakqTAnTYM5aTrMSTNgTiK5pjfMNX1grimEuaYvzDX9YK7p7+KabPP8ACGuuQHkmtUg15wDcs0QA7hmiADXDBXimqGCZ1U7XDMO5prxMNdMgLlmIsw1k2CumQxzzRSYa6bCXDMN5prpMNfMgLmG5JA+MIcUwhzSF+aQfjCH9Ic5ZECKQ2huWA1ywxqQG4aA3FBkADcUCXDDMCFuGJbGDT1cmgluGA9zwwSYGybC3DAJ5obJMDdMgblhKswN02BumA5zwwyYG8g8Xwjn+b5wnu8H5/n+cJ4f4MrzWde9CuX5NWCeXwvm+SIwzw83IM8PF8jzI4Ty/Ii0PN/NpZnI8xPgPD8RzvOT4Dw/Gc7zU+A8PxXO89PgPD8dzvMz4DxP5uW+cF7uB+fl/nBeHgDn5YGpvEzn0bVgHr0RzKPDwTw60oA8OlIgj44SyqOj0vJoV5dmIo9OhPPoJDiPTobz6BQ4j06F8+g0OI9Oh/PoDDiPknmvH5z3+sN5bwCc9wa68l62eWCQUN67Ecx768C8NxLMe6MNyHujBfLeGKG8NyYt73V2aSby3iQ4702G894UOO9NhfPeNDjvTYfz3gw475F5qj+cpwbAeWognKcGpfIUnVfWgXnlJjCvjAbzSrEBeaVYIK+MFcorY9PySieXZiKvTIbzyhQ4r0yF88o0OK9Mh/PKDDivkHlgAJwHBsJ5YJArD2T973mF8sBNYB64GcwDxWAeKDEgD5QI5AGvUB7wpuWBDi7NRB6YAueBqXAemAbngelwHpgB5wHStwfCvj0I9u0zUr5N++zNoM/eAvpsCeizPgN81ifgs34hn/Wn+WyBSzPhs1Nhn50G++x02GdnwD5L+uIg2BfPcPlitj5xppAv3gL64q2gL/pAXwwY4IsBAV8MCvliMM0X2+fwvjgN9sXpsC/OgH2R9LEzYB87M+VjtO/cCvrObaDvBEDfCRngOyEB3wkL+U44zXeUgO9Mh31nBuw7pE+c6fKJrN/jIuQTt4E+cTvoEyHQJyIG+EREwCeiQj4RTfOJPAGfmAH7BDmvz0rNa3oe3g7Ow/XgPIyA8zBmwDyMCczDc4Xm4bltzMP/oDmebFvzu7FYP5qN7Stj+M8qh70HvJ5ULAty/v1F/S3nM+zp6pu+p50zpim9UhpbDNDYbIDGJgM0NhqgscEAjfUGaKwzQGOtARprDNBYbYDGKgM0VhqgcYsBGisM0LjZAI2bDND47r9VgzS++/66nJMvWu/bBsT0HQM0HjJA42EDNB4xQONRAzQeM0DjcQM0Opvep7vGdgZozDVAY54BGj0GaFQGaGxvgMZ8AzQWGKCxgwEaOxqgsZMBGjsboLGLARq7GqCxmwEauxugsYcBGnsaoLGXARp7G6CxjwEaCw3Q2NcAjf0M0NjfAI0DDNA4ENToaJuZc/Jl18ZPT412bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY3/bWvjOa7L9mv7tf3afm2/tl/br+3X9mv7tf3aft/v1dq7YnLZv+E7J4vnIZ/r6xGZ9OVr+8dS4y0BxxvOqK/yNi+p8Y4DxzvVgPHOAcc714DxLgLHu8KA8a4Ex7vKgPGuA8e73oDxbgDH+7AB430EHO9jBoz3CXC8Txow3qfB8T5rwHifA8f7ggHjfREc70sGjLcCHG+dAePdCo53twHjPQiO95AB422Xz423IP/0H283cLyFaX1l+77kD+K9uG8ZUOv/pgEa3zBA4+sGaDxogMbXDNB4wACN+w3QuM8AjXsN0LjHAI27DdC4ywCNOw3QuMMAja8aoHG7ARq3gRo/CCYvGn36x3SYARqHG6BxhAEaRxqgcZQBGkcboHGMARqLDdA41gCNJQZo9Bqg0WeARr8BGgMGaAwaoDFkgMYwqNEy+XsaLZMzGi2TMxotkzMaLZMzGi2TMxotkzMaLZMzGi2TMxppJj+h8QSbn1eck3O+buN0G6/bBOc8cN0m6TZZtym6TdVtmm7TdZuh20zdZuk2W7c5ul2Qdi45D6dFXACcA7Sd1jnn31/U3/ogHoDsAdqMRnuANqPRHqDNaLQHaDMa7QHajEZ7gDaj0R6gzWi0B2gzGu0B2vaQEG+Wl5RGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRnuAtl0b92Z5SWm0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0B2jbfm2/tl/br+3X9mv7tf3afm2/tl/b7/u7WntXTC77N+wB2pn8sutre4B2W9eHM157gHYGv+z62h6g3db14YzXHqCdwS+7vrYHaLd1fTjjtQdoZ/DLrq/tAdptXR/OeO0B2hn8sutre4B2W9eHM157gHYGv+z62h6gbQ/Q9mZ32QO0IY32AG1Goz1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7R5jfawPkajPayP0WgP62M02sP6GI32sD5Goz2sj9FoD+tjNNrD+hiN9GF9J/S5L/JvWO633E9ptNzPaLTcz2i03M9otNzPaLTcz2i03M9otNzPaLTcf8rlcw4Wp/RKaTzfAI3jDNA43gCNEwzQONEAjZMM0DjZAI1TDNA41QCN0wzQON0AjTMM0DjTAI2zDNA42wCNcwzQeAGo8QPgfl9eWhxO8P+FegwX6Xaxbpfodqluc3W7TLfLdZun23zdFui2ULdFui3WbYluS3Vbptvy4pP7vEJ/vUK3Ut3KdIvrltAtqVu5bit1u1K3q3S7WrdrdLtWt+t0W6Xb9brdkOrzxHndq/XXa3Rbq9uNuq3T7SbdbtbtFt1u1e023W7Xbb1ud+h2p2536Xa3bvfodq9uG3S7T7f7dduo2wO6PajbQ7o9rNtHdPuobh/T7eO6fUK3T+r2iG6f0u3Tun2mOO2zwhf6i9gbX0LfhcWn9pvtPwz5LDyZ8lJjd/q9RfCzukggFo8KxeJR4VhcLBCLzwnF4nPCsbhEIBaPCcXiMeFYXCoQi88LxeLzwrGYKxCLx4Vi8bhwLC4TiMUXhGLxBeFYXC4Qiy8KxeKLwrGYJxCLLwnF4kvCsZgvEIsvC8Xiy8KxWCAQiyeEYvGEcCwWCsTiK0Kx+IpwLBYJxOKrQrH4qnAsFgvE4mtCsfiacCyWCMTi60Kx+LpwLJYKxOIbQrH4hnAslgnE4ptCsfimcCyWC8TiSaFYOP12TfWbC2t+Ofe9WFCxdYpCnEbHdufY0399cLXAPbVrrMw95fTbTnB+rRGIxW6hWOwWjsVagVjsEYrFHuFY3CgQi71CsdgrHIt1ArHYJxSLfcKxuEkgFvuFYrFfOBY3C8TigFAsDgjH4haBWLwmFIvXhGNxq0AsDgrF4qBwLG4TiMXrQrF4XTgWtwvE4g2hWLwhHIv1ArF4UygWbwrH4g6BWLwlFIu3hGNxp0As3haKxdvCsbhLIBbvCMXiHeFY3C0Qi0NCsTgkHIt7BGJxWCgWh4Vjca9ALI4IxeKIcCw2CMTiqFAsjgrH4j6BWBwTisUx4VjcLxCL40KxOC4ci40CscgpkYmF069kLB4QiEU7oVi0E47FgwKxyBWKRa5wLB4SiEWeUCzyhGPxsEAsPEKx8AjH4iMCsVBCsVDCsfioQCzaC8WivXAsPiYQi3yhWOQLx+LjArEoEIpFgXAsPiEQiw5CseggHItPCsSio1AsOgrH4hGBWHQSikUn4Vh8SiAWnYVi0TktFu76Jl+4PBwuLQ0lSmPeUCQSDMXioVAkHPUHtPRQPBaKBLyRaCARCpWXxUvjUV8i5o/FI6WlYX8g5guHt6r3/t3ev/qLhRPJQDzhDZf6gtGyUCgZLU0mg8lQMpLQIQkkfN5AxOst8wfKEqW6f384qEPgiwVjiXg4GStzXuzoNOXWmWW/Jx1UHS2LlAd88aQeajgZCkdj8bK4P6z/QtAfDSaScb83Vh6NBsvLfZFk2BsoDYW8UX8wWR4L6z8ZD6YfVJ1t/DJ5oU3wP/x8dTF3L3bh7kWf1BzsUsLPwa5Cc9Dp985Uv3nwHGxxz0FgTl+Ufl/6I5FIzB/xx33ecl/Q5w3GQ3oqhANlkWhpPF4aiSX85ZF4Qv/Plyjz+vT80hMqliwNlEUTiUDImc/Oy1Dz4TldAs7pMDinzwfmYfLdY/zivtWgP6wBfTrdH7Kdc91KsNhHpLymm4DXdBfymu5pXqNgr2mGvabF5TWEd10Me1f6S5KznTfDhLxwHOiFU0EvHAd64RrQC9eCXtgN9MIeBnhhDwEv7CnkhT3TvLB9DuuFTbAXNsNe2OLyQsJbL4G99aSXu2fZ37CUV9PeOgf01rmgt44HvXUt6K03gt7aA/TWXgZ4ay8Bb+0t5K2907y1wD3nsry3G2FvbYK9tRn21haXtxJefSns1SNhrx4BcvVwIe9fBHr/CtD7J4DefyPo/etA7+8Fen8fA7y/j4D3Fwp5f2Ga93dwz7ks7+0G2PsbYe9vgr2/Gfb+Fpf3E7lkLpxLRsG5hMxNw1O5ic4lK8FcsgrMJRPBXLIOzCU3gbmkD5hL+hqQS/oK5JJ+QrmkX1ou6eSec1ne2/VwLmmAc0kjnEua4FzSDOeSFlcuIXLTZXBuGg3nplFwbhoJPjeNEMp168Bctx7MdZPAXHcTmOtuBnNdXzDX9Tcg1/UXyHUDhHLdgLRc19k957K8t+vgXFcP57oGONc1wrmuCc51zXCua3HlOiJ3Xg7nzjFw7hwN504yF49I5WI6d24Ac+fDYO6cDObOm8HceQuYO/uDuXOgAblzoEDuHCSUOwel5c6u7jmX5b1dC+fOOjh31sO5swHOnY1w7myCc2cznDtbXLmTyMXz4FxcDOfiMXAuHg3n4lHgc/FIodz+CJjbHwNz+xQwt98C5vZbwdw+EMztZxiQ288QyO1nCuX2M9Nyezf3nMvy3q6Bc3stnNvr4NxeD+f2Bji3N8K5vQnO7c1wbm9x5XaCFebDrDAWZoVimBXGwKxAssfIFHvQrPAEyApPgqwwFWSFW0FWuA1khTNAVjjLAFY4S4AVzhZihbPTWKGHe85leW9Xw6xQA7NCLcwKdTAr1MOs0ACzQiPMCk0wKzTDrNDiYgWCPRbA7FECs8dYmD2KYfYYA7PHaHDdY5QQyzwNssyzIMtMA1nmNpBlbgdZ5iyQZc4xgGXOEWCZwUIsMziNZXq651yW93YVzDLVMMvUwCxTC7NMHcwy9TDLNMAs0wizTBPMMs0wy7S4WIZgo4UwG3lhNiqB2WgszEbFMBuRrDUqxVo0Gz0HstELIBtNB9nodpCN1oNsdA7IRkMMYKMhAmw0VIiNhqaxUW/3nMvy3q6E2agKZqNqmI1qYDaqhdmoDmajepiNGmA2aoTZqAlmo2aYjVpcbESw1iKYtXwwa3lh1iqBWWsszFrFMGuNAde1Rgux24sgu70EstsMkN3Wg+x2B8huQ0B2KzKA3YoE2G2YELsNS2O3Pu45l+W9vQVmt0qY3apgdquG2a0GZrdamN3qYHarh9mtAWa3RpjdmmB2a4bZrcXFbgQLLoZZ0A+zoA9mQS/MgiUwC46FWZBky9EptqRZsAJkwTqQBWeCLHgHyIJ3gixYBLLgcANYcLgAC44QYsERaSzY1z3nsry3K2AW3AKzYCXMglUwC1bDLFgDs2AtzIJ1MAvWwyzYALNgI8yCTTALNsMs2OJiQYItl8BsGYDZ0g+zpQ9mSy/MliUwW46F2bIYXLccI8SqW0FW3Q2y6iyQVe8EWfUukFWHg6w60gBWHSnAqqOEWHVUGqv2c8+5LO/tzTCrVsCsugVm1UqYVatgVq2GWbUGZtVamFXrYFath1m1AWbVRphVm2BWbYZZtcXFqgT7LoXZNwizbwBmXz/Mvj6Yfb0w+5bA7Euy9JgUS9PsexBk30Mg+84G2fcukH3vBtl3JMi+ow1g39EC7DtGiH3HpLHvAPecy/Le3gSz72aYfStg9t0Cs28lzL5VMPtWw+xbA7NvLcy+dTD71sPs2wCzbyPMvk0w+zbD7NviYl+CpZfBLB2CWToIs3QAZmk/zNI+mKW9MEuXwCw9FlyXLhZi83b5HJsX5HPzdw7I5neDbH4PyOajQTYvNoDNiwXYfKwQm49NY/OB7jmX5b39ci7L5ptgNt8Ms3kFzOZbYDavhNm8CmbzapjNa2A2r4XZvA5m83qYzRtgNm+E2bwJZvNmmM1bXGxOsP5ymPXDMOuHYNYPwqwfgFnfD7O+D2Z9L8z65LNDcerZgWb9biDrF4KsfwHI+veArH8vyPrFIOuXcKwfdvqQYP0SAdb3CrG+V3Ad3mH9i2DWvxhm/Utg1r8UZv25MOtfBrP+5TDrz4NZfz7M+gtg1l8Is/4imPUXw6y/BGb9pTDrL4NZn2TzYTCbD4fZfATM5iNhNh8Fs/lomM3HwGxe7GLzbDlubIrNPan+TvSbLbfeC3LrBpBbS0Bu9YH85vQhwa0+AW71C3GrX7B22uHWi2FuvQTm1kthbp0Lc+tlMLdeDnPrPJhb58PcugDm1oUwty6CuXUxzK1LYG5dCnPrMphbSc4cDnPmCJgzR8KcOQrmzNEwZ46BObMY5syxKc6kuXADyIX3gVzoA7kwYAAXBgS4MCjEhUHB9z84XHgJzIWXwlw4F+bCy2AuvBzmwnkwF86HuXABzIULYS5cBHPhYpgLl8BcuBTmwmUwF5IcNwLmuJEwx42COW40zHFjYI4rhjlurIvjsl7vEuK4+0COux/kuADIcSEDOC4kwHFhIY4LC77T1eG4S2GOmwtz3GUwx10Oc9w8mOPmwxy3AOa4hTDHLYI5bjHMcUtgjlsKc9wymONI7hoJc9comLtGw9w1BuauYpi7xsLcVZLiLpqT7gc5aSPISSGQkyIGcFJEgJOiQpwUFTy3yOGkuTAnXQZz0uUwJ82DOWk+zEkLYE5aCHPSIpiTFsOctATmpKUwJy2DOYnkmlEw14yGuWYMzDXFMNeMhbmmxMU12eZ5rxDXbAS55gGQayIg18QM4JqYANecK8Q15wqeVe1wzWUw11wOc808mGvmw1yzAOaahTDXLIK5ZjHMNUtgrlkKc80ymGtIDhkNc8gYmEOKYQ4ZC3NICcwh3hSH0NzwAMgND4LcEAO54TwDuOE8AW44X4gbnH5PcEMPl2aCGy6HuWEezA3zYW5YAHPDQpgbFsHcsBjmhiUwNyyFuWEZzA1knh8D5/liOM+PhfN8CZznva48n3Xdq1CefxDM8w+Bef48MM+PMyDPjxPI8+OF8vz4tDzfzaWZyPPz4Dw/H87zC+A8vxDO84vgPL8YzvNL4Dy/FM7zy+A8T+blYjgvj4Xzcgmcl71wXval8jKdRx8C8+jDYB4dB+bRCQbk0QkCeXSiUB6dmJZHu7o0E3l0PpxHF8B5dCGcRxfBeXQxnEeXwHl0KZxHl8F5lMx7Y+G8VwLnPS+c93yuvJdtHvAL5b2Hwbz3ETDvTQDz3iQD8t4kgbw3WSjvTU7Le51dmom8twDOewvhvLcIznuL4by3BM57S+G8twzOe2SeKoHzlBfOUz44T/lTeYrOKx8B88pHwbwyCcwrUwzIK1ME8spUobwyNS2vdHJpJvLKQjivLILzymI4ryyB88pSOK8sg/MKmQe8cB7wwXnA78oDWf97XqE88FEwD3wMzANTwDwwzYA8ME0gD0wXygPT0/JAB5dmIg8sgvPAYjgPLIHzwFI4DyyD8wDp2z7Yt/2wbwdSvk377MdAn/046LPTQJ+dYYDPzhDw2ZlCPjszzWcLXJoJn10M++wS2GeXwj67DPZZ0hf9sC8GXL6YrU8EhXzx46AvfgL0xRmgL84ywBdnCfjibCFfnJ3mi+1zeF9cAvviUtgXl8G+SPpYAPaxYMrHaN/5BOg7nwR9ZxboO3MM8J05Ar5zgZDvXJDmO0rAd5bCvrMM9h3SJ4Iun8j6PS5CPvFJ0CceAX1iDugTFxrgExcK+MRFQj5xUZpP5An4xDLYJ8h5HUrNa3oePgLOw0+B8/BCcB5ebMA8vFhgHl4iNA8vaWMe/gfN8WTbmt+NxaeK2djuHMt/VjnsPeD1pGJZkPPvL+pvOZ9hT1ff9D3tnDFN6ZXS2GKAxmYDNDYZoLHRAI0NBmisN0BjnQEaaw3QWGOAxmoDNFYZoLHSAI1bDNBYYYDGzQZo3GSARmfNgNLoaBuac/JF633bgJi+Y4DGQwZoPGyAxiMGaDxqgMZjBmg8boBGZ9P7dNfYzgCNuQZozDNAo8cAjcoAje0N0JhvgMYCAzR2MEBjRwM0djJAY2cDNHYxQGNXAzR2M0BjdwM09jBAY08DNPYyQGNvAzT2MUBjoQEa+xqgsZ8BGvsboHGAARoHghrf/TdbOSdfdm389NRo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNH437Y2nuO6bL+2X9uv7df2a/u1/dp+bb+2X9uv7ff9Xq29KyaX/Ru+c7J4HvK5vh6RSV++tn8sNd4ScLzhjPoqb/OSGu84cLxTDRjvHHC8cw0Y7yJwvCsMGO9KcLyrDBjvOnC86w0Y7wZwvA8bMN5HwPE+ZsB4nwDH+6QB430aHO+zBoz3OXC8Lxgw3hfB8b5kwHgrwPHWGTDereB4dxsw3oPgeA8ZMN52+dx4C/JP//F2A8dbmNZXtu9L/iDei/uWAbX+bxqg8Q0DNL5ugMaDBmh8zQCNBwzQuN8AjfsM0LjXAI17DNC42wCNuwzQuNMAjTsM0PiqARq3G6BxG6jxg2Dy84pP/5ieb4DGcQZoHG+AxgkGaJxogMZJBmicbIDGKQZonGqAxmkGaJxugMYZBmicaYDGWQZonG2AxjkGaLwA1GiZ/D2NlskZjZbJGY2WyRmNlskZjZbJGY2WyRmNlskZjZbJGY00k5/QeILNLy3JyZmr22W6Xa7bPN3m67ZAt4W6LdJtsW5LdFuq2zLdlut2hW4rdCvVrSztXHI8AM5h2lQAnAO0ndY5599f1N/6IB6A7AHajEZ7gDaj0R6gzWi0B2gzGu0B2oxGe4A2o9EeoM1otAdoMxrtAdr2kBBvlpeURntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7gLZdG/dmeUlptGvjjEa7Ns5otGvjjEa7Ns5otGvjjEa7Ns5otGvjjEa7Ns5otGvjjEa7Ns5otGvjjEa7Ns5otGvjjEa7Ns5otGvjjEa7Ns5otAdo235tv7Zf26/t1/Zr+7X92n5tv7Zf2+/7u1p7V0wu+zfsAdqZ/LLra3uAdlvXhzNee4B2Br/s+toeoN3W9eGM1x6gncEvu762B2i3dX0447UHaGfwy66v7QHabV0fznjtAdoZ/LLra3uAdlvXhzNee4B2Br/s+toeoG0P0PZmd9kDtCGN9gBtRqM9QJvRaA/QZjTaA7QZjfYAbUajPUCb0WgP0GY02gO0eY32sD5Goz2sj9FoD+tjNNrD+hiN9rA+RqM9rI/RaA/rYzTaw/oYjfRhfSf0uS/yb1jut9xPabTcz2i03M9otNzPaLTcz2i03M9otNzPaLTcz2i03H/K5XMOFqf0Smmca4DGywzQeLkBGucZoHG+ARoXGKBxoQEaFxmgcbEBGpcYoHGpARqXGaBxuQEarzBA4woDNJYaoLEM1PgBcL8vLy0OJ/g/rseQ0C2pW7luK3W7UrerdLtat2t0u1a363Rbpdv1ut2g22rd1ui2VrcbS07uc53++ibdbtbtFt1u1e023W7Xbb1ud+h2p2536Xa3bvfodq9uG3S7T7f7dduY6vPEed0P6K8f1O0h3R7W7SO6fVS3j+n2cd0+odsndXtEt0/p9mndPqPbZ3V7VLfP6faYbp/X7XHdvqDbF3X7km5f1u0J3b6i21d1+5puX9ftG7p9U7cndfuWbt/W7X90e6ok7bOib6rhReyNL6EvXnJqv9n+w5DvwJMpLzV2p99bBD+rhEAsvisUi+8KxyIpEIunhWLxtHAsygVi8YxQLJ4RjsVKgVh8TygW3xOOxZUCsfi+UCy+LxyLqwRi8QOhWPxAOBZXC8Tih0Kx+KFwLK4RiMWPhGLxI+FYXCsQi2eFYvGscCyuE4jFj4Vi8WPhWKwSiMVPhGLxE+FYXC8Qi58KxeKnwrG4QSAWPxOKxc+EY7FaIBY/F4rFz4VjsUYgFr8QisUvhGOxViAWzwnF4jnhWNwoEItfCsXC6bdrqt9cWPPLue/FgoqtUxTiNDq2Ob7Tf33wAYF7qp1P5p5y+m0nOL8eFIhFrlAscoVj8ZBALPKEYpEnHIuHBWLhEYqFRzgWHxGIhRKKhRKOxUcFYtFeKBbthWPxMYFY5AvFIl84Fh8XiEWBUCwKhGPxCYFYdBCKRQfhWHxSIBYdhWLRUTgWjwjEopNQLDoJx+JTArHoLBSLzsKx+LRALLoIxaKLcCw+IxCLrkKx6Coci88KxKKbUCy6CcfiUYFYdBeKRXfhWHxOIBY9hGLRQzgWjwnEoqdQLHoKx+LzArHoJRSLXsKxeFwgFr2FYtFbOBZfEIhFH6FY9BGOxRcFYlEoFItC4Vh8SSAWfYVi0Vc4Fl8WiEU/oVj0E47FEwKx6C8Ui/7CsfiKQCwGCMVigHAsvioQi4FCsRgoHIuvCcRikFAsBgnH4usCsThDKBZnCMfiGwKxOFMoFmcKx+KbArE4SygWZwnH4kmBWJwtFIuzhWPxLYFYnCMUi3OEY/FtgVgMForF4LRYuOubfOHycLi0NJQojXlDkUgwFIuHQpFw1B/Q0kPxWCgS8EaigUQoVF4WL41HfYmYPxaPlJaG/YGYLxzeqt77d3v/6i8WTiQD8YQ3XOoLRstCoWS0NJkMJkPJSEKHJJDweQMRr7fMHyhLlOr+/eGgDoEvFowl4uFkrMx5saPTlFtnlv2edFB1tCxSHvDFk3qo4WQoHI3Fy+L+sP4LQX80mEjG/d5YeTQaLC/3RZJhb6A0FPJG/cFkeSys/2Q8mH5Qdbbxy+SFNsH/8PMHSrh7cQh3L/qk5uAQHz8HhwrNQaffO1P95sFzsMU9B4E5nUi/L/2RSCTmj/jjPm+5L+jzBuMhPRXCgbJItDQeL43EEv7ySDyh/+dLlHl9en7pCRVLlgbKoolEIOTMZ+dlqPnwnC4B53QYnNNzgXmYfPcYv7jvAdAfHgR9Ot0fsp1zRT4s9hEprykS8JphQl4zLM1rFOw1zbDXtLi8hvCuJOxd6S9JznbenC/kheNAL5wKeuFloBc+CHrhQ6AXFoFeONwALxwu4IUjhLxwRJoXts9hvbAJ9sJm2AtbXF5IeGs57K0nvdw9y/7OT3k17a1zQG+dC3rr5aC3PgR668Ogtw4HvXWkAd46UsBbRwl566g0by1wz7ks7+1G2FubYG9thr21xeWthFevhL16AuzV40GuHifk/YtA718Bev880PsfBr3/I6D3jwS9f7QB3j9awPvHCHn/mDTv7+Cec1ne2w2w9zfC3t8Ee38z7P0tLu8ncsmVcC6ZCOcSMjeNS+UmOpesBHPJKjCXzAdzyUfAXPJRMJeMBnNJsQG5pFggl4wVyiVj03JJJ/ecy/LerodzSQOcSxrhXNIE55JmOJe0uHIJkZuugnPTJDg3TYRz0wTwuWm8UK5bB+a69WCuWwDmuo+Cue5jYK4rBnNdiQG5rkQg13mFcp03Ldd1ds+5LO/tOjjX1cO5rgHOdY1wrmuCc10znOtaXLmOyJ1Xw7lzMpw7J8G5k8zF41O5mM6dG8Dc+TCYOxeCufNjYO78OJg7S8Dc6TMgd/oEcqdfKHf603JnV/ecy/LeroVzZx2cO+vh3NkA585GOHc2wbmzGc6dLa7cSeTia+BcPAXOxZPhXDwJzsUTwefiCUK5/REwtz8G5vZFYG7/OJjbPwHmdh+Y2wMG5PaAQG4PCuX2YFpu7+aec1ne2zVwbq+Fc3sdnNvr4dzeAOf2Rji3N8G5vRnO7S2u3E6wwrUwK0yFWWEKzAqTYVYg2WNCij1oVngCZIUnQVZYDLLCJ0BW+CTICgGQFUIGsEJIgBXCQqwQTmOFHu45l+W9XQ2zQg3MCrUwK9TBrFAPs0IDzAqNMCs0wazQDLNCi4sVCPa4DmaPaTB7TIXZYwrMHpNh9pgErntMFGKZp0GWeRZkmSUgy3wSZJlHQJYJgSwTMYBlIgIsExVimWgay/R0z7ks7+0qmGWqYZapgVmmFmaZOphl6mGWaYBZphFmmSaYZZphlmlxsQzBRqtgNpoOs9E0mI2mwmw0BWYjkrUmpliLZqPnQDZ6AWSjpSAbPQKy0adANoqAbBQzgI1iAmx0rhAbnZvGRr3dcy7Le7sSZqMqmI2qYTaqgdmoFmajOpiN6mE2aoDZqBFmoyaYjZphNmpxsRHBWtfDrDUDZq3pMGtNg1lrKsxaU2DWmgyua00SYrcXQXZ7CWS3ZSC7fQpkt0+D7BYD2e08A9jtPAF2O1+I3c5PY7c+7jmX5b29BWa3SpjdqmB2q4bZrQZmt1qY3epgdquH2a0BZrdGmN2aYHZrhtmtxcVuBAveALPgTJgFZ8AsOB1mwWkwC06FWZBky0kptqRZsAJkwTqQBZeDLPhpkAU/A7LgeSALjjOABccJsOB4IRYcn8aCfd1zLst7uwJmwS0wC1bCLFgFs2A1zII1MAvWwixYB7NgPcyCDTALNsIs2ASzYDPMgi0uFiTYcjXMlrNgtpwJs+UMmC2nw2w5DWbLqTBbTgHXLScLsepWkFV3g6x6BciqnwFZ9bMgq44DWXWCAaw6QYBVJwqx6sQ0Vu3nnnNZ3tubYVatgFl1C8yqlTCrVsGsWg2zag3MqrUwq9bBrFoPs2oDzKqNMKs2wazaDLNqi4tVCfZdA7PvbJh9Z8HsOxNm3xkw+06H2XcazL4kS09OsTTNvgdB9j0Esu8KkH0/C7LvoyD7TgDZd5IB7DtJgH0nC7Hv5DT2HeCec1ne25tg9t0Ms28FzL5bYPathNm3Cmbfaph9a2D2rYXZtw5m33qYfRtg9m2E2bcJZt9mmH1bXOxLsPRamKXnwCw9G2bpWTBLz4RZegbM0tNhlp4Gs/RUcF16ihCbt8vn2Lwgn5u/pSCbPwqy+edANp8EsvkUA9h8igCbTxVi86lpbD7QPeeyvLdfzmXZfBPM5pthNq+A2XwLzOaVMJtXwWxeDbN5DczmtTCb18FsXg+zeQPM5o0wmzfBbN4Ms3mLi80J1r8RZv0LYNafA7P+bJj1Z8GsPxNm/Rkw60+HWZ98dpiSenagWb8byPqFIOuXgaz/OZD1HwNZfwrI+tM41g87fUiw/jQB1p8uxPrTBdfhHdZPwKyfhFm/HGb9lTDrXwmz/lUw618Ns/41MOtfC7P+dTDrr4JZ/3qY9W+AWX81zPprYNZfC7M+yebnw2w+Dmbz8TCbT4DZfCLM5pNgNp8Ms/kUF5tny3FTU2zuSfV3ot9sufUxkFs/D3LrNJBbZ4D85vQhwa0zBLh1phC3zhSsnXa4NQlzaznMrSthbr0S5tarYG69GubWa2BuvRbm1utgbl0Fc+v1MLfeAHPraphb18DcuhbmVpIzx8GcOR7mzAkwZ06EOXMSzJmTYc6cAnPm1BRn0lz4eZALHwe5cAbIhbMM4MJZAlw4W4gLZwu+/8HhwnKYC1fCXHglzIVXwVx4NcyF18BceC3MhdfBXLgK5sLrYS68AebC1TAXroG5cC3MhSTHjYc5bgLMcRNhjpsEc9xkmOOmwBw31cVxWa93CXHc4yDHfQHkuFkgx80xgOPmCHDcBUIcd4HgO10djlsJc9yVMMddBXPc1TDHXQNz3LUwx10Hc9wqmOOuhznuBpjjVsMctwbmuLUwx5HcNQHmrokwd02CuWsyzF1TYO6aCnPXtBR30Zz0BZCTvghy0hyQky40gJMuFOCki4Q46SLBc4scTroS5qSrYE66Guaka2BOuhbmpOtgTloFc9L1MCfdAHPSapiT1sCctBbmJJJrJsJcMwnmmskw10yBuWYqzDXTXFyTbZ6fLsQ1XwS55ksg11wIcs3FBnDNxQJcc4kQ11wieFa1wzVXwVxzNcw118Bccy3MNdfBXLMK5prrYa65Aeaa1TDXrIG5Zi3MNSSHTII5ZDLMIVNgDpkKc8g0mEOmpziE5oYvgdzwZZAbLga54VIDuOFSAW6YK8QNc9O4oYdLM8ENV8PccA3MDdfC3HAdzA2rYG64HuaGG2BuWA1zwxqYG9bC3EDm+clwnp8C5/mpcJ6fBuf56a48n3Xdq1Ce/zKY558A8/ylYJ6/zIA8f5lAnr9cKM9fnpbnu7k0E3n+GjjPXwvn+evgPL8KzvPXw3n+BjjPr4bz/Bo4z6+F8zyZl6fAeXkqnJenwXl5OpyXZ6TyMp1HnwDz6FfAPHoZmEfnGZBH5wnk0flCeXR+Wh7t6tJM5NFr4Tx6HZxHV8F59Ho4j94A59HVcB5dA+fRtXAeJfPeVDjvTYPz3nQ4781w5b1s88BMobz3FTDvfRXMe/PAvLfAgLy3QCDvLRTKewvT8l5nl2Yi710H571VcN67Hs57N8B5bzWc99bAeW8tnPfIPDUNzlPT4Tw1A85TM1N5is4rXwXzytfAvLIAzCuLDMgriwTyymKhvLI4La90cmkm8soqOK9cD+eVG+C8shrOK2vgvLIWzitkHpgO54EZcB6Y6coDWf97XqE88DUwD3wdzAOLwDywxIA8sEQgDywVygNL0/JAB5dmIg9cD+eBG+A8sBrOA2vgPLAWzgOkb8+AfXsm7NuzUr5N++zXQZ/9BuizS0CfXWaAzy4T8NnlQj67PM1nC1yaCZ+9AfbZ1bDProF9di3ss6QvzoR9cZbLF7P1idlCvvgN0Be/CfriMtAXrzDAF68Q8MUVQr64Is0X2+fwvrga9sU1sC+uhX2R9LFZsI/NTvkY7TvfBH3nSdB3rgB9p9QA3ykV8J0yId8pS/MdJeA7a2DfWQv7DukTs10+kfV7XIR84knQJ74F+kQp6BNxA3wiLuATCSGfSKT5RJ6AT6yFfYKc13NS85qeh98C5+G3wXkYB+dh0oB5mBSYh+VC87C8jXn4HzTHk21rfjcW3y5hY5vj4z+rHPYe8HpSsSzI+fcX9becz7Cnq2/6nnbOmKb0SmlsMUBjswEamwzQ2GiAxgYDNNYboLHOAI21BmisMUBjtQEaqwzQWGmAxi0GaKwwQONmAzRuMkCjs2ZAaXS0Dc05+aL1vm1ATN8xQOMhAzQeNkDjEQM0HjVA4zEDNB43QKOz6X26a2xngMZcAzTmGaDRY4BGZYDG9gZozDdAY4EBGjsYoLGjARo7GaCxswEauxigsasBGrsZoLG7ARp7GKCxpwEaexmgsbcBGvsYoLHQAI19DdDYzwCN/Q3QOMAAjQNBjY62mTknX3Zt/PTUaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzRaNfGGY12bZzR+N+2Np7jumy/tl/br+3X9mv7tf3afm2/tl/br+33/V6tvSsml/0bvnOyeB7yub4ekUlfvrZ/LDXeEnC84Yz6Km/zkhrvOHC8Uw0Y7xxwvHMNGO8icLwrDBjvSnC8qwwY7zpwvOsNGO8GcLwPGzDeR8DxPmbAeJ8Ax/ukAeN9GhzvswaM9zlwvC8YMN4XwfG+ZMB4K8Dx1hkw3q3geHcbMN6D4HgPGTDedvnceAvyT//xdgPHW5jWV7bvS/4g3ov7lgG1/m8aoPENAzS+boDGgwZofM0AjQcM0LjfAI37DNC41wCNewzQuNsAjbsM0LjTAI07DND4qgEatxugcRuo8YNg8ktLTv+YzjVA42UGaLzcAI3zDNA43wCNCwzQuNAAjYsM0LjYAI1LDNC41ACNywzQuNwAjVcYoHGFARpLDdBYBmq0TP6eRsvkjEbL5IxGy+SMRsvkjEbL5IxGy+SMRsvkjEbL5IxGmslPaDzB5it9OTlX6naVblfrdo1u1+p2nW6rdLtetxt0W63bGt3W6najbut0u0m3m3W7Je1ccjwAzmHaVACcA7Sd1jnn31/U3/ogHoDsAdqMRnuANqPRHqDNaLQHaDMa7QHajEZ7gDaj0R6gzWi0B2gzGu0B2vaQEG+Wl5RGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRnuAtl0b92Z5SWm0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0a+OMRrs2zmi0B2jbfm2/tl/br+3X9mv7tf3afm2/tl/b7/u7WntXTC77N+wB2pn8sutre4B2W9eHM157gHYGv+z62h6g3db14YzXHqCdwS+7vrYHaLd1fTjjtQdoZ/DLrq/tAdptXR/OeO0B2hn8sutre4B2W9eHM157gHYGv+z62h6gbQ/Q9mZ32QO0IY32AG1Goz1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7R5jfawPkajPayP0WgP62M02sP6GI32sD5Goz2sj9FoD+tjNNrD+hiN9GF9J/S5L/JvWO633E9ptNzPaLTcz2i03M9otNzPaLTcz2i03M9otNzPaLTcf8rlcw4Wp/RKabzSAI1XGaDxagM0XmOAxmsN0HidARpXGaDxegM03mCAxtUGaFxjgMa1Bmi80QCN6wzQeJMBGm82QOMtoMYPgPt9eWlxOMH/t+ox3Kbb7bqt1+0O3e7U7S7d7tbtHt3u1W2Dbvfpdr9uG3V7QLcHdXtIt4d9J/f5Ef31R3X7mG4f1+0Tun1St0d0+5Run9btM7p9VrdHdfucbo/p9nndHtftC7p9MdXnifO6v6S//rJuT+j2Fd2+qtvXdPu6bt/Q7Zu6Panbt3T7tm7/o9tTun1Ht+/q9rRuz+j2Pd2+r9sPdPuhbj/S7VndfqzbT3T7qW4/0+3nuv1Ct+d0+6Vu/6vb87r9n26/8qV9VvRNNbyIvfEl9N3qO7XfbP9hyK/hyZSXGrvT7y2Cn9VtArF4QSgWLwjH4naBWPxGKBa/EY7FeoFY/FYoFr8VjsUdArH4nVAsficcizsFYvF7oVj8XjgWdwnE4g9CsfiDcCzuFojFH4Vi8UfhWNwjEIsXhWLxonAs7hWIxZ+EYvEn4VhsEIjFn4Vi8WfhWNwnEIu/CMXiL8KxuF8gFn8VisVfhWOxUSAWfxOKxd+EY/GAQCz+LhSLvwvH4kGBWLwkFIuXhGPxkEAs/iEUi38Ix+JhgVi8LBQLp9+uqX5zac2578WCiq1TFOI0OraFgdN/ffBLAvdU34DMPeX0205wfn1ZIBb9hGLRTzgWTwjEor9QLPoLx+IrArEYIBSLAcKx+KpALAYKxWKgcCy+JhCLQUKxGCQci68LxOIMoVicIRyLbwjE4kyhWJwpHItvCsTiLKFYnCUciycFYnG2UCzOFo7FtwRicY5QLM4RjsW3BWIxWCgWg4Vj8T8CsRgiFIshwrF4SiAWQ4ViMVQ4Ft8RiEWRUCyKhGPxXYFYDBOKxTDhWDwtEIvhQrEYLhyLZwRiMUIoFiOEY/E9gViMFIrFSOFYfF8gFqOEYjFKOBY/EIjFaKFYjBaOxQ8FYjFGKBZjhGPxI4FYFAvFolg4Fs8KxGKsUCzGCsfixwKxKBGKRYlwLH4iEAuvUCy8wrH4qUAsfEKx8AnH4mcCsfALxcIvHIufC8QiIBSLgHAsfiEQi6BQLILCsXhOIBYhoViEhGPxS4FYhIViERaOxf8KxCIiFIuIcCyeF4hFVCgW0bRYuOubfOHycLi0NJQojXlDkUgwFIuHQpFw1B/Q0kPxWCgS8EaigUQoVF4WL41HfYmYPxaPlJaG/YGYLxzeqt77d3v/6i8WTiQD8YQ3XOoLRstCoWS0NJkMJkPJSEKHJJDweQMRr7fMHyhLlOr+/eGgDoEvFowl4uFkrMx5saPTlFtnlv2edFB1tCxSHvDFk3qo4WQoHI3Fy+L+sP4LQX80mEjG/d5YeTQaLC/3RZJhb6A0FPJG/cFkeSys/2Q8mH5Qdbbxy+SFNsH/8PMv+bh7Mcbdiz6pORgL8HPwXKE56PR7Z6rfPHgOtrjnIDCnb0u/L/2RSCTmj/jjPm+5L+jzBuMhPRXCgbJItDQeL43EEv7ySDyh/+dLlHl9en7pCRVLlgbKoolEIOTMZ+dlqPnwnC4B53QYnNNXAvMw+e4xfnHfl0B/+DLo0+n+kO2cOy+AxT4i5TXnCXjN+UJec36a1yjYa5phr2lxeQ3hXbfD3pX+kuRs581cIS8cB3rhVNALrwK98MugFz4BeuF5oBeOM8ALxwl44XghLxyf5oXtc1gvbIK9sBn2whaXFxLeuh721pNe7p5lf3NTXk176xzQW+eC3no16K1PgN76FdBbx4HeOsEAb50g4K0Thbx1Ypq3FrjnXJb3diPsrU2wtzbD3tri8lbCq++AvXoe7NWXg1x9mZD3LwK9fwXo/deA3v8V0Pu/Cnr/BND7Jxng/ZMEvH+ykPdPTvP+Du45l+W93QB7fyPs/U2w9zfD3t/i8n4il9wJ55L5cC4hc9NlqdxE55KVYC5ZBeaSa8Fc8lUwl3wNzCWTwFwyxYBcMkUgl0wVyiVT03JJJ/ecy/LerodzSQOcSxrhXNIE55JmOJe0uHIJkZvugnPTAjg3zYdz0zzwuelyoVy3Dsx168Fcdx2Y674G5rqvg7luCpjrphmQ66YJ5LrpQrluelqu6+yec1ne23VwrquHc10DnOsa4VzXBOe6ZjjXtbhyHZE774Zz50I4dy6AcyeZiy9P5WI6d24Ac+fDYO5cBebOr4O58xtg7pwG5s4ZBuTOGQK5c6ZQ7pyZlju7uudclvd2LZw76+DcWQ/nzgY4dzbCubMJzp3NcO5sceVOIhffA+fiRXAuXgjn4gVwLp4PPhfPE8rtj4C5/TEwt18P5vZvgLn9m2BunwHm9lkG5PZZArl9tlBun52W27u551yW93YNnNtr4dxeB+f2eji3N8C5vRHO7U1wbm+Gc3uLK7cTrHAvzAqLYVZYBLPCQpgVSPaYl2IPmhWeAFnhSZAVbgBZ4ZsgKzwJssIskBXmGMAKcwRY4QIhVrggjRV6uOdclvd2NcwKNTAr1MKsUAezQj3MCg0wKzTCrNAEs0IzzAotLlYg2GMDzB5LYPZYDLPHIpg9FsLssQBc95gvxDJPgyzzLMgyq0GWeRJkmW+BLDMHZJkLDWCZCwVY5iIhlrkojWV6uudclvd2Fcwy1TDL1MAsUwuzTB3MMvUwyzTALNMIs0wTzDLNMMu0uFiGYKP7YDZaCrPREpiNFsNstAhmI5K15qdYi2aj50A2egFkozUgG30LZKNvg2x0IchGFxvARhcLsNElQmx0SRob9XbPuSzv7UqYjapgNqqG2agGZqNamI3qYDaqh9moAWajRpiNmmA2aobZqMXFRgRr3Q+z1jKYtZbCrLUEZq3FMGstgllrIbiutUCI3V4E2e0lkN3Wguz2bZDd/gdkt4tBdrvUAHa7VIDd5gqx29w0duvjnnNZ3ttbYHarhNmtCma3apjdamB2q4XZrQ5mt3qY3RpgdmuE2a0JZrdmmN1aXOxGsOBGmAWXwyy4DGbBpTALLoFZcDHMgiRbLkixJc2CFSAL1oEseCPIgv8DsuBTIAteCrLgZQaw4GUCLHi5EAtensaCfd1zLst7uwJmwS0wC1bCLFgFs2A1zII1MAvWwixYB7NgPcyCDTALNsIs2ASzYDPMgi0uFiTY8gGYLa+A2XI5zJbLYLZcCrPlEpgtF8NsuQhct1woxKpbQVbdDbLqOpBVnwJZ9Tsgq14Gsuo8A1h1ngCrzhdi1flprNrPPeeyvLc3w6xaAbPqFphVK2FWrYJZtRpm1RqYVWthVq2DWbUeZtUGmFUbYVZtglm1GWbVFherEuz7IMy+K2D2vQJm3+Uw+y6D2XcpzL5LYPYlWXphiqVp9j0Isu8hkH1vAtn3OyD7fhdk33kg+y4wgH0XCLDvQiH2XZjGvgPccy7Le3sTzL6bYfatgNl3C8y+lTD7VsHsWw2zbw3MvrUw+9bB7FsPs28DzL6NMPs2wezbDLNvi4t9CZZ+CGbpUpilV8AsfQXM0sthll4Gs/RSmKWXwCy9GFyXXiTE5u3yOTYvyOfm780gm38XZPOnQTZfALL5IgPYfJEAmy8WYvPFaWw+0D3nsry3X85l2XwTzOabYTavgNl8C8zmlTCbV8FsXg2zeQ3M5rUwm9fBbF4Ps3kDzOaNMJs3wWzeDLN5i4vNCdZ/GGb9Mpj1S2HWXwGz/hUw6y+HWX8ZzPpLYdYnnx0WpZ4daNbvBrJ+Icj6t4Cs/zTI+s+ArL8IZP0lHOuHnT4kWH+JAOsvFWL9pYLr8A7r3waz/u0w66+HWf8OmPXvhFn/Lpj174ZZ/x6Y9e+FWX8DzPr3wax/P8z6G2HWfwBm/Qdh1n8IZn2SzefCbH4ZzOaXw2w+D2bz+TCbL4DZfCHM5otcbJ4txy1Osbkn1d+JfrPl1mdAbv0eyK1LQG5dBvKb04cEty4T4NblQty6XLB22uHW22FuXQ9z6x0wt94Jc+tdMLfeDXPrPTC33gtz6waYW++DufV+mFs3wtz6AMytD8Lc+hDMrSRnXgZz5uUwZ86DOXM+zJkLYM5cCHPmIpgzF6c4k+bC74Fc+H2QC5eBXHiFAVx4hQAXrhDiwhWC739wuHA9zIV3wFx4J8yFd8FceDfMhffAXHgvzIUbYC68D+bC+2Eu3Ahz4QMwFz4Ic+FDMBeSHHc5zHHzYI6bD3PcApjjFsIctwjmuMUujst6vUuI474PctwPQI67AuS4UgM4rlSA48qEOK5M8J2uDsfdAXPcnTDH3QVz3N0wx90Dc9y9MMdtgDnuPpjj7oc5biPMcQ/AHPcgzHEPwRxHctc8mLvmw9y1AOauhTB3LYK5azHMXUtS3EVz0g9ATvohyEmlICfFDeCkuAAnJYQ4KSF4bpHDSXfCnHQXzEl3w5x0D8xJ98KctAHmpPtgTrof5qSNMCc9AHPSgzAnPQRzEsk182GuWQBzzUKYaxbBXLMY5polLq7JNs8vFeKaH4Jc8yOQa+Ig1yQN4JqkANeUC3FNueBZ1Q7X3AVzzd0w19wDc829MNdsgLnmPphr7oe5ZiPMNQ/AXPMgzDUPwVxDcsgCmEMWwhyyCOaQxTCHLIE5ZGmKQ2hu+BHIDc+C3JAEuWGlAdywUoAbrhTihivTuKGHSzPBDXfD3HAPzA33wtywAeaG+2BuuB/mho0wNzwAc8ODMDc8BHMDmecXwnl+EZznF8N5fgmc55e68nzWda9Cef5ZMM//GMzzK8E8f5UBef4qgTx/tVCevzotz3dzaSby/D1wnr8XzvMb4Dx/H5zn74fz/EY4zz8A5/kH4Tz/EJznyby8CM7Li+G8vATOy0vhvLwslZfpPPpjMI/+BMyjV4F59BoD8ug1Ann0WqE8em1aHu3q0kzk0XvhPLoBzqP3wXn0fjiPboTz6ANwHn0QzqMPwXmUzHuL4by3BM57S+G8t8yV97LNA8uF8t5PwLz3UzDvXQPmvesMyHvXCeS9VUJ5b1Va3uvs0kzkvQ1w3rsPznv3w3lvI5z3HoDz3oNw3nsIzntknloC56mlcJ5aBuep5ak8ReeVn4J55WdgXrkOzCvXG5BXrhfIKzcI5ZUb0vJKJ5dmIq/cB+eV++G8shHOKw/AeeVBOK88BOcVMg8shfPAMjgPLHflgaz/Pa9QHvgZmAd+DuaB68E8sNqAPLBaIA+sEcoDa9LyQAeXZiIP3A/ngY1wHngAzgMPwnngITgPkL69DPbt5bBvX5Hybdpnfw767C9An10N+uxaA3x2rYDP3ijkszem+WyBSzPhsxthn30A9tkHYZ99CPZZ0heXw754hcsXs/WJFUK++AvQF58DfXEt6IvrDPDFdQK+eJOQL96U5ovtc3hffAD2xQdhX3wI9kXSx66AfWxFysdo33kO9J1fgr6zDvSdmw3wnZsFfOcWId+5Jc13lIDvPAj7zkOw75A+scLlE1m/x0XIJ34J+sT/gj5xM+gTtxrgE7cK+MRtQj5xW5pP5An4xEOwT5DzujQ1r+l5+L/gPHwenIe3gvPwdgPm4e0C83C90Dxc38Y8/A+a48m2Nb8bi+d9bGwLA/xnlcPeA15PKpYFOf/+ov6W8xn2dPVN39POGdOUXimNLQZobDZAY5MBGhsN0NhggMZ6AzTWGaCx1gCNNQZorDZAY5UBGisN0LjFAI0VBmjcbIDGTQZodNYMKI2OtqE5J1+03rcNiOk7Bmg8ZIDGwwZoPGKAxqMGaDxmgMbjBmh0Nr1Pd43tDNCYa4DGPAM0egzQqAzQ2N4AjfkGaCwwQGMHAzR2NEBjJwM0djZAYxcDNHY1QGM3AzR2N0BjDwM09jRAYy8DNPY2QGMfAzQWGqCxrwEa+xmgsb8BGgcYoHEgqNHRNjPn5MuujZ+eGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGu3aOKPRro0zGv/b1sZzXJft1/Zr+7X92n5tv7Zf26/t1/Zr+7X9vt+rtXfF5LJ/w3dOFs9DPtfXIzLpy9f2j6XGWwKON5xRX+VtXlLjHQeOd6oB450DjneuAeNdBI53hQHjXQmOd5UB410Hjne9AePdAI73YQPG+wg43scMGO8T4HifNGC8T4PjfdaA8T4HjvcFA8b7IjjelwwYbwU43joDxrsVHO9uA8Z7EBzvIQPG2y6fG29B/uk/3m7geAvT+sr2fckfxHtx3zKg1v9NAzS+YYDG1w3QeNAAja8ZoPGAARr3G6BxnwEa9xqgcY8BGncboHGXARp3GqBxhwEaXzVA43YDNG4DNX4QTL7Sd/rH9EoDNF5lgMarDdB4jQEarzVA43UGaFxlgMbrDdB4gwEaVxugcY0BGtcaoPFGAzSuM0DjTQZovNkAjbeAGi2Tv6fRMjmj0TI5o9EyOaPRMjmj0TI5o9EyOaPRMjmj0TI5o5Fm8hMaT7D5Hc453brdpdvdut2j2726bdDtPt3u122jbg/o9qBuD+n2sG4f0e2jun1Mt4+nnUuOB8A5TJsKgHOAttM65/z7i/pbH8QDkD1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7QZjfYAbUajPUDbHhLizfKS0mgPCWE02kNCGI32kBBGoz0khNFoDwlhNNpDQhiN9pAQRqM9JITRaA8JYTTaQ0IYjfaQEEajPSSE0WgPCWE02kNCGI32kBBGoz0khNFoD9C2a+PeLC8pjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjXZtnNFo18YZjfYAbduv7df2a/u1/dp+bb+2X9uv7df2a/t9f1dr74rJZf+GPUA7k192fW0P0G7r+nDGaw/QzuCXXV/bA7Tbuj6c8doDtDP4ZdfX9gDttq4PZ7z2AO0Mftn1tT1Au63rwxmvPUA7g192fW0P0G7r+nDGaw/QzuCXXV/bA7TtAdre7C57gDak0R6gzWi0B2gzGu0B2oxGe4A2o9EeoM1otAdoMxrtAdqMRnuANq/RHtbHaLSH9TEa7WF9jEZ7WB+j0R7Wx2i0h/UxGu1hfYxGe1gfo5E+rO+EPvdF/g3L/Zb7KY2W+xmNlvsZjZb7GY2W+xmNlvsZjZb7GY2W+xmNlvtPuXzOweKUXimNdxqg8S4DNN5tgMZ7DNB4rwEaNxig8T4DNN5vgMaNBmh8wACNDxqg8SEDND5sgMaPGKDxowZo/JgBGj8OavwAuN+XlxaHE/z/CT2GT+r2iG6f0u3Tun1Gt8/q9qhun9PtMd0+r9vjun1Bty/q9iXdvqzbE7p9JXByn1/VX39Nt6/r9g3dvqnbk7p9S7dv6/Y/uj2l23d0+65uT+v2jG7f0+37uv1Atx+m+jxxXveP9NfP6vZj3X6i2091+5luP9ftF7o9p9svdftf3Z7X7f90+5Vuv9btBd1+o9tvdfudbr/X7Q+6/VG3F3X7k25/1u0vuv1Vt7/p9nfdXtLtH7q9rNs/dXtFt026bQ6kfVb0TTW8iL3xJfR9InBqv9n+w5AKeDLlpcbu9HuL4Gf1SYFYbBGKxRbhWDwiEItKoVhUCsfiUwKxqBKKRZVwLD4tEItqoVhUC8fiMwKxqBGKRY1wLD4rEItaoVjUCsfiUYFY1AnFok44Fp8TiEW9UCzqhWPxmEAsGoRi0SAci88LxKJRKBaNwrF4XCAWTUKxaBKOxRcEYtEsFItm4Vh8USAWLUKxaBGOxZcEYrFVKBZbhWPxZYFYbBOKxTbhWDwhEIvtQrHYLhyLrwjE4lWhWDj9dk31mwtrfjn3vVhQsXWKQpxGx3ZM6PRfH/yRwD1VHJK5p5x+2wnOr2cFYjFWKBb/P/beA06q6vz/X+ou0gQVFazYS2Rmd2dmR0VXRUWxJKYaY9mdnTU2rCQmsSFW1CTGhlRN0UQFqdbEAtItiLJ9+oCi9A62/7k6fH+XGwJ/ct+P8rxybl7P6/ua5btnP+cz9zyf9z3uzjlG2IspAl70EfKij7AXLwh4ERDyIiDsxYsCXgSFvAgKe/GSgBelQl6UCnvxsoAXZUJelAl78YqAF+VCXpQLe/GqgBchIS9Cwl78U8CLsJAXYWEv/iXgRUTIi4iwF68JeFEh5EWFsBevC3gRFfIiKuzFGwJeHCvkxbHCXrwp4MVxQl4cJ+zFVAEvjhfy4nhhL6YJeNFXyIu+wl68JeDFCUJenCDsxXQBL04U8uJEYS9mCHhRKeRFpbAXMwW8OEnIi5OEvZgl4MXJQl6cLOzFbAEvThHy4hRhL+YIeNFPyIt+wl7MFfDiVCEvThX24m0BL04T8uI0YS/eEfDidCEvThf24l0BL/oLedFf2Iv3BLw4Q8iLM4S9mCfgxZlCXpwp7MX7Al4MEPJigLAX8wW8OEvIi7OEvfhAwIuzhbw4W9iLDwW8OEfIi3NcXnh/vykYrg2Hq6pCNVXRQCgSKQ9FY6FQJFxRWmakh2LRUKQsEKkoqwmFaqtjVbGKYE20NBqLVFWFS8uiwXB4Ybtv/m7v/8aLhmviZbGaQLgqWF5RHQrFK6ri8fJ4KB6pMZaU1QQDZZFAoLq0rLqmyoxfGi43FgSj5dGaWDgerXY+2NGpdl6dPsfd4qDqiupIbVkwFjdTDcdD4YporDpWGjY/oby0orwmHisNRGsrKspra4OReDhQVhUKBSpKy+O10bD5kbFy90HVfv3bkQ+0Kd/Ov08q4+7Fc7l7MSi1Bs8N8Wvw+0Jr0Bn3lsK4beA1mPeuQWBN/9F9X5ZGIpFoaaQ0FgzUBsuDgfJYyCyFcFl1pKIqFquKRGtKayOxGvO/YE11IGjWl1lQ0XhVWXVFTU1ZyFnPzoehFsNrug+4psPgmr4FWIfxr4/xiwUngf1hMtin3f3B75r7QQjzPiLVa34g0GvOE+o157l6TTu41+TgXpP39Bqidz0I9y73hyT7XTe/FOqFfcFe2A/shbeCvXAy2AungL3wB2Av/KGCXvhDgV74I6Fe+CNXL2xfxPbCLNwLc3AvzHt6IdFb/wT31i0+3N3neL8s9Gq6tw4Ae+t5YG+9DeytU8De+gLYW38I9tYfK+itPxborT8R6q0/cfXWEu+a83lvZ+DemoV7aw7urXlPbyV69UNwr74C7tWXg1x9mVDvPx/s/ZeAvX8w2PtfAHv/i2Dv/zHY+3+qoPf/VKD3/0yo9//M1fs7eNecz3s7Dff+DNz7s3Dvz8G9P+/p/USWPAxnyZVwlpDZdFkhm+gsuRTMkoFgltwOZsmLYJa8BGbJT8EsOV9BlpwvkCU/F8qSn7uypKN3zfm8t1NwlqThLMnAWZKFsyQHZ0nekyVENj0CZ9NVcDZdCWfTFeBz0+VCWTcIzLqbwKwbAmbdS2DWvQxm3flg1l2gIOsuEMi6Xwhl3S9cWdfJu+Z83ttJOOtScNal4azLwFmXhbMuB2dd3pN1RHY+CmfnQDg7r4Kzk8ziywtZTGfnEDA7h4LZeQeYnS+D2fkKmJ0XgNl5oYLsvFAgOy8Sys6LXNnZxbvmfN7bCTg7k3B2puDsTMPZmYGzMwtnZw7OzrwnO4ksfgzO4qvhLB4IZ/FVcBZfCT4XXyGU7Q+C2T4MzPY7wWx/Bcz2V8FsvxDM9osVZPvFAtl+iVC2X+LK9q7eNefz3m6Bsz0BZ3sSzvYUnO1pONszcLZn4WzPwdme92Q7wQrDYFa4BmaFq2FWGAizAskeVxTYg2aFMSArPAWywl0gK7wKssI/QVa4GGSFKgWsUCXACtVCrFDtYoVu3jXn895uhlmhBWaFBMwKSZgVUjArpGFWyMCskIVZIQezQt7DCgR7PA6zx7Uwe1wDs8fVMHsMhNnjKnDf40ohlhkLssxkkGXuBlnmnyDL/AtkmSqQZWIKWCYmwDI1QixT42KZ7t415/PeboJZphlmmRaYZRIwyyRhlknBLJOGWSYDs0wWZpkczDJ5D8sQbDQcZqPrYDa6Fmaja2A2uhpmI5K1riywFs1Gr4JsNBVko3tANvoXyEavgWwUA9koroCN4gJsVCvERrUuNtrdu+Z83tuNMBs1wWzUDLNRC8xGCZiNkjAbpWA2SsNslIHZKAuzUQ5mo7yHjQjWGgGz1vUwa10Hs9a1MGtdA7PW1TBrDQT3ta4SYrfZILvNA9ntXpDdXgPZ7XWQ3eIgu12qgN0uFWC3Xwqx2y9d7LaHd835vLcbYHZrhNmtCWa3ZpjdWmB2S8DsloTZLQWzWxpmtwzMblmY3XIwu+U97Eaw4EiYBW+AWfB6mAWvg1nwWpgFr4FZkGTLqwpsSbNgPciCSZAFh4Is+DrIgm+ALHgpyIKXKWDBywRY8HIhFrzcxYJ7etecz3u7HmbBBpgFG2EWbIJZsBlmwRaYBRMwCyZhFkzBLJiGWTADs2AWZsEczIJ5DwsSbDkKZstBMFveALPl9TBbXgez5bUwW14Ds+XV4L7lQCFWXQiy6hKQVe8DWfUNkFXfBFn1MpBVr1DAqlcIsOqVQqx6pYtV9/KuOZ/3dh3MqvUwqzbArNoIs2oTzKrNMKu2wKyagFk1CbNqCmbVNMyqGZhVszCr5mBWzXtYlWDf0TD7/gpm30Ew+94As+/1MPteB7PvtTD7kiw9sMDSNPuuBtl3E8i+94Ps+ybIvlNB9r0CZN+rFLDvVQLsO1CIfQe62Lend835vLcXwOxbB7NvPcy+DTD7NsLs2wSzbzPMvi0w+yZg9k3C7JuC2TcNs28GZt8szL45mH3zHvYlWHoMzNK/hln6VzBLD4JZ+gaYpa+HWfo6mKWvhVn6GnBf+mohNm9VzLF5STG3fh8A2XwqyObTQDa/CmTzqxWw+dUCbH6NEJtf42LzXt415/Pent+aZfMFMJvXwWxeD7N5A8zmjTCbN8Fs3gyzeQvM5gmYzZMwm6dgNk/DbJ6B2TwLs3kOZvO8h80J1n8CZv0bYdb/Ncz6v4JZfxDM+jfArH89zPrXwaxPPjtcXXh2oFm/K8j6PUDW/z3I+tNA1n8LZP2rQda/lmP9sDOGBOtfK8D61wmx/nWC+/AO6/8RZv0HYdb/E8z6D8Gs/zDM+o/ArP8ozPqPwaw/DGb9x2HWHw6z/giY9UfCrD8KZv3RMOuPgVmfZPNfwmx+Gczml8NsfgXM5lfCbH4VzOYDYTa/2sPmfjnumgKbty2Mt3lcv9z6Fsit00FuvRbk1utBfnPGkODW6wW49QYhbr1B8HenHW59EObWP8Hc+hDMrQ/D3PoIzK2Pwtz6GMytw2BufRzm1uEwt46AuXUkzK2jYG4dDXPrGJhbSc68DObMy2HOvALmzCthzrwK5syBMGdeDXPmNQXOpLlwOsiFM0AuvB7kwkEKuHCQABf+SogLfyX4+Q8OF/4J5sKHYC58GObCR2AufBTmwsdgLhwGc+HjMBcOh7lwBMyFI2EuHAVz4WiYC8fAXEhy3OUwx10Bc9yVMMddBXPcQJjjroY57hoPx/ne7xLiuBkgx80EOW4QyHG/VsBxvxbguBuFOO5Gwc90dTjuIZjjHoY57hGY4x6FOe4xmOOGwRz3OMxxw2GOGwFz3EiY40bBHDca5rgxMMeR3HUFzF1Xwtx1FcxdA2Huuhrmrmtg7rq2wF00J80EOWkWyEm/BjnpNwo46TcCnPRbIU76reC5RQ4nPQxz0iMwJz0Kc9JjMCcNgznpcZiThsOcNALmpJEwJ42COWk0zEljYE4iueZKmGuugrlmIMw1V8Nccw3MNdd6uMZvzl8nxDWzQK6ZDXLNb0Cu+Z0CrvmdANfcJMQ1NwmeVe1wzSMw1zwKc81jMNcMg7nmcZhrhsNcMwLmmpEw14yCuWY0zDVjYK4hOeQqmEMGwhxyNcwh18Acci3MIdcVOITmhtkgN8wBueF3IDfcrIAbbhbghluEuOEWFzd082gmuOFRmBseg7lhGMwNj8PcMBzmhhEwN4yEuWEUzA2jYW4YA3MDmfMD4Zy/Gs75a+CcvxbO+es8Oe/7916Fcn4OmPNzwZy/Gcz5WxXk/K0COX+bUM7f5sr5rh7NRM4/Buf8MDjnH4dzfjic8yPgnB8J5/woOOdHwzk/Bs55MpevhnP5GjiXr4Vz+To4l68v5DKdo3PBHH0bzNFbwRwdrCBHBwvk6O1COXq7K0e7eDQTOToMztHH4RwdDufoCDhHR8I5OgrO0dFwjo6Bc5TMvWvg3LsWzr3r4Ny73pN7fnPgBqHcexvMvXfA3BsM5t4QBbk3RCD37hDKvTtcudfJo5nIvcfh3BsO594IOPdGwrk3Cs690XDujYFzj8ypa+Gcug7OqevhnLqhkFN0rrwD5sq7YK4MAXPlTgW5cqdArtwllCt3uXKlo0czkSvD4VwZAefKSDhXRsG5MhrOlTFwrpA5cB2cA9fDOXCDJwd8/z2vUA68C+bAe2AO3AnmwN0KcuBugRy4RygH7nHlQAePZiIHRsA5MBLOgVFwDoyGc2AMnANk374e7ts3wH17UKFv0332PbDPzgP77N1gn71XQZ+9V6DPDhXqs0NdfbbEo5nosyPhPjsK7rOj4T47Bu6zZF+8Ae6Lgzx90W+f+JVQX5wH9sX3wb54L9gX71PQF+8T6Iv3C/XF+119sX0R3xdHwX1xNNwXx8B9kexjg+A+9qtCH6P7zvtg35kP9p37wL7zgIK+84BA3/m9UN/5vavvtBPoO6PhvjMG7jtkn/iVp0/4/hwXoT4xH+wTH4B94gGwT/xBQZ/4g0Cf+KNQn/ijq0+0EegTY+A+Qa7rXxfWNb0OPwDX4YfgOvwDuA4fVLAOHxRYh38SWod/2sY63I7mWHzbmr/24sMy1tujQ/x7VcTeA4G2BS9Liv7zRf0s5z3s7hmbvqedM6YpvVIa8wo05hRozCrQmFGgMa1AY0qBxqQCjQkFGlsUaGxWoLFJgcZGBRobFGisV6CxToHGBQo0OnsGlEZH28FFW1603g0KPN2oQOMmBRo/U6DxcwUav1Cg8UsFGr9SoNH5j947u8ZWCjS2VqCxjQKNbRVobKdAY3sFGosVaCxRoLGDAo27KNDYUYHGTgo0dlagsYsCjV0VaNxVgcZuCjR2V6BxNwUad1egcQ8FGnso0LinAo17KdC4twKNPRVo7AVqdLT1L9rysnvjO6dGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744zG/7W98SLPZce149px7bh2XDuuHdeOa8e149px7bj/7bW1z4ppzf6M4IE+noeCnteH78hYwW3/s9R8+4DzDe/QWLXbvKTm2xecbz8F8x0Azvc8BfM9H5zvJQrmeyk434EK5jsInO9NCuY7BJzvUAXzfRCc7zAF8x0DzvcpBfMdC853soL5vgrOd6qC+c4G5ztPwXzrwfkmFcx3ITjfJQrmuxqc7yYF821VzM23pHjnn29XcL49XGP5/bzkb+Nzcdcr+F3/dQo0rlWgcY0CjasVaFylQONKBRpXKNC4XIHGZQo0LlWgcYkCjZ8q0PiJAo2LFWj8WIHGjxRoXARq/DaY/Oaynd/TWxRovFWBxtsUaBysQOPtCjQOUaDxDgUa71Sg8S4FGu9WoPEeBRrvVaBxqAKN9ynQeL8CjQ8o0Ph7UKNl8m80WiZnNFomZzRaJmc0WiZnNFomZzRaJmc0WiZnNFomZzTSTL5Z42Y2fyhUVPSwqUdMPWrqMVPDTD1uaripEaZGmhplarSpMaaeMPWkqT+b+oupv7rOJccNcA7TpgxwDtB2qlPRf76on/VtPADZA7QZjfYAbUajPUCb0WgP0C4ixrUHaEMa7QHajEZ7gDaj0R6gzWi0B2jbQ0ICPi8pjfaQEEajPSSE0WgPCWE02kNCGI32kBBGoz0khNFoDwlhNNpDQhiN9pAQRqM9JITRaA8JYTTaQ0IYjfaQEEajPSSE0WgPCWE02kNCGI32AG27Nx7weUlptHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otAdo23HtuHZcO64d145rx7Xj2nHtuHZcO+5/d23ts2Jasz/DHqC9I9/seW0P0N7W9d3M1x6gvQPf7HltD9De1vXdzNceoL0D3+x5bQ/Q3tb13czXHqC9A9/seW0P0N7W9d3M1x6gvQPf7HltD9De1vXdzNceoL0D3+x5bQ/QtgdoB/xd9gBtSKM9QJvRaA/QZjTaA7QZjfYAbUajPUCb0WgP0GY02gO0GY32AG1eoz2sj9FoD+tjNNrD+hiN9rA+RqM9rI/RaA/rYzTaw/oYjfawPkYjfVjfZn3ei/wZlvst91MaLfczGi33Mxot9zMaLfczGi33Mxot9zMaLfczGi33/9sVdA4Wp/RKaXxYgcZHFGh8VIHGxxRoHKZA4+MKNA5XoHGEAo0jFWgcpUDjaAUaxyjQ+IQCjU8q0PhnBRr/okDjX0GN3wL3B9u4fNjM/38zc3jK1NOm/m7qH6aeMfWsqedMjTU1ztTzpsabmmBqoqlJpiabmmLqhdCWY75oXr9k6mVTr5h61dQ/Tf3L1GumXjf1hqk3TU01Nc3UW6amm5phaqapWYUxN5/XPdu8nmNqrqm3Tb1j6l1T75maZ+p9U/NNfWDqQ1MLTNWZqjfVYKrRVJOpZlMtphKmkqZSptKmMqaypnKm8qYWmlpk6iNTH5tabOoTU5+aWhJyvVf0TXXYIeyNL6Hvb6F/H9fvH4YshRdTm8LcnXFvFHyvnhLwYpmQF8uEvXhawIvlQl4sF/bi7wJerBDyYoWwF/8Q8GKlkBcrhb14RsCLVUJerBL24lkBL1YLebFa2IvnBLxYI+TFGmEvxgp4sVbIi7XCXowT8GKdkBfrhL14XsCL9UJerBf2YryAFxuEvNgg7MUEAS82CnmxUdiLiQJebBLyYpOwF5MEvPhMyIvPhL2YLODF50JefC7sxRQBL74Q8uILYS9eEPDiSyEvnHG7FMZtDWue3/obLyhvnV8KcYr29uTIzr8/OFvgnjolInNPOeO2ElxfcwS86CfkRT9hL+YKeHGqkBenCnvxtoAXpwl5cZqwF+8IeHG6kBenC3vxroAX/YW86C/sxXsCXpwh5MUZwl7ME/DiTCEvzhT24n0BLwYIeTFA2Iv5Al6cJeTFWcJefCDgxdlCXpwt7MWHAl6cI+TFOcJeLBDw4lwhL84V9qJOwIvvC3nxfWEv6gW8+IGQFz8Q9qJBwIvzhLw4T9iLRgEvfijkxQ+FvWgS8OJHQl78SNiLZgEvfizkxY+FvWgR8OInQl78RNiLhIAXPxXy4qfCXiQFvPiZkBc/E/YiJeDF+UJenC/sRVrAi58LefFzYS8yAl5cIOTFBcJeZAW8+IWQF78Q9iIn4MWFQl5cKOxFXsCLi4S8uEjYi4UCXlws5MXFwl4sEvDiEiEvLhH24iMBL6qEvKgS9uJjAS+qhbyoFvZisYAXMSEvYsJefCLgRY2QFzUuL7y/3xQM14bDVVWhmqpoIBSJlIeisVAoEq4oLTPSQ7FoKFIWiFSU1YRCtdWxqlhFsCZaGo1FqqrCpWXRYDi8sN03f7f3f+NFwzXxslhNIFwVLK+oDoXiFVXxeHk8FI/UGEvKaoKBsohZAqVl1TVVZvzScLmxIBgtj9bEwvFotfPBjk618+r0Oe4WB1VXVEdqy4KxuJlqOB4KV0Rj1bHSsPkJ5aUV5TXxWGkgWltRUV5bG4zEw4GyqlAoUFFaHq+Nhs2PjJW7D6r269+OfKBN+Xb+fXaIuxfj3L0YlFqD8Qi/BmuF1qAz7i2FcdvAazDvXYPAmn7KfV+WRiKRaGmkNBYM1AbLg4HyWMgshXBZdaSiKharikRrSmsjsRrzv2BNdSBo1pdZUNF4VVl1RU1NWchZz86HoRbDa7oPuKbD4Jp+GFiH8a+P8YsFZ4P9YQ7Yp939we+auzSCeR+R6jWXCvSaXwr1ml+6ek07uNfk4F6T9/Qaonc9Dfcu94ck+103twj1wr5gL+wH9sJHwF44B+yFc8FeeCnYCy9T0AsvE+iFlwv1wstdvbB9EdsLs3AvzMG9MO/phURv/TvcW7f4cHef491S6NV0bx0A9tbzwN76KNhb54K99W2wt14G9tYrFPTWKwR665VCvfVKV28t8a45n/d2Bu6tWbi35uDemvf0VqJX/wPu1YPhXn0byNW3CvX+88HefwnY+x8De//bYO9/B+z9V4C9/yoFvf8qgd4/UKj3D3T1/g7eNefz3k7DvT8D9/4s3PtzcO/Pe3o/kSXPwFlyO5wlZDbdWsgmOksuBbNkIJglw8AseQfMknfBLLkKzJKrFWTJ1QJZco1QllzjypKO3jXn895OwVmShrMkA2dJFs6SHJwleU+WENn0LJxNQ+Bsuh3OpsHgc9NtQlk3CMy6m8CsexzMunfBrHsPzLqrway7VkHWXSuQddcJZd11rqzr5F1zPu/tJJx1KTjr0nDWZeCsy8JZl4OzLu/JOiI7n4Oz8w44O4fA2Ulm8W2FLKazcwiYnUPB7BwOZud7YHbOA7PzWjA7r1eQndcLZOcNQtl5gys7u3jXnM97OwFnZxLOzhScnWk4OzNwdmbh7MzB2Zn3ZCeRxWPhLL4TzuI74CweAmfx7eBz8WChbH8QzPZhYLaPALN9Hpjt74PZfj2Y7YMUZPsggWz/lVC2/8qV7V29a87nvd0CZ3sCzvYknO0pONvTcLZn4GzPwtmeg7M978l2ghXGwaxwF8wKd8KscAfMCiR7DC6wB80KY0BWeApkhZEgK7wPssJ8kBUGgazwawWs8GsBVrhRiBVudLFCN++a83lvN8Os0AKzQgJmhSTMCimYFdIwK2RgVsjCrJCDWSHvYQWCPZ6H2eNumD3ugtnjTpg97oDZYwi473G7EMuMBVlmMsgyo0CWmQ+yzAcgy/waZJnfKGCZ3wiwzG+FWOa3Lpbp7l1zPu/tJphlmmGWaYFZJgGzTBJmmRTMMmmYZTIwy2RhlsnBLJP3sAzBRuNhNroHZqO7YTa6C2ajO2E2Ilnr9gJr0Wz0KshGU0E2Gg2y0QcgG30IstFvQDb6nQI2+p0AG90kxEY3udhod++a83lvN8Js1ASzUTPMRi0wGyVgNkrCbJSC2SgNs1EGZqMszEY5mI3yHjYiWGsCzFr3wqx1D8xad8OsdRfMWnfCrHUHuK81RIjdZoPsNg9ktzEgu30IstsCkN1+B7LbzQrY7WYBdrtFiN1ucbHbHt415/PeboDZrRFmtyaY3ZphdmuB2S0Bs1sSZrcUzG5pmN0yMLtlYXbLweyW97AbwYITYRYcCrPgvTAL3gOz4N0wC94FsyDJlkMKbEmzYD3IgkmQBZ8AWXAByIJ1IAveDLLgrQpY8FYBFrxNiAVvc7Hgnt415/PerodZsAFmwUaYBZtgFmyGWbAFZsEEzIJJmAVTMAumYRbMwCyYhVkwB7Ng3sOCBFtOgtnyPpgth8JseS/MlvfAbHk3zJZ3wWx5J7hveYcQqy4EWXUJyKpPgqxaB7JqPciqt4KsOlgBqw4WYNXbhVj1dher7uVdcz7v7TqYVethVm2AWbURZtUmmFWbYVZtgVk1AbNqEmbVFMyqaZhVMzCrZmFWzcGsmvewKsG+k2H2vR9m3/tg9h0Ks++9MPveA7Pv3TD7kix9R4GlafZdDbLvJpB9/wyybz3Ivg0g+w4G2XeIAvYdIsC+dwix7x0u9u3pXXM+7+0FMPvWwexbD7NvA8y+jTD7NsHs2wyzbwvMvgmYfZMw+6Zg9k3D7JuB2TcLs28OZt+8h30Jlp4Cs/QDMEvfD7P0fTBLD4VZ+l6Ype+BWfpumKXvAvel7xRi81bFHJuXFHPr9y8gmzeAbN4IsvkQkM3vVMDmdwqw+V1CbH6Xi817edecz3t7fmuWzRfAbF4Hs3k9zOYNMJs3wmzeBLN5M8zmLTCbJ2A2T8JsnoLZPA2zeQZm8yzM5jmYzfMeNidY/wWY9X8Ps/4DMOvfD7P+fTDrD4VZ/16Y9e+BWZ98driz8OxAs35XkPV7gKz/V5D1G0HWbwJZ/06Q9e/mWD/sjCHB+ncLsP49Qqx/j+A+vMP6T8Gs/zTM+n+HWf8fMOs/A7P+szDrPwez/liY9cfBrP88zPrjYdafALP+RJj1J8GsPxlm/Skw65NsfgvM5rfCbH4bzOaDYTa/HWbzITCb3wGz+Z0eNvfLcXcV2LxtYbzN4/rl1iaQW5tBbr0b5NZ7QX5zxpDg1nsFuHWoELcOFfzdaYdbn4a59e8wt/4D5tZnYG59FubW52BuHQtz6ziYW5+HuXU8zK0TYG6dCHPrJJhbJ8PcOgXmVpIzb4U58zaYMwfDnHk7zJlDYM68A+bMO2HOvKvAmTQXNoNc2AJy4b0gF96ngAvvE+DC+4W48H7Bz39wuPDvMBf+A+bCZ2AufBbmwudgLhwLc+E4mAufh7lwPMyFE2AunAhz4SSYCyfDXDgF5kKS426DOW4wzHG3wxw3BOa4O2COuxPmuLs8HOd7v0uI41pAjkuAHHcfyHEPKOC4BwQ47vdCHPd7wc90dTjuHzDHPQNz3LMwxz0Hc9xYmOPGwRz3PMxx42GOmwBz3ESY4ybBHDcZ5rgpMMeR3DUY5q7bYe4aAnPXHTB33Qlz110wd91d4C6akxIgJyVBTnoA5KQ/KOCkPwhw0h+FOOmPgucWOZz0DMxJz8Kc9BzMSWNhThoHc9LzMCeNhzlpAsxJE2FOmgRz0mSYk6bAnERyze0w1wyBueYOmGvuhLnmLphr7vZwjd+cv0eIa5Ig16RArvkDyDUPKuCaBwW45k9CXPMnwbOqHa55Fuaa52CuGQtzzTiYa56HuWY8zDUTYK6ZCHPNJJhrJsNcMwXmGpJDhsAccgfMIXfCHHIXzCF3wxxyT4FDaG5IgdyQBrnhQZAbHlLADQ8JcMPDQtzwsIsbunk0E9zwHMwNY2FuGAdzw/MwN4yHuWECzA0TYW6YBHPDZJgbpsDcQOb8HXDO3wnn/F1wzt8N5/w9npz3/XuvQjmfBnM+A+b8Q2DOP6Ig5x8RyPlHhXL+UVfOd/VoJnJ+LJzz4+Ccfx7O+fFwzk+Ac34inPOT4JyfDOf8FDjnyVy+E87lu+BcvhvO5XvgXL63kMt0jmbAHM2COfoImKOPKcjRxwRydJhQjg5z5WgXj2YiR8fBOfo8nKPj4RydAOfoRDhHJ8E5OhnO0SlwjpK5dxece3fDuXcPnHv3enLPbw4MFcq9LJh7OTD3HgNz73EFufe4QO4NF8q94a7c6+TRTOTe83DujYdzbwKcexPh3JsE595kOPemwLlH5tTdcE7dA+fUvXBODS3kFJ0rOTBX8mCuPA7myggFuTJCIFdGCuXKSFeudPRoJnJlPJwrE+BcmQjnyiQ4VybDuTIFzhUyB+6Bc+BeOAeGenLA99/zCuVAHsyBhWAOjABzYJSCHBglkAOjhXJgtCsHOng0EzkwAc6BiXAOTIJzYDKcA1PgHCD79r1w3x4K9+37Cn2b7rMLwT67COyzo8A+O0ZBnx0j0GefEOqzT7j6bIlHM9FnJ8J9dhLcZyfDfXYK3GfJvjgU7ov3efqi3z5xv1BfXAT2xY/AvjgG7ItPKuiLTwr0xT8L9cU/u/pi+yK+L06C++JkuC9Ogfsi2cfug/vY/YU+Rvedj8C+8zHYd54E+85fFPSdvwj0nb8K9Z2/uvpOO4G+MxnuO1PgvkP2ifs9fcL357gI9YmPwT6xGOwTfwH7xN8U9Im/CfSJp4T6xFOuPtFGoE9MgfsEua4fKKxreh0uBtfhJ+A6/Bu4Dp9WsA6fFliHfxdah3/fxjrcjuZYfNuav/bikxDr7ckR/r0qYu+BQNuClyVF//mifpbzHnb3jE3f084Z05ReKY15BRpzCjRmFWjMKNCYVqAxpUBjUoHGhAKNLQo0NivQ2KRAY6MCjQ0KNNYr0FinQOMCBRqdPQNKo6Pt4KItL1rvBgWeblSgcZMCjZ8p0Pi5Ao1fKND4pQKNXynQ6PxH751dYysFGlsr0NhGgca2CjS2U6CxvQKNxQo0lijQ2EGBxl0UaOyoQGMnBRo7K9DYRYHGrgo07qpAYzcFGrsr0LibAo27K9C4hwKNPRRo3FOBxr0UaNxbgcaeCjT2AjU62voXbXnZvfGdU6PdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRuP/2t54keey49px7bh2XDuuHdeOa8e149px7bh23P/22tpnxbRmf0bwQB/PQ0HP68N3ZKzgtv9Zar59wPmGd2is2m1eUvPtC863n4L5DgDne56C+Z4PzvcSBfO9FJzvQAXzHQTO9yYF8x0Czneogvk+CM53mIL5jgHn+5SC+Y4F5ztZwXxfBec7VcF8Z4PznadgvvXgfJMK5rsQnO8SBfNdDc53k4L5tirm5ltSvPPPtys43x6usfx+XvK38bm46xX8rv86BRrXKtC4RoHG1Qo0rlKgcaUCjSsUaFyuQOMyBRqXKtC4RIHGTxVo/ESBxsUKNH6sQONHCjQuAjV+G0z+UGjn9/RhBRofUaDxUQUaH1OgcZgCjY8r0DhcgcYRCjSOVKBxlAKNoxVoHKNA4xMKND6pQOOfFWj8iwKNfwU1Wib/RqNlckajZXJGo2VyRqNlckajZXJGo2VyRqNlckajZXJGI83kmzVuZvN/RIqKnjH1rKnnTI01Nc7U86bGm5pgaqKpSaYmm5pi6gVTL5p6ydTLpl5xnUuOG+Acpk0Z4Byg7VSnov98UT/r23gAsgdoMxrtAdqMRnuANqPRHqDNaLQHaDMa7QHajEZ7gDaj0R6gzWi0B2jbQ0ICPi8pjfaQEEajPSSE0WgPCWE02kNCGI32kBBGoz0khNFoDwlhNNpDQhiN9pAQRqM9JITRaA8JYTTaQ0IYjfaQEEajPSSE0WgPCWE02kNCGI32AG27Nx7weUlptHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otHvjjEa7N85otAdo23HtuHZcO64d145rx7Xj2nHtuHZcO+5/d23ts2Jasz/DHqC9I9/seW0P0N7W9d3M1x6gvQPf7HltD9De1vXdzNceoL0D3+x5bQ/Q3tb13czXHqC9A9/seW0P0N7W9d3M1x6gvQPf7HltD9De1vXdzNceoL0D3+x5bQ/QtgdoB/xd9gBtSKM9QJvRaA/QZjTaA7QZjfYAbUajPUCb0WgP0GY02gO0GY32AG1eoz2sj9FoD+tjNNrD+hiN9rA+RqM9rI/RaA/rYzTaw/oYjfawPkYjfVjfZn3ei/wZlvst91MaLfczGi33Mxot9zMaLfczGi33Mxot9zMaLfczGi33/9sVdA4Wp/RKaXxGgcZnFWh8ToHGsQo0jlOg8XkFGscr0DhBgcaJCjROUqBxsgKNUxRofEGBxhcVaHxJgcaXFWh8BdT4LXB/sI3Lh838/6qZwz9N/cvUa6ZeN/WGqTdNTTU1zdRbpqabmmFqpqlZpmabmmNqrqm3I1uO+Y55/a6p90zNM/W+qfmmPjD1oakFpupM1ZtqMNVoqslUs6kWUwlTycKYm8/rTpnXaVMZU1lTOVN5UwtNLTL1kamPTS029YmpT00tMbXU1DJTy02tMLXS1CpTq02tMbXW1DpT601tMLXR1CZTn5n63NQXpr409ZWpogqjyVTrCtd7Rd9Uhx3C3vgS+l6N/Pu4fv8wpE0Fu5jaFObujHuj4Hv1TwEv2gp50VbYi38JeNFOyIt2wl68JuBFeyEv2gt78bqAF8VCXhQLe/GGgBclQl6UCHvxpoAXHYS86CDsxVQBL3YR8mIXYS+mCXjRUciLjsJevCXgRSchLzoJezFdwIvOQl50FvZihoAXXYS86CLsxUwBL7oKedFV2ItZAl7sKuTFrsJezBbwopuQF92EvZgj4EV3IS+6C3sxV8CL3YS82E3Yi7cFvNhdyAtn3C6FcVvDmue3/sYLylvnl0Kcor39WXTn3x9MCdxT50dl7iln3FaC6yst4MXPhbz4ubAXGQEvLhDy4gJhL7ICXvxCyItfCHuRE/DiQiEvLhT2Ii/gxUVCXlwk7MVCAS8uFvLiYmEvFgl4cYmQF5cIe/GRgBdVQl5UCXvxsYAX1UJeVAt7sVjAi5iQFzFhLz4R8KJGyIsaYS8+FfAiLuRFXNiLJQJe1Ap5USvsxVIBLy4V8uJSYS+WCXjxSyEvfinsxXIBLy4T8uIyYS9WCHhxuZAXlwt7sVLAiyuEvLhC2ItVAl5cKeTFlcJerBbw4iohL64S9mKNgBcDhbwYKOzFWgEvrhby4mphL9YJeHGNkBfXCHuxXsCLa4W8uFbYiw0CXlwn5MV1wl5sFPDieiEvrhf2YpOAFzcIeXGDsBefCXgxSMiLQcJefC7gxa+EvPiVsBdfCHjxayEvfi3sxZcCXtwo5MWNwl58JeDFb4S8+I2wF1//0R7sxW+FvPitywvv7zcFw7XhcFVVqKYqGghFIuWhaCwUioQrSsuM9FAsGoqUBSIVZTWhUG11rCpWEayJlkZjkaqqcGlZNBgOL2z3zd/t/d940XBNvCxWEwhXBcsrqkOheEVVPF4eD8UjNcaSsppgoCxi/lNQaVl1TZUZvzRcbiwIRsujNbFwPFrtfLCjU+28On2Ou8VB1RXVkdqyYCxuphqOh8IV0Vh1rDRsfkJ5aUV5TTxWGojWVlSU19YGI/FwoKwqFApUlJbHa6Nh8yNj5e6Dqv36tyMfaFO+nX9PRbh78XfcvRiUWoO/i/Jr8CahNeiMe0th3DbwGsx71yCwpv/pvi9LI5FItDRSGgsGaoPlwUB5LGSWQrisOlJRFYtVRaI1pbWRWI35X7CmOhA068ssqGi8qqy6oqamLOSsZ+fDUIvhNd0HXNNhcE0/A6zD+NfH+MWCKbA/pME+7e4PftfczVHM+4hUr7lZoNfcItRrbnH1mnZwr8nBvSbv6TVE7/oX3LvcH5Lsd908LNQL+4K9sB/YC58Fe2Ea7IUZsBfeDPbCWxX0wlsFeuFtQr3wNlcvbF/E9sIs3AtzcC/Me3oh0Vtfg3vrFh/u7nO8hwu9mu6tA8Deeh7YW58De2sG7K1ZsLfeCvbWwQp662CB3nq7UG+93dVbS7xrzue9nYF7axburTm4t+Y9vZXo1a/DvfoxuFc/CnL1I0K9/3yw918C9v6xYO/Pgr0/B/b+wWDvH6Kg9w8R6P13CPX+O1y9v4N3zfm8t9Nw78/AvT8L9/4c3Pvznt5PZMkbcJYMg7OEzKZHCtlEZ8mlYJYMBLNkHJglOTBL8mCWDAGz5E4FWXKnQJbcJZQld7mypKN3zfm8t1NwlqThLMnAWZKFsyQHZ0nekyVENr0JZ9PjcDYNg7PpMfC56VGhrBsEZt1NYNY9D2ZdHsy6hWDW3Qlm3d0Ksu5ugay7Ryjr7nFlXSfvmvN5byfhrEvBWZeGsy4DZ10WzrocnHV5T9YR2TkVzs7hcHY+DmcnmcWPFrKYzs4hYHYOBbNzPJidC8HsXARm591gdt6rIDvvFcjOoULZOdSVnV28a87nvZ2AszMJZ2cKzs40nJ0ZODuzcHbm4OzMe7KTyOJpcBaPgLN4OJzFj8NZPAx8Ln5MKNsfBLN9GJjtE8BsXwRm+0dgtt8LZvt9CrL9PoFsv18o2+93ZXtX75rzeW+3wNmegLM9CWd7Cs72NJztGTjbs3C25+Bsz3uynWCFt2BWGAmzwgiYFYbDrECyx2MF9qBZYQzICk+BrDARZIWPQFb4GGSF+0BWeEABKzwgwAq/F2KF37tYoZt3zfm8t5thVmiBWSEBs0ISZoUUzAppmBUyMCtkYVbIwayQ97ACwR7TYfYYBbPHSJg9RsDsMRxmj8fBfY9hQiwzFmSZySDLTAJZ5mOQZRaDLPMAyDJ/UMAyfxBgmT8KscwfXSzT3bvmfN7bTTDLNMMs0wKzTAJmmSTMMimYZdIwy2RglsnCLJODWSbvYRmCjWbAbDQaZqNRMBuNhNloBMxGJGsNK7AWzUavgmw0FWSjySAbLQbZ6BOQjf4AstGDCtjoQQE2+pMQG/3JxUa7e9ecz3u7EWajJpiNmmE2aoHZKAGzURJmoxTMRmmYjTIwG2VhNsrBbJT3sBHBWjNh1hoDs9ZomLVGwaw1EmatETBrDQf3tR4XYrfZILvNA9ltCshun4Ds9inIbg+C7PaQAnZ7SIDdHhZit4dd7LaHd835vLcbYHZrhNmtCWa3ZpjdWmB2S8DsloTZLQWzWxpmtwzMblmY3XIwu+U97Eaw4CyYBZ+AWXAMzIKjYRYcBbPgSJgFSbZ8vMCWNAvWgyyYBFnwBZAFPwVZcAnIgg+BLPiIAhZ8RIAFHxViwUddLLind835vLfrYRZsgFmwEWbBJpgFm2EWbIFZMAGzYBJmwRTMgmmYBTMwC2ZhFszBLJj3sCDBlrNhtnwSZssnYLYcA7PlaJgtR8FsORJmyxHgvuVwIVZdCLLqEpBVXwRZdQnIqktBVn0EZNXHFLDqYwKsOkyIVYe5WHUv75rzeW/XwaxaD7NqA8yqjTCrNsGs2gyzagvMqgmYVZMwq6ZgVk3DrJqBWTULs2oOZtW8h1UJ9p0Ds++fYfZ9EmbfJ2D2HQOz72iYfUfB7Euy9PACS9Psuxpk300g+74Esu9SkH2Xgez7GMi+jytg38cF2He4EPsOd7FvT++a83lvL4DZtw5m33qYfRtg9m2E2bcJZt9mmH1bYPZNwOybhNk3BbNvGmbfDMy+WZh9czD75j3sS7D0XJil/wKz9J9hln4SZuknYJYeA7P0aJilR8EsPRLclx4hxOatijk2Lynm1u/LIJsvA9l8Ocjmj4NsPkIBm48QYPORQmw+0sXmvbxrzue9Pb81y+YLYDavg9m8HmbzBpjNG2E2b4LZvBlm8xaYzRMwmydhNk/BbJ6G2TwDs3kWZvMczOZ5D5sTrP82zPp/hVn/LzDr/xlm/Sdh1n8CZv0xMOuPhlmffHYYUXh2oFm/K8j6PUDWfwVk/eUg668AWX8EyPqjONYPO2NIsP4oAdYfLcT6owX34R3W/yfM+v+CWf81mPVfh1n/DZj134RZfyrM+tNg1n8LZv3pMOvPgFl/Jsz6s2DWnw2z/hyY9efCrE+y+cMwmz8Cs/mjMJs/BrP5MJjNH4fZfDjM5iM8bO6X40YW2LxtYbzN4/rl1hUgt64EuXUUyK1jQH5zxpDg1jEC3PqEELc+Ifi70w63/gvm1tdgbn0d5tY3YG59E+bWqTC3ToO59S2YW6fD3DoD5taZMLfOgrl1Nsytc2BunQtzK8mZj8Cc+SjMmY/BnDkM5szHYc4cDnPmCJgzRxY4k+bClSAXrgK5cAzIhU8q4MInBbjwz0Jc+GfBz39wuPA1mAtfh7nwDZgL34S5cCrMhdNgLnwL5sLpMBfOgLlwJsyFs2AunA1z4RyYC+fCXEhy3KMwxz0Gc9wwmOMehzluOMxxI2COG+nhON/7XUIctwrkuNUgxz0JctxfFHDcXwQ47q9CHPdXwc90dTjudZjj3oA57k2Y46bCHDcN5ri3YI6bDnPcDJjjZsIcNwvmuNkwx82BOW4uzHEkdz0Gc9cwmLseh7lrOMxdI2DuGglz16gCd9GctBrkpDUgJ/0F5KS/KeCkvwlw0lNCnPSU4LlFDie9AXPSmzAnTYU5aRrMSW/BnDQd5qQZMCfNhDlpFsxJs2FOmgNz0lyYk0iuGQZzzeMw1wyHuWYEzDUjYa4Z5eEavzk/Wohr1oBcsxbkmr+BXPO0Aq55WoBr/i7ENX8XPKva4Zo3Ya6ZCnPNNJhr3oK5ZjrMNTNgrpkJc80smGtmw1wzB+aauTDXkBzyOMwhw2EOGQFzyEiYQ0bBHDK6wCE0N6wFuWEdyA1Pg9zwDwXc8A8BbnhGiBuecXFDN49mghumwtwwDeaGt2BumA5zwwyYG2bC3DAL5obZMDfMgblhLswNZM4Ph3N+BJzzI+GcHwXn/GhPzvv+vVehnF8H5vx6MOf/Aeb8swpy/lmBnH9OKOefc+V8V49mIuenwTn/Fpzz0+GcnwHn/Ew452fBOT8bzvk5cM7PhXOezOURcC6PhHN5FJzLo+FcHlPIZTpH14M5ugHM0WfBHB2rIEfHCuToOKEcHefK0S4ezUSOvgXn6HQ4R2fAOToTztFZcI7OhnN0Dpyjc+EcJXNvJJx7o+DcGw3n3hhP7vnNgSeEcm8DmHsbwdwbC+be8wpy73mB3BsvlHvjXbnXyaOZyL3pcO7NgHNvJpx7s+Dcmw3n3hw49+bCuUfm1Cg4p0bDOTUGzqknCjlF58pGMFc2gbnyPJgrExTkygSBXJkolCsTXbnS0aOZyJUZcK7MhHNlFpwrs+FcmQPnylw4V8gcGA3nwBg4B57w5IDvv+cVyoFNYA58BubABDAHJinIgUkCOTBZKAcmu3Kgg0czkQMz4RyYBefAbDgH5sA5MBfOAbJvj4H79hNw336y0LfpPvsZ2Gc/B/vsJLDPTlHQZ6cI9NkXhPrsC64+W+LRTPTZWXCfnQ332Tlwn50L91myLz4B98UnPX3Rb5/4s1Bf/Bzsi1+AfXEK2BdfVNAXXxToiy8J9cWXXH2xfRHfF2fDfXEO3Bfnwn2R7GNPwn3sz4U+RvedL8C+8yXYd14E+87LCvrOywJ95xWhvvOKq++0E+g7c+C+MxfuO2Sf+LOnT/j+HBehPvEl2Ce+AvvEy2CfeFVBn3hVoE/8U6hP/NPVJ9oI9Im5cJ8g1/VfCuuaXodfgeuwqIJbh6+C6/BfCtbhvwTW4WtC6/C1bazD7WiOxbet+Wsv3PdRwN/19Xg/i/LvVRF7DwTaFrwsKfrPF/WznPewu2ds+p52zpim9EppzCvQmFOgMatAY0aBxrQCjSkFGpMKNCYUaGxRoLFZgcYmBRobFWhsUKCxXoHGOgUaFyjQ6OwZUBodbQcXbXnRejco8HSjAo2bFGj8TIHGzxVo/EKBxi8VaPxKgUbnP3rv7BpbKdDYWoHGNgo0tlWgsZ0Cje0VaCxWoLFEgcYOCjTuokBjRwUaOynQ2FmBxi4KNHZVoHFXBRq7KdDYXYHG3RRo3F2Bxj0UaOyhQOOeCjTupUDj3go09lSgsReo0dHWv2jLy+6N75wa7d44o9HujTMa7d44o9HujTMa7d44o9HujTMa7d44o9HujTMa7d44o9HujTMa7d44o9HujTMa7d44o9HujTMa7d44o9HujTMa/9f2xos8lx3XjmvHtePace24dlw7rh3XjmvHteP+t9fWPiumNfszggf6eB4Kel4fviNjBbf9z1Lz7QPON7xDY9Vu85Kab19wvv0UzHcAON/zFMz3fHC+lyiY76XgfAcqmO8gcL43KZjvEHC+QxXM90FwvsMUzHcMON+nFMx3LDjfyQrm+yo436kK5jsbnO88BfOtB+ebVDDfheB8lyiY72pwvpsUzLdVMTffkuKdf75dwfn2cI3l9/OSv43PxV2v4Hf91ynQuFaBxjUKNK5WoHGVAo0rFWhcoUDjcgUalynQuFSBxiUKNH6qQOMnCjQuVqDxYwUaP1KgcRGo8dtg8n9Edn5Pn1Gg8VkFGp9ToHGsAo3jFGh8XoHG8Qo0TlCgcaICjZMUaJysQOMUBRpfUKDxRQUaX1Kg8WUFGl8BNVom/0ajZXJGo2VyRqNlckajZXJGo2VyRqNlckajZXJGo2VyRiPN5Js1bmbz16NFRW+YetPUVFPTTL1larqpGaZmmpplarapOabmmnrb1Dum3jX1nql5rnPJcQOcw7QpA5wDtJ3qVPSfL+pnfRsPQPYAbUajPUCb0WgP0GY02gO0GY32AG1Goz1Am9FoD9BmNNoDtBmN9gBte0hIwOclpdEeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHqBt98YDPi8pjXZvnNFo98YZjXZvnNFo98YZjXZvnNFo98YZjXZvnNFo98YZjXZvnNFo98YZjXZvnNFo98YZjXZvnNFo98YZjXZvnNFo98YZjfYAbTuuHdeOa8e149px7bh2XDuuHdeOa8f9766tfVZMa/Zn2AO0d+SbPa/tAdrbur6b+doDtHfgmz2v7QHa27q+m/naA7R34Js9r+0B2tu6vpv52gO0d+CbPa/tAdrbur6b+doDtHfgmz2v7QHa27q+m/naA7R34Js9r+0B2vYA7YC/yx6gDWm0B2gzGu0B2oxGe4A2o9EeoM1otAdoMxrtAdqMRnuANqPRHqDNa7SH9TEa7WF9jEZ7WB+j0R7Wx2i0h/UxGu1hfYxGe1gfo9Ee1sdopA/r26zPe5E/w3K/5X5Ko+V+RqPlfkaj5X5Go+V+RqPlfkaj5X5Go+V+RqPl/n+7gs7B4pReKY1vKND4pgKNUxVonKZA41sKNE5XoHGGAo0zFWicpUDjbAUa5yjQOFeBxrcVaHxHgcZ3FWh8T4HGeaDGb4H7g21cPmzm//fNHOab+sDUh6YWmKozVW+qwVSjqSZTzaZaTCVMJU2lTKVNZUxlo1uOmTOv86YWmlpk6iNTH5tabOoTU5+aWmJqqallppabWmFqpalVplabWlMYc/N53WvN63Wm1pvaYGqjqU2mPjP1uakvTH1p6itTRcea7zXV2lQbU21NtTPV3lSxqRJTHUztYqqjqU6mOpvqYqqrqV1NdTPV3dRupnY3tYepHqb2NLXXsa73ir6pDjuEvfEl9L0f/fdx/f5hyN7HsoupTWHuzrg3Cr5X8wW86CnkRU9hLz4Q8KKXkBe9hL34UMCLfYS82EfYiwUCXuwr5MW+wl7UCXixn5AX+wl7US/gxf5CXuwv7EWDgBcHCHlxgLAXjQJeHCjkxYHCXjQJeNFbyIvewl40C3hxkJAXBwl70SLgxcFCXhws7EVCwItDhLw4RNiLpIAXhwp5caiwFykBLw4T8uIwYS/SAl4cLuTF4cJeZAS8OELIiyOEvcgKeHGkkBfOuF0K47aGNc9v/Y0XlLfOL4U4RXs78Lidf39wrcA9dfVxMveUM24rwfW1TsCLa4S8uEbYi/UCXlwr5MW1wl5sEPDiOiEvrhP2YqOAF9cLeXG9sBebBLy4QciLG4S9+EzAi0FCXgwS9uJzAS9+JeTFr4S9+ELAi18LefFrYS++FPDiRiEvbhT24isBL34j5MVvhL0oOpb34rdCXvxW2ItWAl78TsiL3wl70VrAi5uEvLhJ2Is2Al7cLOTFzcJetBXw4hYhL24R9qKdgBe3Cnlxq7AX7QW8uE3Ii9uEvSgW8GKwkBeDhb0oEfDidiEvbhf2ooOAF0OEvBgi7MUuAl7cIeTFHcJedBTw4k4hL+4U9qKTgBd3CXlxl7AXnQW8uFvIi7uFvegi4MU9Ql7cI+xFVwEv7hXy4l5hL3YV8GKokBdDhb3oJuDFfUJe3CfsRXcBL+4X8uJ+YS92E/DiASEvHhD2YncBL34v5MXvhb3YQ8CLPwh58QdhL3oIePFHIS/+6PLC+/tNwXBtOFxVFaqpigZCkUh5KBoLhSLhitIyIz0Ui4YiZYFIRVlNKFRbHauKVQRroqXRWKSqKlxaFg2GwwvbffN3e/83XjRcEy+L1QTCVcHyiupQKF5RFY+Xx0PxSI2xpKwmGCiLBALVpWXVNVVm/NJwubEgGC2P1sTC8Wi188GOTrXz6vQ57hYHVVdUR2rLgrG4mWo4HgpXRGPVsdKw+QnlpRXlNfFYaSBaW1FRXlsbjMTDgbKqUChQUVoer42GzY+MlbsPqvbr3458oE35dv59bZS7Fx/k7sWg1Bp88Dh+Df5JaA06495SGLcNvAbz3jUIrOn57vuyNBKJREsjpbFgoDZYHgyUx0JmKYTLqiMVVbFYVSRaU1obidWY/wVrqgNBs77MgorGq8qqK2pqykLOenY+DLUYXtN9wDUdBtf0G8A6jH99jF8suBbsD+vAPu3uD37X3EPHYd5HpHrNQwK95mGhXvOwq9e0g3tNDu41eU+vIXrXB3Dvcn9Ist9184xQL+wL9sJ+YC98E+yF68BeuB7shQ+BvfARBb3wEYFe+KhQL3zU1QvbF7G9MAv3whzcC/OeXkj01g/h3rrFh7v7HO+ZQq+me+sAsLeeB/bWqWBvXQ/21g1gb30E7K2PKeitjwn01mFCvXWYq7eWeNecz3s7A/fWLNxbc3BvzXt6K9GrF8C9eizcq58DufpZod5/Ptj7LwF7/zSw928Ae/9GsPc/Bvb+xxX0/scFev9wod4/3NX7O3jXnM97Ow33/gzc+7Nw78/BvT/v6f1EltTBWTIOzhIym54tZBOdJZeCWTIQzJK3wCzZCGbJJjBLHgezZISCLBkhkCUjhbJkpCtLOnrXnM97OwVnSRrOkgycJVk4S3JwluQ9WUJkUz2cTc/D2TQOzqax4HPTc0JZNwjMupvArJsOZt0mMOs+A7NuBJh1oxRk3SiBrBstlHWjXVnXybvmfN7bSTjrUnDWpeGsy8BZl4WzLgdnXd6TdUR2NsDZOR7Ozufh7CSz+LlCFtPZOQTMzqFgds4As/MzMDs/B7NzFJidYxRk5xiB7HxCKDufcGVnF++a83lvJ+DsTMLZmYKzMw1nZwbOziycnTk4O/Oe7CSyuBHO4glwFo+Hs/h5OIvHgc/FY4Wy/UEw24eB2T4TzPbPwWz/Asz2MWC2P6kg258UyPY/C2X7n13Z3tW75nze2y1wtifgbE/C2Z6Csz0NZ3sGzvYsnO05ONvznmwnWKEJZoWJMCtMgFlhPMwKJHuMLbAHzQpjQFZ4CmSFWSArfAGywpcgKzwJssJfFLDCXwRY4a9CrPBXFyt08645n/d2M8wKLTArJGBWSMKskIJZIQ2zQgZmhSzMCjmYFfIeViDYoxlmj0kwe0yE2WMCzB7jYfZ4Htz3GCfEMmNBlpkMssxskGW+BFnmK5Bl/gKyzN8UsMzfBFjmKSGWecrFMt29a87nvd0Es0wzzDItMMskYJZJwiyTglkmDbNMBmaZLMwyOZhl8h6WIdioBWajyTAbTYLZaCLMRhNgNiJZa1yBtWg2ehVko6kgG80B2egrkI2KjuW8/xvIRk8rYKOnBdjo70Js9HcXG+3uXXM+7+1GmI2aYDZqhtmoBWajBMxGSZiNUjAbpWE2ysBslIXZKAezUd7DRgRrJWDWmgKz1mSYtSbBrDURZq0JMGuNB/e1nhdit9kgu80D2W0uyG5Fx3Ls1gpkt6dBdvuHAnb7hwC7PSPEbs+42G0P75rzeW83wOzWCLNbE8xuzTC7tcDsloDZLQmzWwpmtzTMbhmY3bIwu+Vgdst72I1gwSTMgi/ALDgFZsHJMAtOgllwIsyCJFs+X2BLmgXrQRZMgiz4NsiCrUAWbA2y4D9AFnxWAQs+K8CCzwmx4HMuFtzTu+Z83tv1MAs2wCzYCLNgE8yCzTALtsAsmIBZMAmzYApmwTTMghmYBbMwC+ZgFsx7WJBgyxTMli/CbPkCzJZTYLacDLPlJJgtJ8JsOQHctxwvxKoLQVZdArLqOyCrtgZZtQ3Iqs+CrDpWAauOFWDVcUKsOs7Fqnt515zPe7sOZtV6mFUbYFZthFm1CWbVZphVW2BWTcCsmoRZNQWzahpm1QzMqlmYVXMwq+Y9rEqwbxpm35dg9n0RZt8XYPadArPvZJh9J8HsS7L0+AJL0+y7GmTfTSD7vguybxuQfduC7DsWZN/nFbDv8wLsO16Ifce72Lend835vLcXwOxbB7NvPcy+DTD7NsLs2wSzbzPMvi0w+yZg9k3C7JuC2TcNs28GZt8szL45mH3zHvYlWDoDs/TLMEu/BLP0izBLvwCz9BSYpSfDLD0JZumJ4L70BCE2b1XMsXlJMbd+3wPZvC3I5u1ANn8eZPMJCth8ggCbTxRi84kuNu/lXXM+7+35rVk2XwCzeR3M5vUwmzfAbN4Is3kTzObNMJu3wGyegNk8CbN5CmbzNMzmGZjNszCb52A2z3vYnGD9LMz6r8Cs/zLM+i/BrP8izPovwKw/BWb9yTDrk88OEwrPDjTrdwVZvwfI+vNA1m8Hsn57kPUngKw/iWP9sDOGBOtPEmD9yUKsP1lwH95h/fkw638As/6HMOsvgFm/Dmb9epj1G2DWb4RZvwlm/WaY9Vtg1k/ArJ+EWT8Fs34aZv0MzPokmz8Ds/mzMJs/B7P5WJjNx8Fs/jzM5uNhNp/gYXO/HDexwOZtC+NtHtcvt7YHubUY5NZJILdOAfnNGUOCW6cIcOsLQtz6guDvTjvc+gHMrR/C3LoA5tY6mFvrYW5tgLm1EebWJphbm2FubYG5NQFzaxLm1hTMrWmYWzMwt5Kc+SzMmc/BnDkW5sxxMGc+D3PmeJgzJ8CcObHAmTQXFoNcWAJy4RSQC19UwIUvCnDhS0Jc+JLg5z84XPghzIULYC6sg7mwHubCBpgLG2EubIK5sBnmwhaYCxMwFyZhLkzBXJiGuTADcyHJcc/BHDcW5rhxMMc9D3PceJjjJsAcN9HDcb73u4Q4rgTkuA4gx70IctzLCjjuZQGOe0WI414R/ExXh+MWwBxXB3NcPcxxDTDHNcIc1wRzXDPMcS0wxyVgjkvCHJeCOS4Nc1wG5jiSu8bC3DUO5q7nYe4aD3PXBJi7JsLcNanAXTQndQA5aReQk14GOelVBZz0qgAn/VOIk/4peG6Rw0l1MCfVw5zUAHNSI8xJTTAnNcOc1AJzUgLmpCTMSSmYk9IwJ2VgTiK5ZhzMNc/DXDMe5poJMNdMhLlmkodr/Ob8ZCGu2QXkmo4g17wKcs2/FHDNvwS45jUhrnlN8Kxqh2vqYa5pgLmmEeaaJphrmmGuaYG5JgFzTRLmmhTMNWmYazIw15Ac8jzMIeNhDpkAc8hEmEMmwRwyucAhNDd0BLmhE8gN/wK54fXjdn5ucDTS3PDGcTLc4Iy7mRu6eTQT3NAAc0MjzA1NMDc0w9zQAnNDAuaGJMwNKZgb0jA3ZGBuIHN+PJzzE+Ccnwjn/CQ45yd7ct73770K5XwnMOc7gznvzma/efemgpx/UyDnpwrl/FRXznf1aCZyvhHO+SY455vhnG+Bcz4B53wSzvkUnPNpOOczcM6TuTwBzuWJcC5PgnN5MpzLUwq5TOdoZzBHu4A5+iaYo9MU5Og0gRx9SyhH33LlaBePZiJHm+AcbYZztAXO0QSco0k4R1NwjqbhHM3AOUrm3kQ49ybBuTcZzr0pntzzmwMvCOVeFzD3uoK5Nw3MvekKcm+6QO7NEMq9Ga7c6+TRTOReM5x7LXDuJeDcS8K5l4JzLw3nXgbOPTKnJsE5NRnOqSlwTr1QyCk6V7qCubIrmCvTwVyZqSBXZgrkyiyhXJnlypWOHs1ErrTAuZKAcyUJ50oKzpU0nCsZOFfIHJgM58AUOAde8OSA77/nFcqBXcEc6AbmwEwwB2YryIHZAjkwRygH5rhyoINHM5EDCTgHknAOpOAcSMM5kIFzgOzbU+C+/QLct18s9G26z3YD+2x3sM/OBvvsXAV9dq5An31bqM++7eqzJR7NRJ9Nwn02BffZNNxnM3CfJfviC3BffNHTF/32iZeE+mJ3sC/uBvbFuWBffEdBX3xHoC++K9QX33X1xfZFfF9MwX0xDffFDNwXyT72ItzHXir0Mbrv7Ab2nd3BvvMO2HfeU9B33hPoO/OE+s48V99pJ9B30nDfycB9h+wTL3n6hO/PcRHqE7uDfWIPsE+8B/aJ9xX0ifcF+sR8oT4x39Un2gj0iQzcJ8h1/XJhXdPrcA9wHfYA1+H74Dr8QME6/EBgHX4otA4/3MY63I7mWHzbmr/2osexrLcDj+PfqyL2Hgi0LXhZUvSfL+pnOe9hd8/Y9D3tnDFN6ZXSmFegMadAY1aBxowCjWkFGlMKNCYVaEwo0NiiQGOzAo1NCjQ2KtDYoEBjvQKNdQo0LlCg0dkzoDQ62g4u2vKi9W5Q4OlGBRo3KdD4mQKNnyvQ+IUCjV8q0PiVAo3Of/Te2TW2UqCxtQKNbRRobKtAYzsFGtsr0FisQGOJAo0dFGjcRYHGjgo0dlKgsbMCjV0UaOyqQOOuCjR2U6CxuwKNuynQuLsCjXso0NhDgcY9FWjcS4HGvRVo7KlAYy9Qo6Otf9GWl90b3zk12r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c0/q/tjRd5LjuuHdeOa8e149px7bh2XDuuHdeOa8f9b6+tfVZMa/ZnBA/08TwU9Lw+fEfGCm77n6Xm2wecb3iHxqrd5iU1377gfPspmO8AcL7nKZjv+eB8L1Ew30vB+Q5UMN9B4HxvUjDfIeB8hyqY74PgfIcpmO8YcL5PKZjvWHC+kxXM91VwvlMVzHc2ON95CuZbD843qWC+C8H5LlEw39XgfDcpmG+rYm6+JcU7/3y7gvPt4RrL7+clfxufi7tewe/6r1Ogca0CjWsUaFytQOMqBRpXKtC4QoHG5Qo0LlOgcakCjUsUaPxUgcZPFGhcrEDjxwo0fqRA4yJQ47fB5K9Hd35P31Cg8U0FGqcq0DhNgca3FGicrkDjDAUaZyrQOEuBxtkKNM5RoHGuAo1vK9D4jgKN7yrQ+J4CjfNAjZbJv9FomZzRaJmc0WiZnNFomZzRaJmc0WiZnNFomZzRaJmc0Ugz+WaNm9l8wXFFRXWm6k01mGo01WSq2VSLqYSppKmUqbSpjKmsqZypvKmFpha5ziXHDXAO06YMcA7QdqpT0X++qJ/1bTwA2QO0GY32AG1Goz1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7TtISEBn5eURntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7gLbdGw/4vKQ02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02gO07bh2XDuuHdeOa8e149px7bh2XDuuHfe/u7b2WTGt2Z9hD9DekW/2vLYHaG/r+m7maw/Q3oFv9ry2B2hv6/pu5msP0N6Bb/a8tgdob+v6buZrD9DegW/2vLYHaG/r+m7maw/Q3oFv9ry2B2hv6/pu5msP0N6Bb/a8tgdo2wO0A/4ue4A2pNEeoM1otAdoMxrtAdqMRnuANqPRHqDNaLQHaDMa7QHajEZ7gDav0R7Wx2i0h/UxGu1hfYxGe1gfo9Ee1sdotIf1MRrtYX2MRntYH6ORPqxvsz7vRf4My/2W+ymNlvsZjZb7GY2W+xmNlvsZjZb7GY2W+xmNlvsZjZb7/+0KOgeLU3qlNNYp0FivQGODAo2NCjQ2KdDYrEBjiwKNCQUakwo0phRoTCvQmFGgMatAY06BxrwCjQsVaFwEavwWuD/YxuXDZv7/yMzhY1OLTX1i6lNTS0wtNbXM1HJTK0ytNLXK1GpTa0ytNbXO1HpTG47bcsyN5vUmU5+Z+tzUF6a+NPWVqaLjzf+vqdam2phqa6qdqfamik2VmOpgapfjvxlz83ndHc3rTqY6m+piqqupXU11M9Xd1G6mdje1h6kepvY0tZepvU31NNXL1D6m9jW1n6n9TR1g6kBTvU0dZOpgU4eYOtTUYaYON3WEqSNNHWXqaFPfM3XM8a73ir6pDjuEvfEl9H103L+P6/cPQ/oczy6mNoW5O+PeKPhefSzgRUDIi4CwF4sFvAgKeREU9uITAS9KhbwoFfbiUwEvyoS8KBP2YomAF+VCXpQLe7FUwIuQkBchYS+WCXgRFvIiLOzFcgEvIkJeRIS9WCHgRYWQFxXCXqwU8CIq5EVU2ItVAl4cK+TFscJerBbw4jghL44T9mKNgBfHC3lxvLAXawW86CvkRV9hL9YJeHGCkBcnCHuxXsCLE4W8OFHYiw0CXlQKeeGM26UwbmtY8/zW33hBeev8UohTtLd39N359wc7Hs/P+86+MveUM24rwfXVScCLu4S8uEvYi84CXtwt5MXdwl50EfDiHiEv7hH2oquAF/cKeXGvsBe7CngxVMiLocJedBPw4j4hL+4T9qK7gBf3C3lxv7AXuwl48YCQFw8Ie7G7gBe/F/Li98Je7CHgxR+EvPiDsBc9BLz4o5AXfxT2Yk8BLx4U8uJBYS/2EvDiT0Je/EnYi70FvHhIyIuHhL3oKeDFw0JePCzsRS8BLx4R8uIRYS/2EfDiUSEvHhX2Yl8BLx4T8uIxYS/2E/BimJAXw4S92F/Ai8eFvHhc2IsDBLwYLuTFcGEvDhTwYoSQFyOEvegt4MVIIS9GCntxkIAXo4S8GCXsxcECXowW8mK0sBeHCHgxRsiLMcJeHCrgxRNCXjwh7MVhAl48KeTFk8JeHC7gxZ+FvPizsBdHCHjxFyEv/iLsxZECXvxVyIu/CntxlIAXfxPy4m/CXhwt4MVTQl485fLC+/tNwXBtOFxVFaqpigZCkUh5KBoLhSLhitIyIz0Ui4YiZYFIRVlNKFRbHauKVQRroqXRWKSqKlxaFg2GwwvbffN3e/83XjRcEy+L1QTCVcHyiupQKF5RFY+Xx0PxSI2xpKwmGCiLBALVpWXVNVVm/NJwubEgGC2P1sTC8Wi188GOTrXz6vQ57hYHVVdUR2rLgrG4mWo4HgpXRGPVsdKw+QnlpRXlNfFYaSBaW1FRXlsbjMTDgbKqUChQUVoer42GzY+MlbsPqvbr3458oE35dv694/Hcvfg0dy8Gpdbg0335Nfh3oTXojHtLYdw28BrMe9cgsKY/dt+XpZFIJFoaKY0FA7XB8mCgPBYySyFcVh2pqIrFqiLRmtLaSKzG/C9YUx0ImvVlFlQ0XlVWXVFTUxZy1rPzYajF8JruA67pMLim3R8A9d/ej/Gvj/GLBTsez/WHTsdz3rv7g98194++mPcRqV7zD4Fe84xQr3nG1Wvawb0mB/eavKfXEL1rMdy73B+S7HfdvCHUC/uCvbAf2AvrwV7YCeyFncFe+A+wFz6roBc+K9ALnxPqhc+5emH7IrYXZuFemIN7Yd7TC4ne+gncW7f4cHef471R6NV0bx0A9tbzwN7aAPbWzmBv7QL21mfB3jpWQW8dK9Bbxwn11nGu3lriXXM+7+0M3FuzcG/Nwb017+mtRK/+FO7V0+BePRXk6jeFev/5YO+/BOz9jWDv7wL2/q5g7x8L9v7nFfT+5wV6/3ih3j/e1fs7eNecz3s7Dff+DNz7s3Dvz8G9P+/p/USWLIGz5C04S8hserOQTXSWXApmyUAwS5rALOkKZsmuYJY8D2bJBAVZMkEgSyYKZclEV5Z09K45n/d2Cs6SNJwlGThLsnCW5OAsyXuyhMimpXA2TYez6S04m6aBz01ThbJuEJh1N4FZ1wxm3a5g1nUDs24CmHWTFGTdJIGsmyyUdZNdWdfJu+Z83ttJOOtScNal4azLwFmXhbMuB2dd3pN1RHYug7NzBpyd0+HsJLN4aiGL6ewcAmbnUDA7W8Ds7AZmZ3cwOyeB2TlFQXZOEcjOF4Sy8wVXdnbxrjmf93YCzs4knJ0pODvTcHZm4OzMwtmZg7Mz78lOIouXw1k8E87iGXAWT4ez+C3wuXiaULY/CGb7MDDbE2C2dwezfTcw26eA2f6igmx/USDbXxLK9pdc2d7Vu+b8ciuc7Qk425NwtqfgbE/D2Z6Bsz0LZ3sOzva8J9sJVlgBs8IsmBVmwqwwA2YFkj2mFdiDZoUxICs8BbJCEmSF3UBW2B1khRdBVnhZASu8LMAKrwixwisuVujmXXN+//sQzAotMCskYFZIwqyQglkhDbNCBmaFLMwKOZgV8h5WINhjJcwes2H2mAWzx0yYPWbA7DEd3Pd4S4hlxoIsMxlkmRTIMruDLLMHyDIvgyzzqgKWeVWAZf4pxDL/dLFMd++a8/t7nTDLNMMs0wKzTAJmmSTMMimYZdIwy2RglsnCLJODWSbvYRmCjVbBbDQHZqPZMBvNgtloJsxGJGu9VWAtmo1eBdloKshGaZCN9gDZqAfIRq+CbPQvBWz0LwE2ek2IjV5zsdHu3jXn9+8nYTZqgtmoGWajFpiNEjAbJWE2SsFslIbZKAOzURZmoxzMRnkPGxGstRpmrbkwa82BWWs2zFqzYNaaCbPWDHBfa7oQu80G2W0eyG4ZkN16gOy2J8hu/wLZ7XUF7Pa6ALu9IcRub7jYbQ/vmvP7uUcwuzXC7NYEs1szzG4tMLslYHZLwuyWgtktDbNbBma3LMxuOZjd8h52I1hwDcyCb8MsOBdmwTkwC86GWXAWzIIkW04vsCXNgvUgCyZBFsyCLLgnyIJ7gSz4OsiCbypgwTcFWHCqEAtOdbHgnt415/fzhWEWbIBZsBFmwSaYBZthFmyBWTABs2ASZsEUzIJpmAUzMAtmYRbMwSyY97AgwZZrYbZ8B2bLt2G2nAuz5RyYLWfDbDkLZsuZ4L7lDCFWXQiy6hKQVXMgq+4FsureIKu+CbLqNAWsOk2AVd8SYtW3XKy6l3fN+by362BWrYdZtQFm1UaYVZtgVm2GWbUFZtUEzKpJmFVTMKumYVbNwKyahVk1B7Nq3sOqBPuug9n3XZh934HZ922YfefC7DsHZt/ZMPuSLD2jwNI0+64G2XcTyL55kH33Btm3J8i+00D2na6AfacLsO8MIfad4WLfnt415/PeXgCzbx3MvvUw+zbA7NsIs28TzL7NMPu2wOybgNk3CbNvCmbfNMy+GZh9szD75mD2zXvYl2Dp9TBLvwez9LswS78Ds/TbMEvPhVl6DszSs2GWngXuS88UYvNWxRyblxSD6xdk854gm/cC2Xw6yOYzFbD5TAE2nyXE5rNcbN7Lu+Z83tvzW7NsvgBm8zqYzethNm+A2bwRZvMmmM2bYTZvgdk8AbN5EmbzFMzmaZjNMzCbZ2E2z8FsnvewOcH6G2DWnwez/nsw678Ls/47MOu/DbP+XJj158CsTz47zCw8O9Cs3xVk/R4g6y8CWb8XyPr7gKw/E2T92Rzrh50xJFh/tgDrzxFi/TmC+/AO638Ms/5imPU/gVn/U5j1l8CsvxRm/WUw6y+HWX8FzPorYdZfBbP+apj118CsvxZm/XUw66+HWZ9k8zdgNn8TZvOpMJtPg9n8LZjNp8NsPgNm85keNvfLcbMKbN62MN7mcf1y6z4gt+4LcutskFvngvzmjCHBrXMFuPVtIW59W/B3px1uXQxz6ycwt34Kc+sSmFuXwty6DObW5TC3roC5dSXMratgbl0Nc+samFvXwty6DubW9TC3kpz5JsyZU2HOnAZz5lswZ06HOXMGzJkzYc6cVeBMmgv3BblwP5AL54Jc+I4CLnxHgAvfFeLCdwU//8Hhwk9gLvwU5sIlMBcuhblwGcyFy2EuXAFz4UqYC1fBXLga5sI1MBeuhblwHcyF62EuJDluKsxx02COewvmuOkwx82AOW4mzHGzPBzne79LiOP2Azluf5Dj3gE57j0FHPeeAMfNE+K4eYKf6epw3Kcwxy2BOW4pzHHLYI5bDnPcCpjjVsIctwrmuNUwx62BOW4tzHHrYI5bD3McyV3TYO56C+au6TB3zYC5aybMXbNg7ppd4C6ak/YHOekAkJPeAznpfQWc9L4AJ80X4qT5gucWOZy0BOakpTAnLYM5aTnMSStgTloJc9IqmJNWw5y0BuaktTAnrYM5aT3MSSTXvAVzzXSYa2bAXDMT5ppZMNfM9nCN35yfI8Q1B4BccyDINe+DXPOBAq75QIBrPhTimg8Fz6p2uGYpzDXLYK5ZDnPNCphrVsJcswrmmtUw16yBuWYtzDXrYK5ZD3MNySHTYQ6ZAXPITJhDZsEcMhvmkDkFDqG54UCQG3qD3PAByA0LFHDDAgFuqBPihjoXN3TzaCa4YRnMDcthblgBc8NKmBtWwdywGuaGNTA3rIW5YR3MDethbiBzfgac8zPhnJ8F5/xsOOfneHLe9++9CuV8bzDnDwJzfgGY8/UKcr5eIOcbhHK+wZXzXT2aiZxfDuf8CjjnV8I5vwrO+dVwzq+Bc34tnPPr4JxfD+c8mcsz4VyeBefybDiX58C5PLeQy3SOHgTm6MFgjtaDOdqoIEcbBXK0SShHm1w52sWjmcjRFXCOroRzdBWco6vhHF0D5+haOEfXwTm6Hs5RMvdmwbk3G869OXDuzfXknt8ceFso9w4Gc+8QMPcawdxrVpB7zQK51yKUey2u3Ovk0Uzk3ko491bBubcazr01cO6thXNvHZx76+HcI3NqNpxTc+Ccmgvn1NuFnKJz5RAwVw4Fc6UZzJWEglxJCORKUihXkq5c6ejRTOTKKjhXVsO5sgbOlbVwrqyDc2U9nCtkDsyBc2AunANve3LA99/zCuXAoWAOHAbmQALMgZSCHEgJ5EBaKAfSrhzo4NFM5MBqOAfWwDmwFs6BdXAOrIdzgOzbc+G+/Tbct98p9G26zx4G9tnDwT6bAvtsRkGfzQj02axQn826+myJRzPRZ9fAfXYt3GfXwX12Pdxnyb74NtwX3/H0Rb994l2hvng42BePAPtiBuyLOQV9MSfQF/NCfTHv6ovti/i+uBbui+vgvrge7otkH3sH7mPvFvoY3XeOAPvOkWDfyYF9Z6GCvrNQoO8sEuo7i1x9p51A31kH9531cN8h+8S7nj7h+3NchPrEkWCfOArsEwvBPvGRgj7xkUCf+FioT3zs6hNtBPrEerhPkOv6vcK6ptfhUeA6PBpchx+B63CxgnW4WGAdfiK0Dj/ZxjrcjuZYfNuav/bi6ONZb+/oy79XRew9EGhb8LKk6D9f1M9y3sPunrHpe9o5Y5rSK6Uxr0BjToHGrAKNGQUa0wo0phRoTCrQmFCgsUWBxmYFGpsUaGxUoLFBgcZ6BRrrFGhcoECjs2dAaXS0HVy05UXr3aDA040KNG5SoPEzBRo/V6DxCwUav1Sg8SsFGp3/6L2za2ylQGNrBRrbKNDYVoHGdgo0tlegsViBxhIFGjso0LiLAo0dFWjspEBjZwUauyjQ2FWBxl0VaOymQGN3BRp3U6BxdwUa91CgsYcCjXsq0LiXAo17K9DYU4HGXqBGR1v/oi0vuze+c2q0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmj8X9sbL/Jcdlw7rh3XjmvHtePace24dlw7rh3XjvvfXlv7rJjW7M8IHujjeSjoeX34jowV3PY/S823Dzjf8A6NVbvNS2q+fcH59lMw3wHgfM9TMN/zwfleomC+l4LzHahgvoPA+d6kYL5DwPkOVTDfB8H5DlMw3zHgfJ9SMN+x4HwnK5jvq+B8pyqY72xwvvMUzLcenG9SwXwXgvNdomC+q8H5blIw31bF3HxLinf++XYF59vDNZbfz0v+Nj4Xd72C3/Vfp0DjWgUa1yjQuFqBxlUKNK5UoHGFAo3LFWhcpkDjUgUalyjQ+KkCjZ8o0LhYgcaPFWj8SIHGRaDGb4PJFxy383tap0BjvQKNDQo0NirQ2KRAY7MCjS0KNCYUaEwq0JhSoDGtQGNGgcasAo05BRrzCjQuVKBxEajRMvk3Gi2TMxotkzMaLZMzGi2TMxotkzMaLZMzGi2TMxotkzMaaSbfrHEzm3/at6hoiamlppaZWm5qhamVplaZWm1qjam1ptaZWm9qg6mNpjaZ+szU565zyXEDnMO0KQOcA7Sd6lT0ny/qZ30bD0D2AG1Goz1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7QZjfYAbXtISMDnJaXRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R6gbffGAz4vKY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY32AG07rh3XjmvHtePace24dlw7rh3XjmvH/e+urX1WTGv2Z9gDtHfkmz2v7QHa27q+m/naA7R34Js9r+0B2tu6vpv52gO0d+CbPa/tAdrbur6b+doDtHfgmz2v7QHa27q+m/naA7R34Js9r+0B2tu6vpv52gO0d+CbPa/tAdr2AO2Av8seoA1ptAdoMxrtAdqMRnuANqPRHqDNaLQHaDMa7QHajEZ7gDaj0R6gLfCZzfawPkSjPayP0WgP62M02sP6GI32sD5Goz2sj9FoD+tjNNrD+hiN9GF9m/V5L/JnWO633E9ptNzPaLTcz2i03M9otNzPaLTcz2i03M9otNzPaLTc/29X0DlYnNIrpXGJAo1LFWhcpkDjcgUaVyjQuFKBxlUKNK5WoHGNAo1rFWhcp0DjegUaNyjQuFGBxk0KNH6mQOPnoMZvgfuDbVw+bOb/L8wcvjT1lamiE8y/mWptqo2ptqbamWpvqthUiakOpnYx1dFUJ1OdTXU5Ycsxu5rXu5rqZqq7qd1M7W5qD1M9TO1pai9Te5vqaaqXqX1M7WtqP1P7mzqgMObm87oPNK97mzrI1MGmDjF1qKnDTB1u6ghTR5o6ytTRpr5n6hhTfUwFTAVNlZoqM1VuKmQqbCpiqsJU1NSxpo4zdbypvqZOMHWiqUpTJ5k62dQppvqd4Hqv6JvqsEPYG19Cn3PTeMf1+4chp57ALqY2hbk7494o+F59KeDFaUJenCbsxVcCXpwu5MXpwl4UncB70V/Ii/7CXrQS8OIMIS/OEPaitYAXZwp5caawF20EvBgg5MUAYS/aCnhxlpAXZwl70U7Ai7OFvDhb2Iv2Al6cI+TFOcJeFAt4ca6QF+cKe1Ei4MX3hbz4vrAXHQS8+IGQFz8Q9mIXAS/OE/LiPGEvOgp48UMhL34o7EUnAS9+JOTFj4S96CzgxY+FvPixsBddBLz4iZAXzrhdCuO2hjXPb/2NF5S3zi+FOEV7O/zEnX9/8ECBe2rEiTL3lDNuK8H11VvAi5FCXowU9uIgAS9GCXkxStiLgwW8GC3kxWhhLw4R8GKMkBdjhL04VMCLJ4S8eELYi8MEvHhSyIsnhb04XMCLPwt58WdhL44Q8OIvQl78RdiLIwW8+KuQF38V9uIoAS/+JuTF34S9OFrAi6eEvHhK2IvvCXjxtJAXTwt7cYyAF38X8uLvwl70EfDiH0Je/EPYi4CAF88IefGMsBdBAS+eFfLiWWEvSgW8eE7Ii+eEvSgT8GKskBdjhb0oF/BinJAX44S9CAl48byQF88LexEW8GK8kBfjhb2ICHgxQciLCcJeVAh4MVHIi4nCXkQFvJgk5MUkYS+OFfBispAXk4W9OE7AiylCXkwR9uJ4AS9eEPLiBWEv+gp48aKQFy8Ke3GCgBcvCXnxkrAXJwp48bKQFy8Le1Ep4MUrQl68IuzFSQJevCrkxavCXpws4MU/hbz4p8sL7+83BcO14XBVVaimKhoIRSLloWgsFIqEK0rLjPRQLBqKlAUiFWU1oVBtdawqVhGsiZZGY5GqqnBpWTQYDi9s983f7f3feNFwTbwsVhMIVwXLK6pDoXhFVTxeHg/FIzXGkrKaYKAsEghUl5ZV11SZ8UvD5caCYLQ8WhMLx6PVzgc7OtXOq9PnuFscVF1RHaktC8biZqrheChcEY1Vx0rD5ieUl1aU18RjpYFobUVFeW1tMBIPB8qqQqFARWl5vDYaNj8yVu4+qNqvfzvygTbl2/n3A0/g7sV/cfdiUGoN/utEfg2+JrQGnXFvKYzbBl6Dee8aBNb0l+77sjQSiURLI6WxYKA2WB4MlMdCZimEy6ojFVWxWFUkWlNaG4nVmP8Fa6oDQbO+zIKKxqvKqitqaspCznp2Pgy1GF7TfcA1HQbXtPsDoP7b+zH+9TF+seCBJ3D9ofcJnPfu/uB3zb1+IuZ9RKrXvC7Qa94Q6jVvuHpNO7jX5OBek/f0GqJ3fQX3LveHJPtdN3VCvbAv2Av7gb1wKdgLe4O98CCwF74O9sI3FfTCNwV64VShXjjV1QvbF7G9MAv3whzcC/OeXkj01qIT2N66xYe7+xyvrtCr6d46AOyt54G9dRnYWw8Ce+vBYG99E+yt0xT01mkCvfUtod76lqu3lnjXnM97OwP31izcW3Nwb817eivRq1vBvboR7tUNIFfXC/X+88HefwnY+5eDvf9gsPcfAvb+aWDvn66g908X6P0zhHr/DFfv7+Bdcz7v7TTc+zNw78/CvT8H9/68p/cTWdIazpImOEvIbKovZBOdJZeCWTIQzJIVYJYcAmbJoWCWTAezZKaCLJkpkCWzhLJklitLOnrXnM97OwVnSRrOkgycJVk4S3JwluQ9WUJkUxs4m5rhbGqCs6kRfG5qEMq6QWDW3QRm3Uow6w4Fs+4wMOtmglk3W0HWzRbIujlCWTfHlXWdvGvO572dhLMuBWddGs66DJx1WTjrcnDW5T1ZR2RnWzg7W+DsbIazk8zihkIW09k5BMzOoWB2rgKz8zAwOw8Hs3M2mJ1zFWTnXIHsfFsoO992ZWcX75rzeW8n4OxMwtmZgrMzDWdnBs7OLJydOTg7857sJLK4HZzFCTiLW+AsboazuAl8Lm4UyvYHwWwfBmb7ajDbDwez/Qgw2+eC2f6Ogmx/RyDb3xXK9ndd2d7Vu+Z83tstcLYn4GxPwtmegrM9DWd7Bs72LJztOTjb855sJ1ihPcwKSZgVEjArtMCsQLJHY4E9aFYYA7LCUyArrAFZ4QiQFY4EWeEdkBXeU8AK7wmwwjwhVpjnYoVu3jXn895uhlmhBWaFBMwKSZgVUjArpGFWyMCskIVZIQezQt7DCgR7FMPskYLZIwmzRwJmjxaYPZrBfY8mIZYZC7LMZJBl1oIscyTIMkeBLPMeyDLvK2CZ9wVYZr4Qy8x3sUx375rzeW83wSzTDLNMC8wyCZhlkjDLpGCWScMsk4FZJguzTA5mmbyHZQg2KoHZKA2zUQpmoyTMRgmYjUjWaiqwFs1Gr4JsNBVko3UgGx0FstHRIBu9D7LRBwrY6AMBNvpQiI0+dLHR7t415/PebmzHspHDWl/CrPUVzFokGzms1QpmrdYwa7WBWastzFrtYNZqD7NWMcxaJTBrdYBZKwOzVhpmrRTMWkmYtRIwa7WA+1rNQuw2G2S3eSC7rQfZ7WiQ3b4HstsHILstUMBuCwTYrU6I3epc7LaHd835vLcbYHZrhNmtCWa3ZpjdWmB2S8DsloTZLQWzWxpmtwzMblmY3XIwu+U97Eaw4C4wC2ZhFszALJiGWTAFs2ASZkGSLZsLbEmzYD3IgkmQBTeALPg9kAWPAVlwAciC9QpYsF6ABRuEWLDBxYJ7etecz3u7HmbBBpgFG2EWbIJZsBlmwRaYBRMwCyZhFkzBLJiGWTADs2AWZsEczIJ5DwsSbNkRZssczJZZmC0zMFumYbZMwWyZhNkyAe5btgix6kKQVZeArLoRZNVjQFbtA7JqPciqjQpYtVGAVZuEWLXJxap7edecz3u7DmbVephVG2BWbYRZtQlm1WaYVVtgVk3ArJqEWTUFs2oaZtUMzKpZmFVzMKvmPaxKsG8nmH3zMPvmYPbNwuybgdk3DbNvCmZfkqVbCixNs+9qkH03gey7CWTfPiD7BkD2bQTZt1kB+zYLsG+LEPu2uNi3p3fN+by3F8DsWwezbz3Mvg0w+zbC7NsEs28zzL4tMPsmYPZNwuybgtk3DbNvBmbfLMy+OZh98x72JVi6M8zSC2GWzsMsnYNZOguzdAZm6TTM0imYpZPgvnRCiM1bFXNsXlLMrd/PQDYPgGweBNm8GWTzhAI2TwiweVKIzZMuNu/lXXM+7+35rVk2XwCzeR3M5vUwmzfAbN4Is3kTzObNMJu3wGyegNk8CbN5CmbzNMzmGZjNszCb52A2z3vYnGD9LjDrL4JZfyHM+nmY9XMw62dh1s/ArJ+GWZ98dkgUnh1o1u8Ksn4PkPU/B1k/CLJ+Kcj6CZD1Uxzrh50xJFg/JcD6aSHWTwvuwzus/yXM+l/BrE+yeT3M5g0wmzfCbN4Es3kzzOYtMJsnYDZPwmyegtk8DbN5BmbzLMzmOZjN8zCb18FsXg+zeQPM5o0wmzfBbN4Ms3kLzOYJD5v75bhkgc3bFsbbPK5fbi0FubUM5NYUyK0ZkN+cMSS4NSPArVkhbs0K/u60w61fwdxKcmYdzJn1MGc2wJzZCHNmE8yZzTBntsCcmYA5MwlzZgrmzDTMmRmYM7MwZ+ZgzqyHObMB5sxGmDObYM5shjmzBebMBMyZyQJn0lxYBnJhOciFGZALcwq4MCfAhXkhLswLfv6Dw4Ukxy2AOa4O5rh6mOMaYI5rhDmuCea4ZpjjWmCOS8Acl4Q5LgVzXBrmuAzMcVmY4xpgjmuEOa4J5rhmmONaYI5LwByX9HCc7/0uIY4rBzkuBHJcDuS4hQo4bqEAxy0S4rhFgp/p6nBcK5jjWsMc1wbmuLYwx7WDOa49zHHFMMeVwBzXAea4XWCO6whzXCeY4zrDHEdyVyPMXU0wdzXD3NUCc1cC5q4kzF2pAnfRnBQCOSkMctJCkJM+UsBJHwlw0sdCnPSx4LlFDie1hjmpDcxJbWFOagdzUnuYk4phTiqBOakDzEm7wJzUEeakTjAndYY5ieSaJphrmmGuaYG5JgFzTRLmmpSHa/zmfFqIa8Ig10RArvkI5JrFCrhmsQDXfCLENZ8InlXtcE0bmGvawlzTDuaa9jDXFMNcUwJzTQeYa3aBuaYjzDWdYK7pDHMNySHNMIe0wBySgDkkCXNICuaQdIFDaG6IgNxQAXLDYpAbPlXADZ8KcMMSIW5Y4uKGbh7NBDe0hbmhHcwN7WFuKIa5oQTmhg4wN+wCc0NHmBs6wdzQGeYGMudb4JxPwDmfhHM+Bed82pPzvn/vVSjnK8Ccj4I5/ymY80sV5PxSgZxfJpTzy1w539Wjmcj5dnDOt4dzvhjO+RI45zvAOb8LnPMd4ZzvBOd8ZzjnyVxOwLmchHM5BedyGs7lTCGX6RyNgjl6LJijS8EcXa4gR5cL5OgKoRxd4crRLh7NRI62h3O0GM7REjhHO8A5ugucox3hHO0E52hnOEfJ3EvCuZeCcy8N517Gk3t+cyArlHvHgrl3HJh7y8HcW6kg91YK5N4qodxb5cq9Th7NRO4Vw7lXAudeBzj3doFzryOce53g3OsM5x6ZUyk4p9JwTmXgnMoWcorOlePAXDkezJWVYK6sVpArqwVyZY1Qrqxx5UpHj2YiV0rgXOkA58oucK50hHOlE5wrneFcIXMgDedABs6BrCcHfP89r1AOHA/mQF8wB1aDObBWQQ6sFciBdUI5sM6VAx08mokc6ADnwC5wDnSEc6ATnAOd4Rwg+3YG7ttZuG/nCn2b7rN9wT57Athn14J9dr2CPrteoM9uEOqzG1x9tsSjmeizu8B9tiPcZzvBfbYz3GfJvpiF+2LO0xf99om8UF88AeyLJ4J9cT3YFzcq6IsbBfriJqG+uMnVF9sX8X2xI9wXO8F9sTPcF8k+loP7WL7Qx+i+cyLYdyrBvrMR7DufKeg7nwn0nc+F+s7nrr7TTqDvdIL7Tme475B9Iu/pE74/x0WoT1SCfeIksE98BvaJLxT0iS8E+sSXQn3iS1efaCPQJzrDfYJc1wsL65pehyeB6/BkcB1+Aa7DrxSsw68E1qEzkMQ6dAb9T+twO5pj8W1r/tqLk09gvR1+Iv9eFbH3QKBtwcuSov98UT/LeQ+7e8am72nnjGlKr5TGvAKNOQUaswo0ZhRoTCvQmFKgMalAY0KBxhYFGpsVaGxSoLFRgcYGBRrrFWisU6BxgQKNzp4BpdHRdnDRlhetd4MCTzcq0LhJgcbPFGj8XIHGLxRo/FKBxq8UaHT+o/fOrrGVAo2tFWhso0BjWwUa2ynQ2F6BxmIFGksUaOygQOMuCjR2VKCxkwKNnRVo7KJAY1cFGndVoLGbAo3dFWjcTYHG3RVo3EOBxh4KNO6pQONeCjTurUBjTwUae4EaHW39i7a87N74zqnR7o0zGu3eOKPR7o0zGu3eOKPR7o0zGu3eOKPR7o0zGu3eOKPR7o0zGu3eOKPR7o0zGu3eOKPR7o0zGu3eOKPR7o0zGu3eOKPxf21vvMhz2XHtuHZcO64d145rx7Xj2nHtuHZcO+5/e23ts2Jasz8jeKCP56Gg5/XhOzJWcNv/LDXfPuB8wzs0Vu02L6n59gXn20/BfAeA8z1PwXzPB+d7iYL5XgrOd6CC+Q4C53uTgvkOAec7VMF8HwTnO0zBfMeA831KwXzHgvOdrGC+r4LznapgvrPB+c5TMN96cL5JBfNdCM53iYL5rgbnu0nBfFsVc/MtKd7559sVnG8P11h+Py/52/hc3PUKftd/nQKNaxVoXKNA42oFGlcp0LhSgcYVCjQuV6BxmQKNSxVoXKJA46cKNH6iQONiBRo/VqDxIwUaF4Eavw0m/7Svgl6pQONSBRqXKdC4XIHGFQo0rlSgcZUCjasVaFyjQONaBRrXKdC4XoHGDQo0blSgcZMCjZ8p0Pg5qNEy+TcaLZMzGi2TMxotkzMaLZMzGi2TMxotkzMaLZMzGi2TMxppJt+scTObtzKDtzbVxlRbU+1MtTdVbKrEVAdTu5jqaKqTqc6mupjqampXU91Mda/8f/PGDXAO06YMcA7QdqpT0X++qJ/1bTwA2QO0GY32AG1Goz1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7TtISEBn5eURntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7gLbdGw/4vKQ02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02r1xRqPdG2c02gO07bh2XDuuHdeOa8e149px7bh2XDuuHfe/u7b2WTGt2Z9hD9DekW/2vLYHaG/r+m7maw/Q3oFv9ry2B2hv6/pu5msP0N6Bb/a8tgdob+v6buZrD9DegW/2vLYHaG/r+m7maw/Q3oFv9ry2B2hv6/pu5msP0N6Bb/a8tgdo2wO0A/4ue4A2pNEeoM1otAdoMxrtAdqMRnuANqPRHqDNaLQHaDMa7QHajEZ7gLZAr7SH9SEa7WF9jEZ7WB+j0R7Wx2i0h/UxGu1hfYxGe1gfo9Ee1sdopA/r26zPe5E/w3K/5X5Ko+V+RqPlfkaj5X5Go+V+RqPlfkaj5X5Go+V+RqPl/n+7gs7B4pReKY2tFWhso0BjWwUa2ynQ2F6BxmIFGksUaOygQOMuCjR2VKCxkwKNnRVo7KJAY1cFGndVoLGbAo3dQY3fAvcH27h82Mz/u5nBdze1h6kepvY0tZepvU31NNXL1D6m9jW1n6n9TR1g6kBTvU0dZOrgyi3HPMS8PtTUYaYON3WEqSNNHWXqaFPfM3WMqT6mAqaCpkpNlZkqNxUyFS6Mufm87oh5XWEqaupYU8eZOt5UX1MnmDrReS9MnWTqZFOnmOpn6lRTp5k63VR/U2eYOtPUAFNnmTrb1DmmzjX1fVM/MHWeqR+a+pGpH5v6iamfmvqZqfNN/bzS9V7RN9Vhh7A3voS+3Sr/fVy/fxhyQSW7mNoU5u6Me6Pge7W7gBe/EPLiF8Je7CHgxYVCXlwo7EUPAS8uEvLiImEv9hTw4mIhLy4W9mIvAS8uEfLiEmEv9hbwokrIiyphL3oKeFEt5EW1sBe9BLyICXkRE/ZiHwEvaoS8qBH2Yl8BL+JCXsSFvdhPwItaIS9qhb3YX8CLS4W8uFTYiwMEvPilkBe/FPbiQAEvLhPy4jJhL3oLeHG5kBeXC3txkIAXVwh5cYWwFwcLeHGlkBfOuF0K47aGNc9v/Y0XlLfOL4U4RXs7/qSdf38wInBPTThJ5p5yxm0luL4qBLyYKOTFRGEvogJeTBLyYpKwF8cKeDFZyIvJwl4cJ+DFFCEvpgh7cbyAFy8IefGCsBd9Bbx4UciLF4W9OEHAi5eEvHhJ2IsTBbx4WciLl4W9qBTw4hUhL14R9uIkAS9eFfLiVWEvThbw4p9CXvxT2ItTBLz4l5AX/xL2op+AF68JefGasBenCnjxupAXrwt7cZqAF28IefGGsBenC3jxppAXbwp70V/Ai6lCXkwV9uIMAS+mCXkxTdiLMwW8eEvIi7eEvRgg4MV0IS+mC3txloAXM4S8mCHsxdkCXswU8mKmsBfnCHgxS8iLWcJenCvgxWwhL2YLe/F9AS/mCHkxR9iLHwh4MVfIi7nCXpwn4MXbQl68LezFDwW8eEfIi3eEvfiRgBfvCnnxrrAXPxbw4j0hL94T9uInAl7ME/JinrAXPxXw4n0hL94X9uJnAl7MF/JivssL7+83BcO14XBVVaimKhoIRSLloWgsFIqEK0rLjPRQLBqKlAUiFWU1oVBtdawqVhGsiZZGY5GqqnBpWTQYDi9s983f7f3feNFwTbwsVhMIVwXLK6pDoXhFVTxeHg/FIzXGkrKaYKAsEghUl5ZV11SZ8UvD5caCYLQ8WhMLx6PVzgc7OtXOq9PnuFscVF1RHaktC8biZqrheChcEY1Vx0rD5ieUl1aU18RjpYFobUVFeW1tMBIPB8qqQqFARWl5vDYaNj8yVu4+qNqvfzvygTbl2/n3SCV3L37A3YtBqTX4wUn8GvxQaA06495SGLcNvAbz3jUIrOnd3fdlaSQSiZZGSmPBQG2wPBgoj4XMUgiXVUcqqmKxqki0prQ2Eqsx/wvWVAeCZn2ZBRWNV5VVV9TUlIWc9ex8GGoxvKb7gGs6DK7p1sA6jH99jF8s6F7T27vfttcfKio57939we+aW3AS5n1EqtcsEOg1dUK9ps7Va9rBvSYH95q8p9cQvWuPSrZ3uT8k2e+6WSLUC/uCvbAf2AvbVHK90N2/trcettcLo5Wc9wvAXlivoBfWC/TCBqFe2ODqhe29a87nvZ2Fe2EO7oV5Ty8kemuPSra3bvHh7j7HW1Lo1XRvHQD21vPA3ur+gEy/vdXdD7e3vrbXW4+t5LyvB3tro4Le2ijQW5uEemuTq7eWeNecz3s7A/fWLNxbc3BvzXt6K9Gr96xke/VyuFcvA7l6qVDvPx/s/ZeAvd/9wcN+e7+7X29v/W+v9x9XyXnfCPb+ZgW9v1mg97cI9f4WV+/v4F1zPu/tNNz7M3Dvz8K9Pwf3/ryn9xNZslclmyUr4Cwhs2lpIZvoLLkUzJKBYJa4PyDeb5a4+//2+sn2suT4Ss77ZjBLEgqyJCGQJUmhLEm6sqSjd835vLdTcJak4SzJwFmShbMkB2dJ3pMlRDbtXclm00o4m1bA2bQcfG5aJpR1g8CsuwnMOvdBI36zzp1P2+t328u6vpWc9wkw61IKsi4lkHVpoaxLu7Kuk3fN+by3k3DWpeCsS8NZl4GzLgtnXQ7Ourwn64js7FnJZucqODtXwtlJZvGyQhbT2TkEzM6hYHa6D8Dym53uvNte/9xedp5QyXmfArMzoyA7MwLZmRXKzqwrO7t415zPezsBZ2cSzs4UnJ1pODszcHZm4ezMwdmZ92QnkcW9KtksXg1n8So4i1fCWbwCfC5eLpTtD4LZPgzMdvfBkX6z3Z3H2+vv28v2Eys57zNgtucUZHtOINvzQtmed2V7V++a83lvt8DZnoCzPQlnewrO9jSc7Rk427NwtufgbM97sp1ghX0qWVZYA7PCapgVVsGsQLLH8gJ70KwwBmSFp0BWcB/g7JcV3Pm+vbzYHitUVnLe50BWWKiAFRYKsMIiIVZY5GKFbt415/PeboZZoQVmhQTMCkmYFVIwK6RhVsjArJCFWSEHs0LewwoEe+xbybLHWpg91sDssRpmj1Uwe6wE9z1WCLHMWJBlJoMs07GSYxk3f2wvz7bHMidVct4vBFnmIwUs85EAy3wsxDIfu1imu3fN+by3m2CWaYZZpgVmmQTMMkmYZVIwy6RhlsnALJOFWSYHs0zewzIEG+1XybLROpiN1sJstAZmo9UwG5GstaLAWjQbvQqy0VSQjTpVcmzk5pnt5eP22OjkSs77j0A2WqyAjRYLsNEnQmz0iYuNdveuOZ/3diPMRk0wGzXDbNQCs1ECZqMkzEYpmI3SMBtlYDbKwmyUg9ko72EjgrX2r2RZaz3MWutg1loLs9YamLVWw6y1CtzXWinEbrNBdpsHslvnSo7dTq7k2O2USs77xSC7faqA3T4VYLclQuy2xMVue3jXnM97uwFmt0aY3ZpgdmuG2a0FZrcEzG5JmN1SMLulYXbLwOyWhdktB7Nb3sNuBAseUMmy4AaYBdfDLLgOZsG1MAuugVmQZMuVBbakWbAeZMEkyIJdKjkWdPPb9nhgeyzYr5Lz/lOQBZcqYMGlAiy4TIgFl7lYcE/vmvN5b9fDLNgAs2AjzIJNMAs2wyzYArNgAmbBJMyCKZgF0zALZmAWzMIsmINZMO9hQYItD6xk2XIjzJYbYLZcD7PlOpgt18JsuQZmy9XgvuUqIVZdCLLqEpBVu1ZyrOrmy+3xyvZY9dRKzvulIKsuV8CqywVYdYUQq65wsepe3jXn896ug1m1HmbVBphVG2FWbYJZtRlm1RaYVRMwqyZhVk3BrJqGWTUDs2oWZtUczKp5D6sS7Nu7kmXfTTD7boTZdwPMvuth9l0Hs+9amH1Jll5VYGmafVeD7LsJZN9dKzn2dfPq9vhne+x7WiXn/XKQfVcqYN+VAuy7Soh9V7nYt6d3zfm8txfA7FsHs289zL4NMPs2wuzbBLNvM8y+LTD7JmD2TcLsm4LZNw2zbwZm3yzMvjmYffMe9iVY+qBKlqU/g1l6E8zSG2GW3gCz9HqYpdfBLL0WZuk14L70aiE2b1XMsXlJMbd+u1VybO7m6e3x2fbY/PRKzvuVIJuvVsDmqwXYfI0Qm69xsXkv75rzeW/Pb82y+QKYzetgNq+H2bwBZvNGmM2bYDZvhtm8BWbzBMzmSZjNUzCbp2E2z8BsnoXZPAezed7D5gTrH1zJsv7nMOt/BrP+Jpj1N8KsvwFm/fUw66+DWZ98dlhdeHagWb8ryPo9QNbvXsmxvpvPt8d722P9/pXg8xvI+ms51g87Y0iw/loB1l8nxPrrBPfhHdYn2XwBzOZ1MJvXw2zeALN5I8zmTTCbN8Ns3gKzeQJm8yTM5imYzdMwm2dgNs/CbJ6D2TwPs/kSmM2Xwmy+DGbz5TCbr4DZfCXM5qtgNl/tYXO/HLemwOZtC+NtHtcvt7pZc3vssj1uPaOSm+9akFvXg/zmjCHBresFuHWDELduEPzdaYdbSc5cAHNmHcyZ9TBnNsCc2QhzZhPMmc0wZ7bAnJmAOTMJc2YK5sw0zJkZmDOzMGfmYM5cCnPmMpgzl8OcuQLmzJUwZ66COXM1zJlrCpxJc6Gb5bbHBtvjwjMrOS5cD3LhRgVcuFGACzcJceEmwc9/cLiQ5LgFMMfVwRxXD3NcA8xxjTDHNcEc1wxzXAvMcQmY45Iwx6VgjkvDHJeBOS4Lc9wymOOWwxy3Aua4lTDHrYI5bjXMcWs8HOd7v0uI49zstb0s3x7HDajk5rsR5LjPFHDcZwIc97kQx30u+JmuDseR3LUA5q46mLvqYe5qgLmrEeauJpi7mmHuaoG5KwFzVxLmrhTMXWmYuzIwdy2HuWsFzF0rYe5aBXPXapi71sDctbbAXTQnudlme1m5PU46q5LjpM9ATvpCASd9IcBJXwpx0peC5xY5nERyzQKYa+pgrqmHuaYB5ppGmGuaYK5phrmmBeaaBMw1SZhrUjDXpGGuWQFzzUqYa1bBXLMa5po1MNes9XCN35xfJ8Q1bhbZXrZtj2vOruTm+wXINV8p4JqvBLim6GQZrnHGlTqr2uEakkMWwBxSB3NIPcwhDTCHNMIc0gRzSDPMIS0whyRgDknCHJKCOWQlzCGrYA5ZDXPIGphD1sIcsq7AITQ3uLN+e9mxPW44p5Ljhq9Abmh18s7PDY5GmhtaC3FDaxc3dPNoJriBzPkFcM7XwTlfD+d8A5zzjXDON8E53wznfAuc8wk455Nwzq+Cc341nPNr4JxfC+f8Ok/O+/69V6Gcd2fz9nr99nL+3Epuvu5s9pt3bRTkfBuBnG8rlPNtXTnf1aOZyHkylxfAuVwH53I9nMsNcC43wrncBOdyM5zLLXAuJ+BcXg3n8ho4l9fCubwOzuX1hVymc9SdfdvrpdvL0e9XcjnaBszRdgpytJ1AjrYXytH2rhzt4tFM5CiZewvg3KuDc68ezr0GOPca4dxrgnOvGc69Fjj31sC5txbOvXVw7q335J7fHNgglHvurNpe79te7v2gkptvOzD3ihXkXrFA7pUI5V6JK/c6eTQTuUfm1AI4p+rgnKqHc6oBzqlGOKea4JxqhnNqLZxT6+CcWg/n1IZCTtG54s6C7fWW7eXKeZVcrhSDudJBQa50EMiVXYRyZRdXrnT0aCZyhcyBBXAO1ME5UA/nQAOcA41wDjTBObAOzoH1cA5s8OSA77/nFcoBd+/eXi/YXg78sJKbbwcwBzoqyIGOAjnQSSgHOrlyoINHM5EDZN9eAPftOrhv18N9uwHu241w314P9+0NcN/eWOjbdJ9198btrbXt9dkfVXJ9tiPYZzsr6LOdBfpsF6E+28XVZ0s8mok+S/bFBXBfrIP7Yj3cFxvgvrgB7osbPX3Rb5/YJNQX3b1se2tje33xx5XcfDuDfbGrgr7YVaAv7irUF3d19cX2Hs1EXyT72AK4j9XBfawe7mMb4T62qdDH6L7j7hXbu/e213d+Usn1na5g3+mmoO90E+g73YX6TndX32kn0HfIPrEA7hN1cJ/Y5OkTvj/HRahPuNf29u6V7fWJn1Zy8+0G9ondFPSJ3QT6xO5CfWJ3V59oI9AnyHW9AF7XnxXWNb0O3Wtne+/F9tbhz8B1uBu4DvdQsA73EFiHPYTWYY9trMPtaI7Ft635ay9+Vsl6O/4k/r0qYu+BQNuClyVF//miftbXzOUZm76nnTOmKb1SGvMKNOYUaMwq0JhRoDGtQGNKgcakAo0JBRpbFGhsVqCxSYHGRgUaGxRorFegsU6BxgUKNDp7BpRGR9vBRVtetN4NCjzdqEDjJgUaP1Og8XMFGr9QoPFLBRq/UqDR+Y/eO7vGVgo0tlagsY0CjW0VaGynQGN7BRqLFWgsUaCxgwKNuyjQ2FGBxk4KNHZWoLGLAo1dFWjcVYHGbgo0dlegcTcFGndXoHEPBRp7KNC4pwKNeynQuLcCjT0VaOwFanS09S/a8rJ74zunRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMRrs3zmi0e+OMxv+1vfEiz2XHtePace24dlw7rh3XjmvHtePace24/+21tc+Kac3+jOCBPp6Hgp7Xh+/IWMFt/7PUfPuA8w3v0Fi127yk5tsXnG8/BfMdAM73PAXzPR+c7yUK5nspON+BCuY7CJzvTQrmOwSc71AF830QnO8wBfMdA873KQXzHQvOd7KC+b4KzneqgvnOBuc7T8F868H5JhXMdyE43yUK5rsanO8mBfNtVczNt6R4559vV3C+PVxj+f285G/jc3HXK/hd/3UKNK5VoHGNAo2rFWhcpUDjSgUaVyjQuFyBxmUKNC5VoHGJAo2fKtD4iQKNixVo/FiBxo8UaFwEavw2mLxV5c7vaWsFGtso0NhWgcZ2CjS2V6CxWIHGEgUaOyjQuIsCjR0VaOykQGNnBRq7KNDYVYHGXRVo7KZAY3dQo2XybzS2VqDRMjmj0TI5o9EyOaPRMjmj0TI5o9EyOaPRMjmj8X+RyTdr3Mzme55cVLSXqb1N9TTVy9Q+pvY1tZ+p/U0dYOpAU71NHWTqYFOHmDrU1GGmDj/5/80bN8A5TJsywDlA26lORf/5on7Wt/EAZA/QZjTaA7QZjfYAbUajPUCb0WgP0GY02gO0GY32AG1Goz1Am9FoD9C2h4QEfF5SGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtAdp2bzzg85LSaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaPfGGY12b5zRaA/QtuPace24dlw7rh3XjmvHtePace24dtz/7traZ8W0Zn+GPUB7R77Z89oeoL2t67uZrz1Aewe+2fPaHqC9reu7ma89QHsHvtnz2h6gva3ru5mvPUB7B77Z89oeoL2t67uZrz1Aewe+2fPaHqC9reu7ma89QHsHvtnz2h6gbQ/QDvi77AHakEZ7gDaj0R6gzWi0B2gzGu0B2oxGe4A2o9EeoM1otAdoMxrtAdoCfzeqQGMbBRrtYX2MRntYH6PRHtbHaLSH9TEa7WF9jEZ7WB+j0R7Wx2jsDmps5dLnvcifYbnfcj+l0XI/o9FyP6PRcj+j0XI/o9FyP6PRcj+j0XI/o9Fy/79dQedgcUqvlMa9FGjcW4HGngo09lKgcR8FGvdVoHE/BRr3V6DxAAUaD1SgsbcCjQcp0HiwAo2HKNB4qAKNhynQeDio8Vvg/mAblw+b+f8IM4cjTR1l6mhT3zN1jKk+pgKmgqZKTZWZKjcVMhU2FTFVYSpq6tiTtxzzOPP6eFN9TZ1g6kTHJ1MnmTrZ1Cmm+pk61dRppk431d/UGabONDXA1FmFMTef1322eX2OqXNNfd/UD0ydZ+qHpn5k6semfmLqp6Z+Zup8Uz83dYGpX5i60NRFpi42dYmpKlPVpmKmakzFTdWautTUL01dZupyU1eYutLUVaYGmrra1DUnu94r/MY/hL3xJfQdcfK/j+v3D0OuhRdTm8LcnXFvFHyvjhTw4johL64T9uIoAS+uF/LiemEvjhbw4gYhL24Q9uJ7Al4MEvJikLAXxwh48SshL34l7EUfAS9+LeTFr4W9CAh4caOQFzcKexEU8OI3Ql78RtiLUgEvfivkxW+FvSgT8OJ3Ql78TtiLcgEvbhLy4iZhL0ICXtws5MXNwl6EBby4RciLW4S9iAh4cauQF7cKe1Eh4MVtQl7cJuxFVMCLwUJeDBb24lgBL24X8sIZt0th3Naw5vmtv/GC8tb5pRCnaG9nnLLz7w+eLXBPzTxF5p5yxm0luL7OEfBilpAXs4S9OFfAi9lCXswW9uL7Al7MEfJijrAXPxDwYq6QF3OFvThPwIu3hbx4W9iLHwp48Y6QF+8Ie/EjAS/eFfLiXWEvfizgxXtCXrwn7MVPBLyYJ+TFPGEvfirgxftCXrwv7MXPBLyYL+TFfGEvzhfw4gMhLz4Q9uLnAl58KOTFh8JeXCDgxQIhLxYIe/ELAS/qhLyoE/biQgEv6oW8qBf24iIBLxqEvGgQ9uJiAS8ahbxoFPbiEgEvmoS8aBL2okrAi2YhL5qFvagW8KJFyIsWYS9iAl4khLxICHtRI+BFUsiLpLAXcQEvUkJepIS9qBXwIi3kRVrYi0sFvMgIeZER9uKXAl5khbzICntxmYAXOSEvcsJeXC7gRV7Ii7ywF1cIeLFQyIuFwl5cKeDFIiEvFgl7cZWAFx8JefGRsBcDBbz4WMiLj11etPZoDoZrw+GqqlBNVTQQikTKQ9FYKBQJV5SWGemhWDQUKQtEKspqQqHa6lhVrCJYEy2NxiJVVeHSsmgwHF7Y7pu/2/u/8aLhmnhZrCYQrgqWV1SHQvGKqni8PB6KR2qMJWU1wUBZJBCoLi2rrqky45eGy40FwWh5tCYWjkernQ92dKqdV6fPcbc4qLqiOlJbFozFzVTD8VC4IhqrjpWGzU8oL60or4nHSgPR2oqK8traYCQeDpRVhUKBitLyeG00bH5krNx9ULVf/3bkA23Kt/PvZ5/M3YuLuXsxKLUGF5/Cr8FPhNagM+4thXHbwGsw712DwJo+0n1flkYikWhppDQWDNQGy4OB8ljILIVwWXWkoioWq4pEa0prI7Ea879gTXUgaNaXWVDReFVZdUVNTVnIWc+tTRXDa7oPuKbD4JreC1iH8a+P8YsFzwb7wzlgn3b3B79r7tNTMO8jUr3mU4Fes0So1yxx9Zp2cK/Jwb0m7+k1RO86Cu5dbSq5ddO6UqYX9gV7YT+wF+4N9sJzwF54LtgLPwV74VIFvXCpQC9cJtQLl7l6YXvvmvN5b2fhXpiDe2He0wuJ3no03Fu3+HB3n+O1rvymV9O9dQDYW88De2tPsLeeC/bW74O9dSnYW5cr6K3LBXrrCqHeusLVW0u8a87nvZ2Be2sW7q05uLfmPb2V6NXfg3v1FodcAL3a3fv99gmn70v0/vPB3n8J2Pt7gb3/+2Dv/wHY+5eDvX+lgt6/UqD3rxLq/atcvb+Dd835vLfTcO/PwL0/C/f+HNz7857eT2TJMXCWbHEYEZAlZDY5OeJkE50ll4JZMhDMkn3ALPkBmCXngVmyEsyS1QqyZLVAlqwRypI1rizp6F1zPu/tFJwlaThLMnCWZOEsycFZkvdkCZFNfeBs2uIQOiCbyKxzssmddX77opNzElk3CMy6m8Cs2xfMuvPArPshmHWrwaxbqyDr1gpk3TqhrFvnyrpO3jXn895OwlmXgrMuDWddBs66LJx1OTjr8p6sI7IzAGfnFoejAtlJZrGTnWQWO7npZDGdnUPA7BwKZud+YHb+EMzOH4HZuRbMzvUKsnO9QHZuEMrODa7s7OJdcz7v7QScnUk4O1Nwdqbh7MzA2ZmFszMHZ2fek51EFgfhLN7iEHAgi8ls//q/1VWyWezOdr854OS6RLY/CGb7MDDb9wez/Udgtv8YzPb1YLZvVJDtGwWyfZNQtm9yZXtX75rzeW+3wNmegLM9CWd7Cs72NJztGTjbs3C25+Bsz3uynWCFUpgVdqlkWYFkD4cVSPb4er8bHM/hBIc9aFYYA7LCUyArHACywo9BVvgJyAobQVb4TAErfCbACp8LscLnLlbo5l1zPu/tZpgVWmBWSMCskIRZIQWzQhpmhQzMClmYFXIwK+Q9rECwRxnMHh0rWfYgWcZhD5JlHPYgWebrPYpKLvccjpFgmbEgy0wGWeZAkGV+ArLMT0GW+QxkmS8UsMwXAizzpRDLfOlime7eNefz3m6CWaYZZpkWmGUSMMskYZZJwSyThlkmA7NMFmaZHMwyeQ/LEGxUDrNRp0qWjUjWctiIZC2HjUjWctiIZK2vuaiSZ6NXQTaaCrJRb5CNfgqy0c9ANvoCZKOvFLDRVwJsVNRPho2ccTez0e7eNefz3m6E2agJZqNmmI1aYDZKwGyUhNkoBbNRGmajDMxGWZiNcjAb5T1sRLBWCGatzpUsa5Hs5rAWyW4Oa5Hs5rAWyW4Oa7nZzW/Of81tlTy7zQbZbR7IbgeB7PYzkN3OB9ntK5DdWvXb+dnN0UizW2shdmvtYrc9vGvO573dALNbI8xuTTC7NcPs1gKzWwJmtyTMbimY3dIwu2VgdsvC7JaD2S3vYTeCBcMwC3apZFmQZEuHBUm2dFiQZEuHBUm2dFiQZEuHAx22pFmwHmTBJMiCB4MseD7Igj8HWdDNb36ZqI0CFmwjwIJthViwrYsF9/SuOZ/3dj3Mgg0wCzbCLNgEs2AzzIItMAsmYBZMwiyYglkwDbNgBmbBLMyCOZgF8x4WJNgyArNl10qWLUlWddiSZFWHLUlWddiSZFWHLUlWddjSzap+ucbhVAlWXQiy6hKQVQ8BWfXnIKteALJqG5BV2ylg1XYCrNpeiFXbu1h1L++a83lv18GsWg+zagPMqo0wqzbBrNoMs2oLzKoJmFWTMKumYFZNw6yagVk1C7NqDmbVvIdVCfatgNl310qWfUmWdtiXZGmHfUmWdtiXZGmHfUmWdtiXZGmHex2Wptl3Nci+m0D2PRRk3wtA9v0FyL7tQPYtVsC+xQLsWyLEviUu9u3pXXM+7+0FMPvWwexbD7NvA8y+jTD7NsHs2wyzbwvMvgmYfZMw+6Zg9k3D7JuB2TcLs28OZt+8h30Jlo7CLN2tkmVpks0dlibZ3GFpks0dlibZ3GFpks0dlibZ3GFpN5v75TiHyyXYvFUxx+Ylxdz6PQxk81+AbH4hyObFIJt3UMDmHQTYfBchNt/Fxea9vGvO5709vzXL5gtgNq+D2bweZvMGmM0bYTZvgtm8GWbzFpjNEzCbJ2E2T8FsnobZPAOzeRZm8xzM5nkPmxOsfyzM+t0rWdYnnx0c1iefHRzWJ58dHNYnnx0c1iefHRzWJ58dHNYnnx0czneeHWjW7wqyfg+Q9Q8HWf9CkPUvAlm/A8j6HTnWDztjSLB+RwHW7yTE+p0E9+Ed1ifZfAHM5nUwm9fDbN4As3kjzOZNMJs3w2zeArN5AmbzJMzmKZjN0zCbZ2A2z8JsnoPZPA+zeetKls0dlibZ3GFpks0dlibZ3GFpks0dlibZ3GFpks0dlnazuV+Oc7jcqbaF8TaP65dbLwK59WKQWzuC3NoZ5DdnDAlu7SzArV2EuLWL4O9OO9xKcuYCmDPrYM6shzmzAebMRpgzm2DObIY5swXmzATMmUmYM1MwZ6ZhzszAnJmFOTMHc6bDhSRnOlxIcqbDhSRnOlxIcqbDhSRnOlxIcqbDhSRnOkzocCbNhReDXHgJyIWdQS7sqoALuwpw4a5CXLir4Oc/OFxIctwCmOPqYI6rhzmuAea4RpjjmmCOa4Y5rgXmuATMcUmY41Iwx6VhjsvAHJeFOc7hLpLjHO4iOc7hLpLjHO4iOc7hLpLjHO4iOc7hLjfH+d7vqpThuEtAjqsCOa4ryHHdFHBcNwGO6y7Ecd0FP9PV4TiSuxbA3FUHc1c9zF0NMHc1wtzVBHNXM8xdLTB3JWDuSsLclYK5Kw1zVwbmLoeTSO5yOInkLoeTSO5yOInkLoeTSO5yOInkLoeRHO6iOakK5KRqkJO6gZy0mwJO2k2Ak3YX4qTdBc8tcjiJ5JoFMNfUwVxTD3NNA8w1jTDXNMFc0wxzTQvMNQmYa5Iw16RgrknDXONwCMk1DoeQXONwCMk1DoeQXONwCMk1Doe4ucZvzjtMI8E11SDXxECu2Q3kmj0UcM0eAlzTQ4hrevSTO6va4RqSQxbAHFIHc0g9zCENMIc0whzSBHNIM8whLTCHJGAOScIckoI5xOEGkkMcbiA5xOEGkkMcbiA5xOEGkkMcZnA4hOaGGMgNNSA37AFyw54KuGFPAW7YS4gb9nJxQzePZoIbyJxfAOd8HZzz9XDON8A53wjnfBOc881wzrfAOZ+Acz4J57yTy2TOO7lM5ryTy2TOO7lM5ryTy+6c9/17r5UyOV8D5nwczPk9wZzfW0HO7y2Q8z2Fcr6nK+e7ejQTOU/m8gI4l+vgXK6Hc7kBzuVGOJeb4FxuhnO5Bc7lBJzLTo6SuezkKJnLTo6SuezkKJnLToY6uUznaBzM0VowR/cGc7SXghztJZCj+wjl6D6uHO3i0UzkKJl7C+Dcq4Nzrx7OvQY49xrh3GuCc68Zzr0WOPecnCJzz8kpMvecnCJzz8kpd+75zQEn8yRyrxbMvUvB3OsF5t6+CnJvX4Hc208o9/Zz5V4nj2Yi98icWgDnVB2cU/VwTjXAOdUI51QTnFPNcE45uULmlJMrZE45uULmlJMpTk7RuXIpmCu/BHNlXzBX9leQK/sL5MoBQrlygCtXOno0E7lSDudKCM6VMJwrEThXKuBcicK5QuaA07fJHHD6NpkDTt9254Dvv+etlMmBX4I5cBmYA/uDOXCgghw4UCAHegvlQG9XDnTwaCZyIATnQBjOgQicAxVwDkThHCD7ttNnyb7t9Fmybzs91unbdJ+9DOyzl4N99kCwzx6koM8eJNBnDxbqswe7+myJRzPRZ8Nwn43AfbYC7rNRuM+SfdHpY2RfdPqYuy/67RNOT5Toi5eDffEKsC8eBPbFQxT0xUME+uKhQn3xUFdfbO/RTPTFCNwXK+C+GIX7ItnHusJ9bNdCH6P7zhVg37kS7DuHgH3nMAV95zCBvnO4UN853NV32gn0nQq470ThvkP2iV09fcL357gI9YkrwT5xFdgnDgP7xBEK+sQRAn3iSKE+caSrT7QR6BNRuE+Q67pbYV3T6/AqcB0OBNfhEeA6PErBOjxKYB0eLbQOj97GOtyO5lh825q/9mLgyay3M07h36si9h4ItC14WVL0ny/qZ339Wamesel72jljmtIrpTGvQGNOgcasAo0ZBRrTCjSmFGhMKtCYUKCxRYHGZgUamxRobFSgsUGBxnoFGusUaFygQKOzZ0Bp/Pq/SxdtedF6NyjwdKMCjZsUaPxMgcbPFWj8QoHGLxVo/EqBRuc/eu/sGlsp0NhagcY2CjS2VaCxnQKN7RVoLFagsUSBxg4KNO6iQGNHBRo7KdDYWYHGLgo0dlWgcVcFGrsp0NhdgcbdFGjcXYHGPRRo7KFA454KNO6lQOPeCjT2VKCxF6jR0da/aMvL7o3vnBrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxr/1/bGizyXHdeOa8e149px7bh2XDuuHdeOa8e14/6319Y+K6Y1+zOCB/p4Hgp6Xh++I2MFt/3PUvPtA843vENj1W7zkppvX3C+/RTMdwA43/MUzPd8cL6XKJjvpeB8ByqY7yBwvjcpmO8QcL5DFcz3QXC+wxTMdww436cUzHcsON/JCub7KjjfqQrmOxuc7zwF860H55tUMN+F4HyXKJjvanC+mxTMt1UxN9+S4p1/vl3B+fZwjeX385K/jc/FXa/gd/3XKdC4VoHGNQo0rlagcZUCjSsVaFyhQONyBRqXKdC4VIHGJQo0fqpA4ycKNC5WoPFjBRo/UqBxEajx22DyPU/e+T3dS4HGvRVo7KlAYy8FGvdRoHFfBRr3U6BxfwUaD1Cg8UAFGnsr0HiQAo0HK9B4iAKNhyrQeJgCjYeDGi2Tf6PRMjmj0TI5o9EyOaPRMjmj0TI5o9EyOaPRMjmj0TI5o5Fm8s0aN7P59/oVFR1jqo+pgKmgqVJTZabKTYVMhU1FTFWYipo61tRxpo431dfUCa5zyfk36RDOAOcAbac6Ff3ni/pZ38YDkD1Am9FoD9BmNNoDtBmN9gBtRqM9QJvRaA/QZjTaA7QZjfYAbUajPUDbHhIS8HlJabSHhDAa7SEhjEZ7SAij0R4Swmi0h4QwGu0hIYxGe0gIo9EeEsJotIeEMBrtISGMRntICKPRHhLCaLSHhDAa7SEhjEZ7SAij0R4Swmi0B2jbvfGAz0tKo90bZzTavXFGo90bZzTavXFGo90bZzTavXFGo90bZzTavXFGo90bZzTavXFGo90bZzTavXFGo90bZzTavXFGo90bZzTavXFGoz1A245rx7Xj2nHtuHZcO64d145rx7Xj2nH/u2trnxXTmv0Z9gDtHflmz2t7gPa2ru9mvvYA7R34Zs9re4D2tq7vZr72AO0d+GbPa3uA9rau72a+9gDtHfhmz2t7gPa2ru9mvvYA7R34Zs9re4D2tq7vZr72AO0d+GbPa3uAtj1AO+DvsgdoQxrtAdqMRnuANqPRHqDNaLQHaDMa7QHajEZ7gDaj0R6gzWi0B2gL/H6wAo32sD5Goz2sj9FoD+tjNNrD+hiN9rA+RqM9rI/RaA/rYzT+Lx7Wt1mf9yJ/huV+y/2URsv9jEbL/YxGy/2MRsv9jEbL/YxGy/2MRsv9jEbL/f92BZ2DxSm9UhqPUaCxjwKNAQUagwo0lirQWKZAY7kCjSEFGsMKNEYUaKxQoDGqQOOxCjQep0Dj8Qo09lWg8QRQ47fA/cE2Lh828/+JzhxMnWTqZFOnmOpn6lRTp5k63VR/U2eYOtPUAFNnmTrb1DmmzjX1/X5bjvkD8/o8Uz809SNTPzb1E1M/NfUzU+eb+rmpC0z9wtSFpi4ydbGpS0xVmaoujHlwYcyYeV1jKm6q1tSlpn5p6jJTl5u6wtSVpq4yNdDU1aauMXWtqetMXW/qBlODTP3K1K9N3WjqN6Z+a+p3pm4ydbOpW0zdauo2U4NN3W5qiKk7TN1p6q5+rvcKf+A9hL3xJfSd2O/fx/X7hyF3w4upTWHuzrg3Sr5XAl7cI+TFPcJenCTgxb1CXtwr7MXJAl4MFfJiqLAXpwh4cZ+QF/cJe9FPwIv7hby4X9iLUwW8eEDIiweEvThNwIvfC3nxe2EvThfw4g9CXvxB2Iv+Al78UciLPwp7cYaAFw8KefGgsBdnCnjxJyEv/iTsxQABLx4S8uIhYS/OEvDiYSEvHhb24mwBLx4R8uIRYS/OEfDiUSEvHhX24lwBLx4T8uIxYS++L+DFMCEvnHG7FMZtDWue3/obLyhvnV8KcYr2tuXUnX9/MCZwTyVOlbmnnHFbCa6vGgEvkkJeJIW9iAt4kRLyIiXsRa2AF2khL9LCXlwq4EVGyIuMsBe/FPAiK+RFVtiLywS8yAl5kRP24nIBL/JCXuSFvbhCwIuFQl4sFPbiSgEvFgl5sUjYi6sEvPhIyIuPhL0YKODFx0JefCzsxdUCXiwW8mKxsBfXCHjxiZAXnwh7ca2AF58KefGpsBfXCXixRMiLJcJeXC/gxVIhL5YKe3GDgBfLhLxYJuzFIAEvlgt5sVzYi18JeLFCyIsVwl78WsCLlUJerBT24kYBL1YJebFK2IvfCHixWsiL1cJe/FbAizVCXqwR9uJ3Al6sFfJirbAXNwl4sU7Ii3XCXtws4MV6IS/WC3txi4AXG4S82CDsxa0CXmwU8mKjsBe3CXixSciLTcJeDBbw4jMhLz4T9uJ2AS8+F/Lic2Evhgh48YWQF18Ie3GHgBdfCnnxpcsL7+83BcO14XBVVaimKhoIRSLloWgsFIqEK0rLjPRQLBqKlAUiFWU1oVBtdawqVhGsiZZGY5GqqnBpWTQYDi9sV/hjz83jRcM18bJYTSBcFSyvqA6F4hVV8Xh5PBSP1BhLymqCgbJIIFBdWlZdU2XGLw2XGwuC0fJoTSwcj1Y7H+zoVDuvTp/jbnFQdUV1pLYsGIubqYbjoXBFNFYdKw2bn1BeWlFeE4+VBqK1FRXltbXBSDwcKKsKhQIVpeXx2mjY/MhYufugar/+7cgH2pRv599j/bh78SvuXgxKrcGvTuXXYNFpMmvQGfeWwrht4DWY965BYE1Xuu/L0kgkEi2NlMaCgdpgeTBQHguZpRAuq45UVMViVZFoTWltJFZj/hesqQ4EzfoyCyoaryqrrqipKQs569n5MNRieE33Add0GFzTxwDrMP71MX6xYAzsDzVgn3b3B9+H952GeR+R6jWORrrXtBbqNa1dvaYd3GtycK/Je3oN0btOgnuX+0OS/a6bvYR6YV+wF/YDe2EfsBfWgL0wDvZCd//y2xPaKOiFbQR6YVuhXtjW1QvbF7G9MAv3whzcC/OeXkj01pPh3rrFh7v7HG+vQq+me+sAsLeeB/bWANhb42BvrQV7axuwt7ZT0FvbCfTW9kK9tb2rt5Z415zPezsD99Ys3FtzcG/Ne3or0atPgXt1L7hX9wS5em+h3n8+2PsvAXt/EOz9tWDvvxTs/e3A3l+soPcXC/T+EqHeX+Lq/R28a87nvZ2Ge38G7v1ZuPfn4N6f9/R+Ikv6wVmyD5wlZDbtXcgmOksuBbNkIJglpWCWXApmyS/BLCkGs6SDgizpIJAluwhlyS6uLOnoXXM+7+0UnCVpOEsycJZk4SzJwVmS92QJkU2nwtm0L5xN+8DZ1At8buoplHWDwKy7Ccy6MjDrfglm3WVg1nUAs66jgqzrKJB1nYSyrpMr6zp515zPezsJZ10Kzro0nHUZOOuycNbl4KzLe7KOyM7T4OzcD87OfeHsJLO4ZyGL6ewcAmbnUDA7y8HsvAzMzsvB7OwIZmdnBdnZWSA7uwhlZxdXdnbxrjmf93YCzs4knJ0pODvTcHZm4OzMwtmZg7Mz78lOIotPh7N4fziL94OzeF84i/cBn4t7CWX7g2C2DwOzPQRm++Vgtl8BZntnMNu7Ksj2rgLZvqtQtu/qyvau3jXn895ugbM9AWd7Es72FJztaTjbM3C2Z+Fsz8HZnvdkO8EK/WFWOABmBZI99obZoyfMHr0K7EGzwhiQFZ4CWSEMssIVICtcCbJCV5AVuilghW4CrNBdiBW6u1ihm3fN+by3m2FWaIFZIQGzQhJmhRTMCmmYFTIwK2RhVsjBrJD3sALBHmfA7HEgzB4ky+wNs0xPmGV6eVjGb+7tI8QyY0GWmQyyTARkmStBlrkKZJluIMvspoBldhNgmd2FWGZ3F8t09645n/d2E8wyzTDLtMAsk4BZJgmzTApmmTTMMhmYZbIwy+Rglsl7WIZgozNhNuoNsxHJWnvDrNUTZq1eMGvtU2Atmo1eBdloKshGFSAbXQWy0UCQjXYD2WgPBWy0hwAb9RBiox4uNtrdu+Z83tuNMBs1wWzUDLNRC8xGCZiNkjAbpWA2SsNslIHZKAuzUQ5mo7yHjQjWGgCz1kEwa5HstjfMbj1hdusFs9s+Hnbzm/P7CrHbbJDd5oHsFgXZbSDIbleD7LYHyG57KmC3PQXYbS8hdtvLxW57eNecz3u7AWa3RpjdmmB2a4bZrQVmtwTMbkmY3VIwu6VhdsvA7JaF2S0Hs1vew24EC54Fs+DBMAuSbLk3zJY9YbbsBbPlPjBb7ltgS5oF60EWTIIseCzIgleDLHgNyIJ7giy4twIW3FuABXsKsWBPFwvu6V1zPu/tepgFG2AWbIRZsAlmwWaYBVtgFkzALJiEWTAFs2AaZsEMzIJZmAVzMAvmPSxIsOXZMFseArMlyap7w6zaE2bVXjCr7gOz6r4eVvXLNfsJsepCkFWXgKx6HMiq14Csei3IqnuDrNpLAav2EmDVfYRYdR8Xq+7lXXM+7+06mFXrYVZtgFm1EWbVJphVm2FWbYFZNQGzahJm1RTMqmmYVTMwq2ZhVs3BrJr3sCrBvufA7HsozL4kS+8Ns3RPmKV7wSy9D8zS+8IsvV+BpWn2XQ2y7yaQfY8H2fdakH2vA9m3F8i++ypg330F2Hc/Ifbdz8W+Pb1rzue9vQBm3zqYfeth9m2A2bcRZt8mmH2bYfZtgdk3AbNvEmbfFMy+aZh9MzD7ZmH2zcHsm/ewL8HS58IsfRjM0iSb7w2zeU+YzXvBbL4PzOb7wmy+n4fN/XLc/kJs3qqYY/OSYm799gXZ/DqQza8H2XxfkM33V8Dm+wuw+QFCbH6Ai817edecz3t7fmuWzRfAbF4Hs3k9zOYNMJs3wmzeBLN5M8zmLTCbJ2A2T8JsnoLZPA2zeQZm8yzM5jmYzfMeNidY//sw6x8Osz757LA3/OzQE3526AU/O+wDPzvsCz877Ac/O+xfeHagWb8ryPo9QNY/AWT960HWvwFk/f1B1j+QY/2wM4YE6x8owPq9hVi/t+A+vMP6lTDrnwSz/skw658Cs34/mPVPhVn/NJj1T4dZvz/M+mfArH8mzPoDYNY/C2b9s2HWPwdm/XNh1ifZfC+YzfeG2bwnzOa9YDbfB2bzfWE23w9m8/09bO6X4w4osHnbwnibx/XLrTeA3DoI5NYDQW49COQ3ZwwJbj1IgFsPFuLWgwV/d9rh1pNgbj0Z5tZTYG7tB3PrqTC3ngZz6+kwt/aHufUMmFvPhLl1AMytZ8HcejbMrefA3HouzK0kZ+4Nc2ZPmDN7wZy5D8yZ+8KcuR/MmfvDnHlAgTNpLhwEcuGvQC48COTCQxRw4SECXHioEBceKvj5Dw4Xngxz4SkwF/aDufBUmAtPg7nwdJgL+8NceAbMhWfCXDgA5sKzYC48G+bCc2AuPBfmQpLjesIc1wvmuH1gjtsX5rj9YI7bH+a4Azwc53u/S4jjfgVy3K9BjjsE5LjDFHDcYQIcd7gQxx0u+JmuDsedAnNcP5jjToU57jSY406HOa4/zHFnwBx3JsxxA2COOwvmuLNhjjsH5rhzYY4juasXzF37wNy1L8xd+8HctT/MXQfA3HVggbtoTvo1yEk3gpx0GMhJRyjgpCMEOOlIIU46UvDcIoeT+sGcdCrMSafBnHQ6zEn9YU46A+akM2FOGgBz0lkwJ50Nc9I5MCedC3MSyTX7wFyzL8w1+8Fcsz/MNQfAXHOgh2v85nxvIa65EeSa34BccwTINUcp4JqjBLjmaCGuOVrwrGqHa06FueY0mGtOh7mmP8w1Z8BccybMNQNgrjkL5pqzYa45B+aac2GuITlkX5hD9oM5ZH+YQw6AOeRAmEN6FziE5obfgNzwW5AbjgK54XsKuOF7AtxwjBA3HOPihm4ezQQ3nAZzw+kwN/SHueEMmBvOhLlhAMwNZ8HccDbMDefA3HAuzA1kzu8H5/z+cM4fAOf8gXDO9/bkvO/fexXK+d+COf87MOe/B+Z8HwU530cg5wNCOR9w5XxXj2Yi50+Hc74/nPNnwDl/JpzzA+CcPwvO+bPhnD8Hzvlz4Zwnc3l/OJcPgHP5QDiXe8O5fFAhl+kc/R2YozeBOdoHzNGgghwNCuRoqVCOlrpytItHM5Gj/eEcPQPO0TPhHB0A5+hZcI6eDefoOXCOngvnKJl7B8C5dyCce73h3DvIk3t+c+Bgody7Ccy9m8HcC4K5V6Yg98oEcq9cKPfKXbnXyaOZyL0z4Nw7E869AXDunQXn3tlw7p0D5965cO6ROXUgnFO94Zw6CM6pgws5RefKzWCu3ALmShmYKyEFuRISyJWwUK6EXbnS0aOZyJUz4VwZAOfKWXCunA3nyjlwrpwL5wqZA73hHDgIzoGDPTng++95hXLgFjAHbgVzIATmQERBDkQEcqBCKAcqXDnQwaOZyIEBcA6cBefA2XAOnAPnwLlwDpB9+yC4bx8M9+1DCn2b7rO3gn32NrDPRsA+G1XQZ6MCffZYoT57rKvPlng0E332LLjPng332XPgPnsu3GfJvngw3BcP8fRFv33iUKG+eBvYFweDfTEK9sXjFPTF4wT64vFCffF4V19sX8T3xbPhvngO3BfPhfsi2ccOgfvYoYU+RvedwWDfuR3sO8eBfaevgr7TV6DvnCDUd05w9Z12An3nHLjvnAv3HbJPHOrpE74/x0WoT9wO9okhYJ/oC/aJExX0iRMF+kSlUJ+odPWJNgJ94ly4T5Dr+rDCuqbX4RBwHd4BrsMTwXV4koJ1eJLAOjxZaB2evI11uB3Nsfi2NX/txR39WG9bTuXfqyL2Hgi0LXhZUvSfL+pnOe9hd8/Y9D3tnDFN6ZXSmFegMadAY1aBxowCjWkFGlMKNCYVaEwo0NiiQGOzAo1NCjQ2KtDYoEBjvQKNdQo0LlCg8euz6iGNX59PWrTlRevdoMDTjQo0blKg8TMFGj9XoPELBRq/VKDxKwUanf/ovbNrbKVAY2sFGtso0NhWgcZ2CjS2V6CxWIHGEgUaOyjQuIsCjR0VaOykQGNnBRq7KNDYVYHGXRVo7KZAY3cFGndToHF3BRr3UKCxhwKNeyrQuJcCjXsr0NhTgcZeoEZHW/+iLS+7N75zarR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaLR744xGuzfOaPxf2xsv8lx2XDuuHdeOa8e149px7bh2XDuuHdeO+99eW/usmNbszwge6ON5KOh5ffiOjBXc9j9LzbcPON/wDo1Vu81Lar59wfn2UzDfAeB8z1Mw3/PB+V6iYL6XgvMdqGC+g8D53qRgvkPA+Q5VMN8HwfkOUzDfMeB8n1Iw37HgfCcrmO+r4HynKpjvbHC+8xTMtx6cb1LBfBeC812iYL6rwfluUjDfVsXcfEuKd/75dgXn28M1lt/PS/42Phd3vYLf9V+nQONaBRrXKNC4WoHGVQo0rlSgcYUCjcsVaFymQONSBRqXKND4qQKNnyjQuFiBxo8VaPxIgcZFoEY3k3ufQ/zyvnOWx+GHcPN2xvteP95PUGNAwsMjYA+PEfDwiJ3cwyNhD/sIeHjkTu7hUbCHAQEPj9rJPTwa9jAo4OHRO7mH34M9LBXw8Hs7uYfHwB6WCXh4zE7uYR/Yw3IBD/vs5B4GYA9DAh4GdnIPg7CHYQEPgzu5h6WwhxEBD0t3cg/LYA8rBDws28k9LIc9jAp4WL6TexiCPTxWwMPQTu5hGPbwOAEPwzu5hxHYw+MFPIzs5B5WwB72FfCwYif3MAp7eIKAh6DGb+X3TG4H9UppfFSBxmcUaHxNgcb5CjQuUqBxkwKNXQ7d+TX2VqAxrEDjmQo0XqRA43UKNN6lQONwBRrHKdA4VYHGD9qyTL5Z42Y2P+W0oqJ+pk41dZqp0031N3WGqTNNDTB1lqmzTZ1j6lxT3zf1A1PnmfqhqR+ZKmpbqE5F//mqBCci/XCxsN3Of3PkFWjMKdCYVaAxo0BjWoHGlAKNSQUaEwo0tijQ2KxAY5MCjY0KNDYo0FivQGOdAo0LFGic35pl8oOLtrzsAXY7p0Z7gB2j0R5gx2i0B9gxGu0BdoxGe4Ado9EeYMdotAfYMRrtAXaMRnuAHaPRHmDHaLQH2DEa7QF2jEZ7gB2j0R5gx2i0B9gxGu0BdozG/7UD7Bxt/Yu2vOze+M6p0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij0e6NMxrt3jij8X9tb7zIc9lx7bh2XDuuHdeOa8e149px7bh2XDvuf3tt7bNiWrM/I3ggeJjv4TsyVnDb/yw13z7gfMMKDi/uC863n4L5DgDne56C+Z4PzvcSBfO9FJzvQAXzHQTO9yYF8x0Czneogvk+CM53mIL5jgHn+5SC+Y4F5ztZwXxfBec7VcF8Z4PznadgvvXgfJMK5rsQnO8SBfNdDc53k4L5tirm5ltSvPPPtys43x6usfweNPJtfC7uegW/679Ogca1CjSuUaBxtQKNqxRoXKlA4woFGpcr0LhMgcalCjQuUaDxUwUaP1GgcbECjR8r0PiRAo2LQI1uJvc+hxAHCx5+CDdvZ7zvCRwsCGoUOZzxCNjDYwQ8PGIn9/BI2MM+Ah4euZN7eBTsYUDAw6N2cg+Phj0MCnh49E7u4fdgD0sFPPzeTu7hMbCHZQIeHrOTe9gH9rBcwMM+O7mHAdjDkICHgZ3cwyDsYVjAw+BO7mEp7GFEwMPSndzDMtjDCgEPy3ZyD8thD6MCHpbv5B6GYA+PFfAwtJN7GIY9PE7Aw/BO7mEE9vB4AQ8jO7mHFbCHfQU8rNjJPYzCHp4g4CGo8es97c36vBf5M6R/l+V20BMpjY8q0PiMAo2vKdA4X4HGRQo0blKgscuhO7/G3go0hhVoPFOBxosUaLxOgca7FGgcrkDjOAUapyrQ+EFby/2eK3jKaTv/+9ZPgcZTFWg8TYHG0xVo7K9A4xkKNJ6pQOMABRrPUqDxbAUaz1Gg8VwFGr+vQOMPFGg8T4HGHyrQ+CNQ47fA/cE2Lh828/+PzRx+Yuqnpn5m6nxTPzd1galfmLrQ1EWmLjZ1iakqU9WmYqZqTMVN1Z625ZiXmte/NHWZqctNXWHqSlNXmRpo6mpT15i61tR1pq43dYOpQaZ+ZerXpm4sjHlwYczfmNe/NfU7UzeZutnULaZuNXWbqcGmbjc1xNQdpu40dZepu03dY+peU0NN3WfqflMPmPq9qT+Y+qOpB039ydRDph429YipR009ZmqYqcdNDTc1wtTI0womtin8X8fEGz1f+8lWvvbTrXztZ1v52vlb+drPt/K1C7bytV9s5WsXbuVrF23laxdv5WuXbOVrVVv5WvVWvhbbytdqtvK1+Fa+5txUXQpvvsR/UJT4ow6vzoC/a4s/6vA751FwQ5V4TyT+SIR+T44A35PxCt4TiT86od+TI8H3ZJqC90Tij1jo9+Qo8D2pU/CeSPxRDP2eHA2+J4sVvCcSf2RDvyffA9+TzxW8JxJ/tEO/J8eA70nX03f+90Tij4Do96QP+J70VvCeSPxREf2eBMD3JKTgPZH4IyX6PQmC70l/Be+JxB890e9JKfieXKDgPZH4Iyr6PSkD35OBCt4TiT/Kot+TcvA9GazgPZH4Iy/6PQmB78nDCt4TiT8ao9+TMPiePK3gPZH4IzT6PYmA78krCt4TiT9qo9+TCvA9eUfBeyLxR3L0exIF35M0+J64/9vjbwr/8dn9td9u5Wu/28rXbtrK127eytdu2crXbt3K127bytcGb+Vrt2/la0O28rU7tvK1O7fytbu28rW7t/K1e7bytXu38rWhW/nafVv52v1b+doDW/na77fytT9s5Wt/3MrXHtzK1/60la89tJWvPbyVrz2yla89upWvPbaVrw3bytce38rXhhe+5lzeNRkM14bDVVWhmqpoIBSJlIeisVAoEq4oLTPLKRSLhiJlgUhFWU0oVFsdq4pVBGuipdFYpKoqXFoWDYbDC9t98zsM/zdeNFwTL4vVBMJVwfKK6lAoXlEVj5fHQ/FIjVmmZTXBQFkkEKguLauuqTLjl4bLzbIMRsujNbFwPFrt/NGn89+b23l1+hx3i0PgKqojtWXBWNxMNRwPhSuisepYadj8hPLSivKaeKw0EK2tqCivrQ1G4uFAWVUoFKgoLY/XRsPmR8bK3YfA+fVvR37ZvXw7//6b07j+uJrrj0H3veiMe0th3LbwvZj33ovAvf0T+N4eD473aGGtFMNrpQ+4VsLgWukH3N/xr4+eiAV/A66734LvqXvd+V3Da07HvI+41/Aa1xpuD6/hHLyG8941DPSEn8I9YRrcE8ge84xQj+kL9ph+YI85FewxvwV7zO/A93QN2GPWCvWYta4eUwL3mCzcY3Jwj8l7ewzQs34G96w6uGdNg3sW2QNfE+qBA8AeeB7YA08De+DvwB54E/iergV74DqhHrjO1QN3gXtgBu6BWbgH5uAemPf2QKCnng/31MVwT62De+o0uKeSPXq+UI8+H+zRl4A9+nSwR98E9uibwfd0Hdij1wv16PWuHt2piO3RabhHZ+AenYV7dA7u0XlvjwZ6/s/hnv853PMXwz2/Du750+CeT2bIIqEMuRTMkIFghvQHM+RmMENuAd/T9WCGbBDKkA2uDOnivfd8vscpOEPScIZk4AzJwhmSgzMk780QIJMugDPJ/XcnRCZ9DmfSYjiT6uBMmgZnEplxm4QybhCYcTeBGXcGmHG3gBl3K/iebgAzbqNQxm10Zdyu3nvP53uchDMuBWdcGs64DJxxWTjjcnDG5b0ZB2TmL+DM7A1nJpnBz8AZ/BqcwfPhDF4EZ/AmOIOdDxeXyOAhYAYPBTP4TDCDbwUz+DbwPd0IZvAmoQze5Mrg7t57z+d7nIAzOAlncArO4DScwRk4g7NwBufgDM57MxjI9AvhTA/Bmd4bznSSEV6DGWE+zAiLYEbYBDOCk+kkI/QWYoQHQUYYBjLCAJARbgMZYTB5z4GM8JkQI3zmYoTdvfeez/e4BWaEBMwISZgRUjAjpGFGyMCMkIUZIQczQt7LCABzXAQzR3+YOUIwc/SGmYNkmPkwwyyCGWYTzDAOc0yDmYNkmLAQw4wBGeYpkGHOAhlmMMgwt4Pv6Wcgw3wuxDCfuximh/fe8/keN8MM0wIzTAJmmCTMMCmYYdIww2RghsnCDJODGSbvZRiAiS6GmegCmIn6w0wUgpmoN8xEJGMtghlrE8xYDhPVwUw0DWYikrHOFGKssSBjTQYZ62yQsW4HGWsI+J5+DjLWF0KM9YWLsfby3ns+3+MmmLGaYcZqgRkrATNWEmasFMxYaZixMjBjZWHGysGMlfcyFsBsl8DMNhBmtgtgZusPM1sIZrbeMLORDLgJZkCH2RbDzFYHM9s0mNlIBrxIiAFfBRlwKsiA54AMOARkwDvA9/QLkAG/FGLAL10M2NN77/l8jxthBmyCGbAZZsAWmAETMAMmYQZMwQyYhhkwAzNgFmbAHMyAeS8DAkxZBTPlYJgpB8JMeQHMlP1hpgzBTNkbZkqSUR2m/BxmysUwU9bBTDkNZkqSUa8TYtTZIKPOAxn1XJBR7wAZ9U7wPf0SZNSvhBj1Kxej7uO993y+xw0wozbCjNoEM2ozzKgtMKMmYEZNwoyaghk1DTNqBmbULMyoOZhR815GBZi3Gmbeh2HmHQwz70CYeS+Ambc/zLwhmHl7w8xLMnRvmKHDMEOfCTP0RTBDXwcz9F1CDF0PMnQSZOjvgwx9J8jQd4Hv6VcgQxf1l2FoZ9zNDL2f997z+R7XwwzdADN0I8zQTTBDN8MM3QIzdAJm6CTM0CmYodMwQ2dghs7CDJ2DGTrvZWiAyWMwkz8NM/nDMJMPhpl8IMzkF8BM3h9m8hDM5L1hJicZPwwz/pkw418EM/51MOPfBTP+cCHGXwgy/hKQ8X8AMv5dIOPfDb6nbi73y/ithBi/lYvxD/Deez7f4zqY8ethxm+AGb8RZvwmmPGbYcZvgRk/ATN+Emb8FMz4aZjxMzDjZ2HGz8GMn/cyPvDMUAM/M7wCPzM8DT8zPAw/MwyGnxkGws8MF8DPDP3hZ4YQ/MzQG35mIJ9BzoSfQS6Cn0Gug59B7oKfQYbDzyDjhJ5BVoPPIJvAZ5DzwGeQu8FnkHvA97QV+AzSWugZpLXrGaS3997z+R4vgJ9B6uBnkHr4GaQBfgZphJ9BmuBnkGb4GaQFfgZJwM8gSfgZJAU/g6ThZ5AM/AyShZ9BcvAzSN77DAI808ThZ5p34GeaV+BnmqfhZ5qH4WeawfAzzUD4meYC+JmmP/xME4KfaXrDzzTkM9JF8DPSdfAz0l3wM9Jw+BlpHPyMNFXoGalVMfeMVFLM5ccPwWeke8BnpHvB97Q1+IzURugZqY3rGelg773n8z2e39rzjOTTzw/afrNGKH0L4GeuOviZqx5+5mqAn7ka4WeuJviZqxl+5mqBn7kS8DNXEn7mSsHPXGn4mSsDP3Nl4WeuHPzMlfc+cwHPcLXwM1wafoZ7B36GewV+hnsafoZ7GH6GGww/ww2En+EugJ/h+sPPcCH4Ga43/AxHPhNeBz8T3gU/Ew6HnwnHwc+EUwvPhPQzXFfwGa4H+Az3I/AZ7l7wGW4o+J62AZ/h2nLPcGH3M1xbwf/O5TzD/QR+hhsPP8ORz1x18DNXPfzM1QA/czXCz1xN8DNXM/zM1QI/cyXgZ64k/MyVgp+50vAzVwZ+5srCz1w5+JkrDz9zPQo/cz0DP3O9Bj9zzYefuRbBz1yb4Gcu5xlpIPyMdAH8jNQffkYKwc9IveFnJPKZ6y74mWs4/Mw1Dn7mmlp45mpbGG/zuH6fH4aCzw/3gfNtCz4/tOv//3+O27vczw/tBP9Wx3l++Cn8/DANfn4geb8O5v16mPcbYN5vhHm/Ceb9Zpj3W2DeT8C8n4R5PwXzfhrm/QzM+1mY93Mw7z8D8/5rMO/Ph3l/Ecz7m2Ded/h8MMznA2E+vwDm8/4wn4dgPu8N8znJ+8Nh3h8H8/7UAu/TfH4fyOf3g/NtB/J5eyE+by/4eVkOn/8M5vM6mM/Ph/n85zCfXwDz+S9gPr8Q5vOLYD6/GObzS2A+r4L5vBrm8xjM5zUwn8dhPid5+jWYp+fDPL0I5ulNME87/PswzL+DYf4dCPPvBTD/9of5NwTzb2+Yf0meHgfz9NQCT9P8ez/Ivw+A820P8m+xEP8W95c7c8Hh3/Nh/l0M8+/PYf69AObfX8D8eyHMvxfB/HsxzL+XwPxbBfNvNcy/MZh/a2D+jcP8S/LqfJhXF8G8ugnmVYcvn4b58mGYLwfDfDkQ5ssLYL7sD/NlCObL3jBfkrw6tcCrNF8+APLl78F+VQzyZYkQX5b0lzt31uHLn8N8+TnMlxfAfPkLmC8vhPnyIpgvL4b58hKYL6tgvqyG+TIG82UNzJdxmC9JHlwE8+AmmAcdfnsF5renYX57GOa3wTC/DYT57QKY3/rD/BaC+a03zG8OD9L89nuQ3/4A9pcSkN86CPFbBxe/7eV5Xwh+uwDmt66ns/z2C5jfLoT57SKY3y6G+e0SmN+qYH6rhvktBvNbDcxvcZjfSN7aBPOWw0fvwHz0CsxHT8N89DDMR4NhPhoI89EFMB/1h/koBPNRbwE++gPIR38E+0EHkI92EeKjXVx81MPzvhB89AuYj3rDfHQhzEcXwXx0McxHl8B8VAXzUTXMRzGYj2pgPorDfETyjMMfaZg/3oH54xWYP56G+eNhmD8Gw/wxEOaPC2D+6A/zR0iAP/4I8seD4PrdBeSPjkL80dHFH7t73heCPy6E+SME88dFMH9cDPPHJTB/VMH8UQ3zRwzmjxqYP+Iwf5C80BvmhTDMC2fCvHARzAvXwbxwF8wLw2FeGAfzwtQCL9D5/iCY738C11tHMN87CeV7J1e+d/e8L0S+XwTne3843y+G8/0SON+r4HyvhvM9Bud7DZzvcTjfyTwOw3l8JpzHF8F5fB2cx3fBeTwczuNxcB7/f+x9BXQcSdK0ZFkmGWRmZpZk2ZaZUWZmkpmZQWZmZpmZmZmZmZmZ6c+506xze7vidm+z+7a+33ovnqsnIrNromqiRrJgd/B5LH1+jhE8P8cKvj7CC56fESw6PyOw89PTsC4S52dt4fOzuvD5WUf4/KwrfH7WEz4/A4TPz/rC52cD4fNT8rwrLnze1RI+79oKn3cDhM+7KcLn3XLh82538HknfT6NFTyfxgnu5wiC51NEi86niOx8imhYF4nzqY7w+dRS+HyqK3w+1RM+nwKEz6f6wudTA+HzSfI8qSV8nrQVPk8GCJ8nU4TPk+XC58nu4PNEOv/HCeb/eMn/fxfM/0gW5X8klv/hDesikf91hfO/t3D+1xPO/wDh/K8vnP8NhPNfMq/bCuf1AOG8niKc18uF83p3cF5L5+t4wXydILhfIgnmq6dF+erJ8jWci3y+1hPO13HC+RognK/1hfO1gXC+SubhAOE8nCKch8uF83B3cB5K59cEwfyaKLi+noL5Fdmi/IrM8iuMBfkVIJxfC4Tzq75wfjUQzi/JvJkinDfLhfNmd3DeSOfDRMF8mCS4HpEF8yGKRfkQheVDKAvyob5wPmwWzocGwvkg+XpeLvx63h38epZ+/U0SfP1NFvQviuDrL6pFr7+o7PUX0oLXXwPh198x4def5Otld/DrRXp/Txbc31MEn29Uwf0dzaL9HY3t7xBC6+Kcs2N/NywsNm9vx/527J+/OM+ABnie3lME5yi5To7XSejgtTJ+uBo88Pp7H94F5DzwMpmuVO+GlvX2/vfrwultpOBxdFrPGISYhFiE2IQ4hLiEeIT4hASEhIREhMSEJISkRYMbOV9ojkZhDI/FMHkspsljsUwei23yWByTx+KaPBbP5LH4Jo8lMHksocljiUweS2zyWBKTx5IW/fmJr/PDU3JhDZv774Za9KJSB5eXdwyhXo7nGFOk17/9ivX3e/k4wzX23+3l+zOo4/y9Xl489OP+nV4+vz9A4v33vbyMh1H8/7JXloZ/PNgS/He9/MwOyYT/TS8/8wM30V/vlVV1eCf+q72yqt8IJPlrvXzQm4qkmr4RKPjrjYDpG4FktJ7JCSkIKQmpCKkJaQhpCekI6QkZCBkJXgRvgo/xjUAyk0MwucljKUweS2nyWCqTx1KbPJbG5LG0Jo+lM3ksvcljGUwey2jymJfJY94mj/nY8EagoOAbgWSCbwSSC74RSCH4RiCl4BuBVIJvBFILvhFII/hGIK3gG4F0gm8E0gu+Ecgg+EYgo+AbAS/BNwLegm8EfDR9I1Do1xsB0zcCmWg9fQmZCVkIWQl+hGyE7IQchJyEXITchDyO9SfkM74RyGRyCPracAgWEjwEMwkegr6Ch2BmwUMwi+AhmFXwEPQTPASzCR6C2QUPwRyCh2BOwUMwl+AhmFvwEMwjeAjmFTwE82l6CBb+dQiaHoL5aT0LEAoSChEKE4oQihKKEYoT/AklCCUJpQilCWWKGiYpfbgVFjzc8gsebgUED7eCgodbIcHDrbDg4VZE8HArKni4FRM83IoLHm7+godbCcHDraTg4VZK8HArLXi4ldH0cCvy63AzPdzK0nqWI5QnVCBUJFQiVCZUIVQlVCNUJ9Qg1CTUItS2+nArIni4lRU83MoJHm7lBQ+3CoKHW0XBw62S4OFWWfBwqyJ4uFUVPNyqCR5u1QUPtxqCh1tNwcOtluDhVlvTw63or8PN9HCrQ+tZl1CPEECoT2hAaEhoRGhMaEJoSmhGaE5oQWhp9eFWVPBwqyN4uNUVPNzqCR5uAYKHW33Bw62B4OHWUPBwayR4uDUWPNyaCB5uTQUPt2aCh1tzwcOtheDh1lLTw63Yr8PN9HBrRevZmtCG0JbQjtCe0IHQkdCJ0JnQhdCV0I3QndDD6sOtmODh1krwcGsteLi1ETzc2goebu0ED7f2godbB8HDraPg4dZJ8HDrLHi4dRE83LoKHm7dBA+37oKHWw9ND7fivw4308OtJ61nL0IgoTehD6EvoR+hP2EAYSBhEGEwYQhhKGGY1YdbccHDrafg4dZL8HALFDzcegsebn0ED7e+godbP8HDrb/g4TZA8HAbKHi4DRI83AYLHm5DBA+3oYKH2zBNDzf/X4eb6eE2nNZzBGEkYRRhNGEMYSxhHGE8YQJhImESYTJhCmGq1Yebv+DhNlzwcBsheLiNFDzcRgkebqMFD7cxgofbWMHDbZzg4TZe8HCbIHi4TRQ83CYJHm6TBQ+3KYKH21RND7cSvw4308NtGq3ndMIMwkxCEGEWYTZhDmEuYR5hPmEBYSFhEWGx1YdbCcHDbZrg4TZd8HCbIXi4zRQ83IIED7dZgofbbMHDbY7g4TZX8HCbJ3i4zRc83BYIHm4LBQ+3RYKH22JND7eSvw4308NtCa3nUsIywnLCCsJKwirCasIawlrCOsJ6wgbCRsImqw+3koKH2xLBw22p4OG2TPBwWy54uK0QPNxWCh5uqwQPt9WCh9sawcNtreDhtk7wcFsveLhtEDzcNgoebps0PdxK/TrcTA+3zbSeWwhbCdsI2wk7CDsJuwi7CXsIewn7CPsJBwgHrT7cSgkebpsFD7ctgofbVsHDbZvg4bZd8HDbIXi47RQ83HYJHm67BQ+3PYKH217Bw22f4OG2X/BwOyB4uB3U9HAr/etwMz3cDtF6HiYcIRwlHCMcJ5wgnCScIpwmnCGcJZwjnCdcsPpwKy14uB0SPNwOCx5uRwQPt6OCh9sxwcPtuODhdkLwcDspeLidEjzcTgsebmcED7ezgofbOcHD7bzg4XZB08OtzK/DzfRwu0jreYlwmXCFcJVwjXCdcINwk3CLcJtwh3CXcI9w3+rDrYzg4XZR8HC7JHi4XRY83K4IHm5XBQ+3a4KH23XBw+2G4OF2U/BwuyV4uN0WPNzuCB5udwUPt3uCh9t9TQ+3sr8ON9PD7QGt50PCI8JjwhPCU8IzwnPCC8JLwivCa8IbwlvCO6sPt7KCh9sDwcPtoeDh9kjwcHsseLg9ETzcngoebs8ED7fngofbC8HD7aXg4fZK8HB7LXi4vRE83N4KHm7vND3cyv063EwPt/e0nh8IHwmfCJ8JXwhfCd8I3wk/HAdZMaojhCC4EUIWM0xS+nArJ3i4vRc83D4IHm4fBQ+3T4KH22fBw+2L4OH2VfBw+yZ4uH0XPNx+CB5ujhftX+6lONxci8kdbiGKyR1ubsXkDreQxfQ83Mr/OtxMDzd3Ws9QhNCEMISwhHAED0J4QgRCREIkgichMiEKIarVh1t5wcPNvZjc4RZKqJfjOYYW6fVvv8IUkzvcwhaTO9zCFZM73DyKyR1u4YvJHW4RiskdbhGLyR1ukQQPN0/Bwy2y4OEWRfBwi6rp4Vbh1+FmerhFo/WMTohBiEmIRYhNiEOIS4hHiE9IQEhISERITEhSzMXwx3KLmfyxXJPHYpo8Fsvksdgmj8UxeSyuyWPxTB6Lb/JYApPHEpo8lsjkscQmjyUpZv2fAqogeOhHEzz0owse+jEED/2Ygod+LMFDP7bgoR9H8NCPK3joxxM89OMLHvoJBA/9hIKHfiLBQz+x4KGfpJg1h2cIQzb+3TwLnVwuZ32L6vGcQwk+50yaPGd3wefso8lzDin4nL01ec4egs/ZS5PnHE7wOWfU5DmHFXzOGTR5zmEEn3N6TZ5zJMHnnE6T5xxR8Dmn1eQ5RxB8zmk0ec7hBZ9zak2ec1TB55xKk+ccRfA5p9TkOUcWfM4pNHnOnoLPObkmzzmm4HNOpslzjiH4nJNq8pyjCz7nJJo852iCzzmxJs85ruBzTqTJc44j+JwTavKcYws+5wSaPOdYgs85vibPOaHgc46nyXNOIPic42rynOMLPuc4mjzneILPObYmzzmp4HOOpclzTiL4nGNq8pwTCz7nGJo850SCzzm6Rc/ZVfg5Zxabp4+l88wi56evlfPMqsm6+8nNM7OV88wmN09vK+eZXW6ePlbOM4cmr6OccvPMZOU8c4nNM4ulr6PcmryO8ojN09fPynnmFZunXxYr55lPbn9aeh7ll9uf2aycZwG5eVq67gXl5lnfynkWEptnJkv3Z2G5eVqan0Vs8tPr7314F7XpfbLX3/vwLib3E/Q+Vs6zuCbz9NdkniU0mWdJTeZZSpN5ltZknmU0mWdZTeZZTpN5ltdknhU0mWdFTeZZSZN5VtZknlU0mWdVTeZZTZN5VtdknjU0mWdNTeZZS5N51tZknnU0mWddTeZZT5N5Bmgyz/qazLOBJvNsqMk8G2kyz8aazLOJJvNsqsk8m2kyz+aazLOFJvNsqck8W2kyz9aazLONJvNsq8k822kyz/aazLODJvPsqMk8O2kyz86azLOLJvPsqsk8u2kyz+6azLOHJvPsqck8e2kyz0BN5tlbk3n20WSefTWZZz9N5tlfk3kO0GSeAzWZ5yBN5jlYk3kO0WSeQzWZ5zBN5jlck3mO0GSeIzWZ5yhN5jlak3mO0WSeYzWZ5zhN5jlek3lO0GSeEzWZ5yRN5jlZk3lO0WSeUzWZ5zRN5jldk3nO0GSeMzWZZ5Am85ylyTxnazLPOZrMc64m85ynyTznazLPBZrMc6Em81ykyTwXazLPJZrMc6km81ymyTyXazLPFZrMc6Um81ylyTxXazLPNZrMc60m81ynyTzXazLPDZrMc6Mm89ykyTw3azLPLZrMc6sm89ymyTy3azLPHZrMc6cm89ylyTx3azLPPZrMc68m89ynyTz3azLPA5rM86Am8zykyTwPazLPI5rM86gm8zymyTyPazLPE5rM86Qm8zylyTxPazLPM5rM86wm8zynyTzPazLPC5rM86Im87ykyTwvazLPK5rM86om87ymyTyvazLPG5rM86Ym87ylyTxvazLPO5rM864m87ynyTzvazLPB5rM86Em83ykyTwfazLPJ5rM86km83ymyTyfazLPF5rM86Um83ylyTxfazLPN5rM860m83ynyTzfazLPD5rM86Mm8/ykyTw/azLPL5rM86sm8/ymyTy/azLPH5rM06WYHvN01WSeITSZp5sm8wypyTzdNZlnKE3mGVqTeYbRZJ5hNZlnOE3m6aHJPMNrMs8ImswzoibzjKTJPD01mWdkTeYZRZN5RhWYZ8PgZlbOM1oxsV5wnn/Xg6T/7Ty9vTIbH3LMLQohJJurJ+F78Hh90p/jKOxxxxy+s7pkdJ2ckIKQstjPx50fbtJ7SrBXMsH9mcqiPSTtXzTBXskF/UutiX+nQ8j1SiHoXxpB/8yyIVWxnxmQmo3TsHFKQzakpet0hPSEDDZkwxnBtUkruDYZNdnbZwX9Syfon5cm/p0T9C+9oH/eFmdDRpYBXmzszcYZDNngQ9eZCL6EzDZkw3nBtfERXJssmuztC4L+ZRL0L6sm/l0U9M9X0D8/i7MhC8uArGzsx8aZDdmQja6zE3IQctqQDZcE1yab4Nrk0mRvXxb0L7ugf7k18e+KoH85BP3LY3E25GIZkJuN87BxTkM25KXrfIT8hAI2ZMNVwbXJK7g2BTXZ29cE/csn6F8hTfy7LuhffkH/ClucDQVZBhRi48JsXMCQDUXouiihGKG4DdlwQ3Btigiujb8me/umoH9FBf0roYl/twT9KyboX0mLs8GfZUAJNi7JxsUN2VCKrksTyhDK2pANtwXXppTg2pTTZG/fEfSvtKB/5TXx766gf2UE/atgcTaUYxlQno0rsHFZQzZUpOtKhMqEKjZkwz3BtakouDZVNdnb9wX9qyToXzVN/Hsg6F9lQf+qW5wNVVkGVGPj6mxcxZANNei6JqEWobYN2fBQcG1qCK5NHU329iNB/2oK+ldXE/8eC/pXS9C/ehZnQx2WAXXZuB4b1zZkQwBd1yc0IDS0IRueCK5NgODaNNJkbz8V9K++oH+NNfHvmaB/DQT9a2JxNjRiGdCYjZuwcUNDNjSl62aE5oQWNmTDc8G1aSq4Ni012dsvBP1rJuhfK038eynoX3NB/1pbnA0tWQa0YuPWbNzCkA1t6LotoR2hvQ3Z8EpwbdoIrk0HTfb2a0H/2gr611ET/94I+tdO0L9OFmdDB5YBHdm4Exu3N2RDZ7ruQuhK6GZDNrwVXJvOgmvTXZO9/U7Qvy6C/vXQxL/3gv51FfSvp8XZ0J1lQA827snG3QzZ0IuuAwm9CX1syIYPgmvTS3Bt+mqytz8K+hco6F8/Tfz7JOhfb0H/+lucDX1ZBvRj4/5s3MeQDQPoeiBhEGGwDdnwWXBtBgiuzRBN9vYXQf8GCvo3VBP/vgr6N0jQv2EWZ8MQlgFD2XgYGw82ZMNwuh5BGEkYZUM2fBNcm+GCazNak739XdC/EYL+jdHEvx+C/o0U9G+sxdkwmmXAGDYey8ajDNkwjq7HEyYQJtqQDY6GUr3GCa7NJE32tqugf+MF/ZusiX8hBP2bIOjfFIuzYRLLgMlsPIWNJxqyYSpdTyNMJ8ywIRvcBNdmquDazNRkb4cU9G+aoH9BmvjnLujfdEH/ZlmcDTNZBgSx8Sw2nmHIhtl0PYcwlzDPhmwIJbg2swXXZr4mezu0oH9zBP1boIl/YQT9myvo30KLs2E+y4AFbLyQjecZsmERXS8mLCEstSEbwgquzSLBtVmmyd4OJ+jfYkH/lmvin4egf0sE/VthcTYsYxmwnI1XsPFSQzaspOtVhNWENTZkQ3jBtVkpuDZrNdnbEQT9WyXo3zpN/Iso6N9qQf/WW5wNa1kGrGPj9Wy8xpANG+h6I2ETYbMN2RBJcG02CK7NFk32tqegfxsF/duqiX+RBf3bJOjfNouzYQvLgK1svI2NNxuyYTtd7yDsJOyyIRuiCK7NdsG12a3J3o4q6N8OQf/2aOJfNEH/dgr6t9fibNjNMmAPG+9l412GbNhH1/sJBwgHbciG6IJrs09wbQ5psrdjCPq3X9C/w5r4F1PQvwOC/h2xOBsOsQw4zMZH2PigIRuO0vUxwnHCCRuyIZbg2hwVXJuTmuzt2IL+HRP075Qm/sUR9O+4oH+nLc6GkywDTrHxaTY+YciGM3R9lnCOcN6GbIgruDZnBNfmgiZ7O56gf2cF/buoiX/xBf07J+jfJYuz4QLLgItsfImNzxuy4TJdXyFcJVyzIRsSCK7NZcG1ua7J3k4o6N8VQf9uaOJfIkH/rgr6d9PibLjOMuAGG99k42uGbLhF17cJdwh3bciGxIJrc0twbe5psreTCPp3W9C/+5r4l1TQvzuC/j2wOBvusQy4z8YP2PiuIRse0vUjwmPCExuyIZng2jwUXJunmuzt5IL+PRL075km/qUQ9O+xoH/PLc6GpywDnrHxczZ+YsiGF3T9kvCK8NqGbEgpuDYvBNfmjSZ7O5Wgfy8F/XuriX+pBf17JejfO4uz4Q3LgLds/I6NXxuy4T1dfyB8JHyyIRvSCK7Ne8G1+azJ3k4r6N8HQf++aOJfOkH/Pgr699XibPjMMuALG39l40+GbPjmuCb8ILgUtz4b0guuzTfBtXEtrsfeziDo33dB/0Jo4l9GQf9+CPrnVtzabHDsb2cGhGBjNzZ2Kf77bAhJ1+6EUITQNmSDl+DahCwutzZhNNnb3oL+uQv6F1YT/3wE/Qsl6F84i7MhDMuAsGwcjo1DG7LBg67DEyIQItqQDZkE18ZDcG0iabK3fQX9Cy/on6cm/mUW9C+CoH+RLc6GSCwDPNk4MhtHNGRDFLqOSohGiG5DNmQRXJsogmsTQ5O9nVXQv6iC/sXUxD8/Qf+iCfoXy+JsiMEyICYbx2Lj6IZsiE3XcQhxCfFsyIZsgmsTW3Bt4muyt7ML+hdH0L8EmviXQ9C/uIL+JbQ4G+KzDEjAxgnZOJ4hGxLRdWJCEkJSG7Ihp+DaJBJcm2Sa7O1cgv4lFvQvuSb+5Rb0L4mgfykszoZkLAOSs3EKNk5qyIaUdJ2KkJqQxoZsyCO4NikF1yatJns7r6B/qQT9S6eJf/kE/Ust6F96i7MhLcuAdGycno3TGLIhA11nJHgRvG3IhvyCa5NBcG18NNnbBQT9yyjoXyZN/Cso6J+XoH++FmeDD8uATGzsy8behmzITNdZCFkJfjZkQyHBtcksuDbZNNnbhQX9yyLoX3ZN/Csi6F9WQf9yWJwN2VgGZGfjHGzsZ8iGnHSdi5CbkMeGbCgquDY5BdcmryZ7u5igf7kE/cuniX/FBf3LLehffouzIS/LgHxsnJ+N8xiyoQBdFyQUIhS2IRv8BdemgODaFNFkb5cQ9K+goH9FNfGvpKB/hQT9K2ZxNhRhGVCUjYuxcWFDNhSna39CCUJJG7KhlODaFBdcm1Ka7O3Sgv75C/pXWhP/ygj6V0LQvzIWZ0MplgGl2bgMG5c0ZENZui5HKE+oYEM2lBVcm7KCa1NRk71dTtC/coL+VdLEv/KC/pUX9K+yxdlQkWVAJTauzMYVDNlQha6rEqoRqtuQDRUE16aK4NrU0GRvVxT0r6qgfzU18a+SoH/VBP2rZXE21GAZUJONa7FxdUM21KbrOoS6hHo2ZENlwbWpLbg2AZrs7SqC/tUR9K++Jv5VFfSvrqB/DSzOhgCWAfXZuAEb1zNkQ0O6bkRoTGhiQzZUE1ybhoJr01STvV1d0L9Ggv4108S/GoL+NRb0r7nF2dCUZUAzNm7Oxk0M2dCCrlsSWhFa25ANNQXXpoXg2rTRZG/XEvSvpaB/bTXxr7agf60E/WtncTa0YRnQlo3bsXFrQza0p+sOhI6ETjZkQx3BtWkvuDadNdnbdQX96yDoXxdN/Ksn6F9HQf+6WpwNnVkGdGHjrmzcyZAN3ei6O6EHoacN2RAguDbdBNemlyZ7u76gf90F/QvUxL8Ggv71EPSvt8XZ0ItlQCAb92bjnoZs6EPXfQn9CP1tyIaGgmvTR3BtBmiytxsJ+tdX0L+BmvjXWNC/foL+DbI4GwawDBjIxoPYuL8hGwbT9RDCUMIwG7KhieDaDBZcm+Ga7O2mgv4NEfRvhCb+NRP0b6igfyMtzobhLANGsPFINh5myIZRdD2aMIYw1oZsaC64NqME12acJnu7haB/owX9G6+Jfy0F/Rsj6N8Ei7NhHMuA8Ww8gY3HGrJhIl1PIkwmTLEhG1oJrs1EwbWZqsnebi3o3yRB/6Zp4l8bQf8mC/o33eJsmMoyYBobT2fjKYZsmEHXMwlBhFk2ZENbwbWZIbg2szXZ2+0E/Zsp6N8cTfxrL+hfkKB/cy3OhtksA+aw8Vw2nmXIhnl0PZ+wgLDQhmzoILg28wTXZpEme7ujoH/zBf1brIl/nQT9WyDo3xKLs2ERy4DFbLyEjRcasmEpXS8jLCessCEbOguuzVLBtVmpyd7uIujfMkH/VmniX1dB/5YL+rfa4mxYyTJgFRuvZuMVhmxYQ9drCesI623Ihm6Ca7NGcG02aLK3uwv6t1bQv42a+NdD0L91gv5tsjgbNrAM2MjGm9h4vSEbNtP1FsJWwjYbsqGn4NpsFlyb7Zrs7V6C/m0R9G+HJv4FCvq3VdC/nRZnw3aWATvYeCcbbzNkwy663k3YQ9hrQzb0FlybXYJrs0+Tvd1H0L/dgv7t18S/voL+7RH074DF2bCPZcB+Nj7AxnsN2XCQrg8RDhOO2JAN/QTX5qDg2hzVZG/3F/TvkKB/xzTxb4Cgf4cF/TtucTYcZRlwjI2Ps/ERQzacoOuThFOE0zZkw0DBtTkhuDZnNNnbgwT9Oyno31lN/Bss6N8pQf/OWZwNZ1gGnGXjc2x82pAN5+n6AuEi4ZIN2TBEcG3OC67NZU329lBB/y4I+ndFE/+GCfp3UdC/qxZnw2WWAVfY+CobXzJkwzW6vk64QbhpQzYMF1yba4Jrc0uTvT1C0L/rgv7d1sS/kYL+3RD0747F2XCLZcBtNr7DxjcN2XCXru8R7hMe2JANowTX5q7g2jzUZG+PFvTvnqB/jzTxb4ygf/cF/XtscTY8ZBnwiI0fs/EDQzY8oeunhGeE5zZkw1jBtXkiuDYvNNnb4wT9eyro30tN/Bsv6N8zQf9eWZwNL1gGvGTjV2z83JANr+n6DeEt4Z0N2TBBcG1eC67Ne0329kRB/94I+vdBE/8mCfr3VtC/jxZnw3uWAR/Y+CMbvzNkwye6/kz4QvhqQzZMFlybT4Jr802TvT1F0L/Pgv5918S/qYL+fRH074fF2fCNZcB3Nv7Bxl8N2eDiT48TQhDc/K3PhmmCa+OYu9TahPTXY29PF/TPVdA/d038myHoXwhB/0L5W5sNjv3tzAB3Ng7Fxm7+v8+G0HQdhhCWEM6GbJgpuDahBdfGQ5O9HSToXxhB/8Jr4t8sQf/CCvoXweJs8GAZEJ6NI7BxOEM2RKTrSARPQmQbsmG24NpEFFybKJrs7TmC/kUS9C+qJv7NFfTPU9C/aBZnQxSWAVHZOBobRzZkQ3S6jkGISYhlQzbME1yb6IJrE1uTvT1f0L8Ygv7F0cS/BYL+xRT0L67F2RCbZUAcNo7LxrEM2RCPruMTEhAS2pANCwXXJp7g2iTSZG8vEvQvvqB/iTXxb7GgfwkE/UticTYkYhmQmI2TsHFCQzYkpetkhOSEFDZkwxLBtUkquDYpNdnbSwX9SyboXypN/Fsm6F9yQf9SW5wNKVkGpGLj1GycwpANaeg6LSEdIb0N2bBccG3SCK5NBk329gpB/9IK+pdRE/9WCvqXTtA/L4uzIQPLgIxs7MXG6Q3Z4E3XPoRMBF8bsmGV4Np4C65NZk329mpB/3wE/cuiiX9rBP3LJOhfVouzITPLgCxsnJWNfQ3Z4EfX2QjZCTlsyIa1gmvjJ7g2OTXZ2+sE/csm6F8uTfxbL+hfdkH/clucDTlZBuRi49xsnMOQDXkccyLkI+S3IRs2CK5NHsG1KaDJ3t4o6F9eQf8KauLfJkH/8gn6V8jibCjAMqAgGxdi4/yGbChM10UIRQnFbMiGzYJrU1hwbYprsre3CPpXRNA/f0382yroX1FB/0pYnA3FWQb4s3EJNi5myIaSdF2KUJpQxoZs2Ca4NiUF16asJnt7u6B/pQT9K6eJfzsE/Sst6F95i7OhLMuAcmxcno3LGLKhAl1XJFQiVLYhG3YKrk0FwbWposne3iXoX0VB/6pq4t9uQf8qCfpXzeJsqMIyoCobV2PjyoZsqE7XNQg1CbVsyIY9gmtTXXBtamuyt/cK+ldD0L86mvi3T9C/moL+1bU4G2qzDKjDxnXZuJYhG+rRdQChPqGBDdmwX3Bt6gmuTUNN9vYBQf8CBP1rpIl/BwX9qy/oX2OLs6Ehy4BGbNyYjRsYsqEJXTclNCM0tyEbDgmuTRPBtWmhyd4+LOhfU0H/Wmri3xFB/5oJ+tfK4mxowTKgJRu3YuPmhmxoTddtCG0J7WzIhqOCa9NacG3aa7K3jwn610bQvw6a+Hdc0L+2gv51tDgb2rMM6MDGHdm4nSEbOtF1Z0IXQlcbsuGE4Np0Elybbprs7ZOC/nUW9K+7Jv6dEvSvi6B/PSzOhm4sA7qzcQ827mrIhp503YsQSOgdnA0OhGbrwj9chdfK1cWaPeUiO88GFvb2cWXeRgwe96G16EvoR+hPGEAYSBhEGEwYQhhKGEYYThhBGOkf3MQt+F9HE1fDY31NHutn8lh/k8cGmDw20OSxQSaPDTZ5bIjJY0NNHhtm8thwk8dGmDw20v/npnV+RJJdwN9t4r8bEn0EAqdBw39/9JXrVb+fXK9s/eV6eQ8Q69XAe6BYrwDvQWK9/LwHi/Xy8h4i1auBl/dQqV4BXt7DpHr5eXkPl+pFr+0RQr0aUK+Rwm+gpA/jEC4/zwwXwUy7G2Tt8/6783O8CbLied8LsubNTUjhde8p+CZ3lNwe9xbcN966rEUIwf032t+a1/A/9XUh/fod89/vZR/jA2afsI1in5iNZuO1SX+Oxxg+YRtL1+MI4wkT/H/fT3IfOt4/97UgE+8H/bPPAsdzHmvB834QpEf+jBXMjImCZ4HgvvHWZS3cBPffJH9rXsP/pNeFWcZOZLk66U9m7GS6nkKYSphmYcY6+vazIGseBv2zM9bxnCdb8LwfBenxup4s+FqcLpixgvvGW5e1CCm4/2b4W/Ma/ie9LswydjrL1Rl/MmNn0nUQYRZhtoUZ6+7y82vZLoJr/Tjon52xjuc804Ln/SRIj9f1TMHX4hzBjBXcN966rIW74P6b62/Na/if9Lowy9g5LFfn/smMnUfX8wkLCAstzNhQLj//b9BFcK2fBv2zM9bxnOdZ8LyfBenxup4n+FpcJJixgvvGW5e1CCW4/xb7W/Ma/ie9LswydhHL1cV/MmOX0PVSwjLCcgsz1vENOQMtyJrnQf/sjHU85yUWPO8XQXq8rpcIvhZXCGas4L7x1mUtQgvuv5X+1ryG/0mvC7OMXcFydeWfzNhVdL2asIaw1sKMDePy83vXXATX+mXQPztjHc95lQXP+1WQHq/rVYKvxXWCGSu4b7x1WYswgvtvvb81r+F/0uvCLGPXsVxd/yczdgNdbyRsImy2MGPDuvz8XmAXwbV+HfTPzljHc95gwfN+E6TH63qD4Gtxi2DGCu4bb13WIqzg/tvqb81r+J/0ujDL2C0sV7f+yYzdRtfbCTsIOy3M2HAuP3+2wkVwrd8G/bMz1vGct1nwvN8F6fG63ib4WtwlmLGC+8Zbl7UIJ7j/dvtb8xr+J70uzDJ2F8vV3X8yY/fQ9V7CPsJ+CzPWw+Xnz6q5CK71+6B/dsY6nvMeC573hyA9Xtd7BF+LBwQzVnDfeOuyFh6C+++gvzWv4X/S68IsYw+wXD34JzP2EF0fJhwhHLUwY8O7/PzZXxfBtf4Y9M/OWMdzPmTB8/4UpMfr+pDga/GYYMYK7htvXdYivOD+O+5vzWv4n/S6MMvYYyxXj//JjD1B1ycJpwinLczYCC4/f5eCi+Bafw76Z2es4zmfsOB5fwnS43V9QvC1eEYwYwX3jbcuaxFBcP+d9bfmNfxPel2YZewZlqtn/2TGnqPr84QLhIsWZqzjl/qMsCBrvgb9szPW8ZzPWfC8vwXp8bo+J/havCSYsYL7xluXtYgouP8u+1vzGv4nvS7MMvYSy9XLfzJjr9D1VcI1wnULM9bxO71GWpA134P+2RnreM5XLHjeP4L0eF1fEXwt3hDMWMF9463LWkQS3H83/a15Df+TXhdmGXuD5erNP5mxt+j6NuEO4a7/H3/BbwjDOv9dDyT3zC1/a/a2+O/y+m/n6RPwh4fM1j2yy8/1jcLGUdn4nmHd79P1A8JDwiN/63+xczTBXvcFX9+PLdpD0v5FF+z1QNC/J5r4F0Ow10NB/576W3smPGbnwBM2fsrGjwzZ8IyunxNeEF7akA0xBXs9E1ybV5rs7ViCvZ5Lfk+mJv7FFuz1QtC/NxZnwyuWAa/Z+A0bvzRkw1u6fkd4T/hgQzbEEez1VvL/EDXZ23EFe70T9O+TJv7FE+z1XvL/VyzOho8sAz6x8Wc2/mDIhi90/ZXwzfG4DdkQX7DXF8G1+aHJ3k4g2OuroH8uJfTwL6Fgr2+C/rmWsDYbfrAMcKyVc+zKxt8N2RCCODdCSIJ7CeuzIZFgrxAl5NYmlCZ7O7FgLzdB/0Jr4l8SwV4hBf0LY3E2hGIZEJqNw7Cxe4nfZ0NYug5H8CCEtyEbkgr2Ciu4NhE02dvJBHuFE/Qvoib+JRfs5SHoXySLsyECy4CIbByJjcMbssGTriMTohCi2pANKQR7eQquTTRN9nZKwV6RBf2Lrol/qQR7RRH0L4bF2RCNZUB0No7BxlEN2RCTrmMRYhPi2JANqQV7xRRcm7ia7O00gr1iCfoXTxP/0gr2ii3oX3yLsyEuy4B4bByfjeMYsiEBXSckJCIktiEb0gn2SiC4Nkk02dvpBXslFPQvqSb+ZRDslUjQv2QWZ0MSlgFJ2TgZGyc2ZENyuk5BSElIZUM2ZBTslVxwbVJrsre9BHulEPQvjSb+eQv2SinoX1qLsyE1y4A0bJyWjVMZsiEdXacnZCBktCEbfAR7pRNcGy9N9nYmwV7pBf3z1sQ/X8FeGQT987E4G7xYBnizsQ8bZzRkQya69iVkJmSxIRsyS75OBNcmqyZ7O4vk60TQPz9N/MsquZcF/ctmcTZkZRngx8bZ2DiLIRuy03UOQk5CLhuywU+wV3bBtcmtyd7OJtgrh6B/eTTxL7tgr5yC/uW1OBtyswzIw8Z52TiXIRvy0XV+QgFCQRuyIYdgr3yCa1NIk72dU7BXfkH/CmviXy7BXgUE/SticTYUYhlQmI2LsHFBQzYUpetihOIEfxuyIbdgr6KCa1NCk72dR7BXMUH/SmriX17BXsUF/StlcTaUYBlQko1LsbG/IRtK03UZQllCORuyIZ9gr9KCa1Nek72dX7BXGUH/KmjiXwHBXmUF/atocTaUZxlQgY0rsnE5QzZUouvKhCqEqjZkQ0HBXpUE16aaJnu7kGCvyoL+VdfEv8KCvaoI+lfD4myoxjKgOhvXYOOqhmyoSde1CLUJdWzIhiKCvWoKrk1dTfZ2UcFetQT9q6eJf8UEe9UW9C/A4myoyzKgHhsHsHEdQzbUp+sGhIaERjZkQ3HBXvUF16axJnvbX7BXA0H/mmjiXwnBXg0F/WtqcTY0ZhnQhI2bsnEjQzY0o+vmhBaEljZkQ0nBXs0E16aVJnu7lGCv5oL+tdbEv9KCvVoI+tfG4mxoxTKgNRu3YeOWhmxoS9ftCO0JHWzIhjKCvdoKrk1HTfZ2WcFe7QT966SJf+UEe7UX9K+zxdnQkWVAJzbuzMYdDNnQha67EroRutuQDeUFe3URXJsemuztCoK9ugr611MT/yoK9uom6F8vi7OhB8uAnmzci427G7IhkK57E/oQ+tqQDZUEewUKrk0/TfZ2ZcFevQX966+Jf1UEe/UR9G+AxdnQj2VAfzYewMZ9DdkwkK4HEQYThtiQDVUFew0UXJuhmuztaoK9Bgn6N0wT/6oL9hos6N9wi7NhKMuAYWw8nI2HGLJhBF2PJIwijLYhG2oI9hohuDZjNNnbNQV7jRT0b6wm/tUS7DVK0L9xFmfDGJYBY9l4HBuPNmTDeLqeQJhImGRDNtQW7DVecG0ma7K36wj2miDo3xRN/Ksr2GuioH9TLc6GySwDprDxVDaeZMiGaXQ9nTCDMNOGbKgn2Gua4NoEabK3AwR7TRf0b5Ym/tUX7DVD0L/ZFmdDEMuAWWw8m41nGrJhDl3PJcwjzLchGxoI9pojuDYLNNnbDQV7zRX0b6Em/jUS7DVP0L9FFmfDApYBC9l4ERvPN2TDYrpeQlhKWGZDNjQW7LVYcG2Wa7K3mwj2WiLo3wpN/Gsq2GupoH8rLc6G5SwDVrDxSjZeZsiGVXS9mrCGsNaGbGgm2GuV4Nqs02RvNxfstVrQv/Wa+NdCsNcaQf82WJwN61gGrGfjDWy81pANG+l6E2EzYYsN2dBSsNdGwbXZqsnebiXYa5Ogf9s08a+1YK/Ngv5ttzgbtrIM2MbG29l4iyEbdtD1TsIuwm4bsqGNYK8dgmuzR5O93Vaw105B//Zq4l87wV67BP3bZ3E27GEZsJeN97HxbkM27KfrA4SDhEM2ZEN7wV77BdfmsCZ7u4NgrwOC/h3RxL+Ogr0OCvp31OJsOMwy4AgbH2XjQ4ZsOEbXxwknCCdtyIZOgr2OCa7NKU32dmfBXscF/TutiX9dBHudEPTvjMXZcIplwGk2PsPGJw3ZcJauzxHOEy7YkA1dBXudFVybi5rs7W6Cvc4J+ndJE/+6C/Y6L+jfZYuz4SLLgEtsfJmNLxiy4QpdXyVcI1y3IRt6CPa6Irg2NzTZ2z0Fe10V9O+mJv71Eux1TdC/WxZnww2WATfZ+BYbXzdkw226vkO4S7hnQzYECva6Lbg29zXZ270Fe90R9O+BJv71Eex1V9C/hxZnw32WAQ/Y+CEb3zNkwyO6fkx4QnhqQzb0Fez1SHBtnmmyt/sJ9nos6N9zTfzrL9jriaB/LyzOhmcsA56z8Qs2fmrIhpd0/YrwmvDGhmwYINjrpeDavNVkbw8U7PVK0L93mvg3SLDXa0H/3lucDW9ZBrxj4/ds/MaQDR/o+iPhE+GzDdkwWLDXB8G1+aLJ3h4i2OujoH9fNfFvqGCvT4L+fbM4G76wDPjKxt/Y+LMhG77T9Q+CS0niS1qfDcMEe30XXJsQJfXY28MFe/0Q9M9NE/9GCPZyKSnnX8iS1maDY387M8CNjUOysWvJ32eDO12HIoQmhLEhG0YK9nIXXJuwmuztUYK9Qgn6F04T/0YL9got6J+HxdkQlmVAODb2YOMwhmwIT9cRCBEJkWzIhjGCvcILro2nJnt7rGCvCIL+RdbEv3GCvSIK+hfF4mzwZBkQmY2jsHEkQzZEpetohOiEGDZkw3jBXlEF1yamJnt7gmCvaIL+xdLEv4mCvaIL+hfb4myIyTIgFhvHZuMYhmyIQ9dxCfEI8W3IhkmCveIIrk0CTfb2ZMFecQX9S6iJf1MEe8UT9C+RxdmQgGVAQjZOxMbxDdmQmK6TEJISktmQDVMFeyUWXJvkmuztaYK9kgj6l0IT/6YL9koq6F9Ki7MhOcuAFGycko2TGbIhFV2nJqQhpLUhG2YI9koluDbpNNnbMwV7pRb0L70m/gUJ9koj6F8Gi7MhHcuA9GycgY3TGrIhI117ERx/qNLHhmyYJdgro+DaZNJkb88W7OUl6J+vJv7NEezlLehfZouzIRPLAF82zszGPoZsyELXWQl+hGw2ZMNcwV5ZBNcmuyZ7e55gr6yC/uXQxL/5gr38BP3LaXE2ZGcZkIONc7JxNkM25KLr3IQ8jrnZkA0LBHvlElybfJrs7YWCvXIL+pdfE/8WCfbKI+hfAYuzIR/LgPxsXICN8xqyoSBdFyIUJhSxIRsWC/YqKLg2RTXZ20sEexUS9K+YJv4tFexVWNC/4hZnQ1GWAcXYuDgbFzFkgz9dlyCUJJSyIRuWCfbyF1yb0prs7eWCvUoI+ldGE/9WCPYqKehfWYuzoTTLgDJsXJaNSxmyoRxdlydUIFS0IRtWCvYqJ7g2lTTZ26sEe5UX9K+yJv6tFuxVQdC/KhZnQyWWAZXZuAobVzRkQ1W6rkaoTqhhQzasEexVVXBtamqyt9cK9qom6F8tTfxbJ9iruqB/tS3OhposA2qxcW02rmHIhjp0XZdQjxBgQzasF+xVR3Bt6muytzcI9qor6F8DTfzbKNirnqB/DS3OhvosAxqwcUM2DjBkQyO6bkxoQmhqQzZsEuzVSHBtmmmytzcL9mos6F9zTfzbItiriaB/LSzOhmYsA5qzcQs2bmrIhpZ03YrQmtDGhmzYKtirpeDatNVkb28T7NVK0L92mvi3XbBXa0H/2lucDW1ZBrRj4/Zs3MaQDR3ouiOhE6GzDdmwQ7BXB8G16aLJ3t4p2KujoH9dNfFvl2CvToL+dbM4G7qwDOjKxt3YuLMhG7rTdQ9CT0IvG7Jht2Cv7oJrE6jJ3t4j2KuHoH+9NfFvr2CvnoL+9bE4GwJZBvRm4z5s3MuQDX3puh+hP2GADdmwT7BXX8G1GajJ3t4v2KufoH+DNPHvgGCv/oL+DbY4GwayDBjExoPZeIAhG4bQ9VDCMMJwG7LhoGCvIYJrM0KTvX1IsNdQQf9GauLfYcFewwT9G2VxNoxgGTCSjUex8XBDNoym6zGEsYRxNmTDEcFeowXXZrwme/uoYK8xgv5N0MS/Y4K9xgr6N9HibBjPMmACG09k43GGbJhE15MJUwhTbciG44K9JgmuzTRN9vYJwV6TBf2brol/JwV7TRH0b4bF2TCNZcB0Np7BxlMN2TCTroMIswizbciGU4K9ZgquzRxN9vZpwV5Bgv7N1cS/M4K9Zgn6N8/ibJjDMmAuG89j49mGbJhP1wsICwmLbMiGs4K95guuzWJN9vY5wV4LBP1bool/5wV7LRT0b6nF2bCYZcASNl7KxosM2bCMrpcTVhBW2pANFwR7LRNcm1Wa7O2Lgr2WC/q3WhP/Lgn2WiHo3xqLs2EVy4DVbLyGjVcasmEtXa8jrCdssCEbLgv2Wiu4Nhs12dtXBHutE/Rvkyb+XRXstV7Qv80WZ8NGlgGb2HgzG28wZMMWut5K2EbYbkM2XBPstUVwbXZosrevC/baKujfTk38uyHYa5ugf7sszoYdLAN2svEuNt5uyIbddL2HsJewz4ZsuCnYa7fg2uzXZG/fEuy1R9C/A5r4d1uw115B/w5anA37WQYcYOODbLzPkA2H6Pow4QjhqA3ZcEew1yHBtTmmyd6+K9jrsKB/xzXx755gryOC/p2wOBuOsQw4zsYn2PioIRtO0vUpwmnCGRuy4b5gr5OCa3NWk739QLDXKUH/zmni30PBXqcF/TtvcTacZRlwjo3Ps/EZQzZcoOuLhEuEyzZkwyPBXhcE1+aKJnv7sWCvi4L+XdXEvyeCvS4J+nfN4my4wjLgKhtfY+PLhmy4Ttc3CDcJt2zIhqeCva4Lrs1tTfb2M8FeNwT9u6OJf88Fe90U9O+uxdlwm2XAHTa+y8a3DNlwj67vEx4QHtqQDS8Ee90TXJtHmuztl4K97gv691gT/14J9nog6N8Ti7PhEcuAx2z8hI0fGrLhKV0/IzwnvLAhG14L9noquDYvNdnbbwR7PRP075Um/r0V7PVc0L/XFmfDS5YBr9j4NRu/MGTDG7p+S3hHeG9DNryTfJ0Irs0HTfb2e8nXiaB/HzXx74PkXhb075PF2fCBZcBHNv7Exu8N2fCZrr8QvhK+2ZANHwV7fRZcm++a7O1Pgr2+CPr3QxP/Pgv2+iron0spa7PhO8uAH2zsuK9z/M2QDa7EhSC4EUKWsj4bvgj2ci0ltzbupfTY218Fe4UQ9C+UJv59E+zlJuhfaIuzwZ1lQCg2Ds3GIUv9PhvC0HVYQjiChw3Z8F2wVxjBtQmvyd7+IdgrrKB/ETTxz/EikOoVTtC/iBZnQ3iWARHYOCIbexiyIRJdexIiE6LYkA2ugmsTSXBtomqyt0MI+ucp6F80TfxzE/QvsqB/0S3OhqgsA6KxcXQ2jmLIhhh0HZMQixDbhmwIKbg2MQTXJo4me9td0L+Ygv7F1cS/UIL+xRL0L57F2RCHZUBcNo7HxrEN2RCfrhMQEhIS2ZANoQXXJr7g2iTWZG+HEfQvgaB/STTxL6ygfwkF/UtqcTYkZhmQhI2TsnEiQzYko+vkhBSElDZkQzjBtUkmuDapNNnbHoL+JRf0L7Um/oUX9C+FoH9pLM6GVCwDUrNxGjZOaciGtHSdjpCekMGGbIgguDZpBdcmoyZ7O6Kgf+kE/fPSxL9Igv6lF/TP2+JsyMgywIuNvdk4gyEbfOg6E8GXkNmGbPAUXBsfwbXJosnejizoXyZB/7Jq4l8UQf98Bf3zszgbsrAMyMrGfmyc2ZAN2eg6OyEHIacN2RBVcG2yCa5NLk32djRB/7IL+pdbE/+iC/qXQ9C/PBZnQy6WAbnZOA8b5zRkQ166zkfITyhgQzbEEFybvIJrU1CTvR1T0L98gv4V0sS/WIL+5Rf0r7DF2VCQZUAhNi7MxgUM2VCErosSihGK25ANsQXXpojg2vhrsrfjCPpXVNC/Epr4F1fQv2KC/pW0OBv8WQaUYOOSbFzckA2l6Lo0oQyhrA3ZEE9wbUoJrk05TfZ2fEH/Sgv6V14T/xII+ldG0L8KFmdDOZYB5dm4AhuXNWRDRbquRKhMqGJDNiQUXJuKgmtTVZO9nUjQv0qC/lXTxL/Egv5VFvSvusXZUJVlQDU2rs7GVQzZUIOuaxJqEWrbkA1JBNemhuDa1NFkbycV9K+moH91NfEvmaB/tQT9q2dxNtRhGVCXjeuxcW1DNgTQdX1CA0JDG7IhueDaBAiuTSNN9nYKQf/qC/rXWBP/Ugr610DQvyYWZ0MjlgGN2bgJGzc0ZENTum5GaE5oYUM2pBJcm6aCa9NSk72dWtC/ZoL+tdLEvzSC/jUX9K+1xdnQkmVAKzZuzcYtDNnQhq7bEtoR2tuQDWkF16aN4Np00GRvpxP0r62gfx018S+9oH/tBP3rZHE2dGAZ0JGNO7Fxe0M2dKbrLoSuhG42ZEMGwbXpLLg23TXZ2xkF/esi6F8PTfzzEvSvq6B/PS3Ohu4sA3qwcU827mbIhl50HUjoTehjQzZ4C65NL8G16avJ3vYR9C9Q0L9+mviXSdC/3oL+9bc4G/qyDOjHxv3ZuI8hGwbQ9UDCIMJgG7LBV3BtBgiuzRBN9nZmQf8GCvo3VBP/sgj6N0jQv2EWZ8MQlgFD2XgYGw82ZMNwuh5BGEkYZUM2ZBVcm+GCazNak73tJ+jfCEH/xmjiXzZB/0YK+jfW4mwYzTJgDBuPZeNRhmwYR9fjCRMIE23IhuyCazNOcG0mabK3cwj6N17Qv8ma+JdT0L8Jgv5NsTgbJrEMmMzGU9h4oiEbptL1NMJ0wgwbsiGX4NpMFVybmZrs7dyC/k0T9C9IE//yCPo3XdC/WRZnw0yWAUFsPIuNZxiyYTZdzyHMJcyzIRvyCq7NbMG1ma/J3s4n6N8cQf8WaOJffkH/5gr6t9DibJjPMmABGy9k43mGbFhE14sJSwhLbciGAoJrs0hwbZZpsrcLCvq3WNC/5Zr4V0jQvyWC/q2wOBuWsQxYzsYr2HipIRtW0vUqwmrCGhuyobDg2qwUXJu1muztIoL+rRL0b50m/hUV9G+1oH/rLc6GtSwD1rHxejZeY8iGDXS9kbCJsNmGbCgmuDYbBNdmiyZ7u7igfxsF/duqiX/+gv5tEvRvm8XZsIVlwFY23sbGmw3ZsJ2udxB2EnbZkA0lBNdmu+Da7NZkb5cU9G+HoH97NPGvlKB/OwX922txNuxmGbCHjfey8S5DNuyj6/2EA4SDNmRDacG12Se4Noc02dtlBP3bL+jfYU38Kyvo3wFB/45YnA2HWAYcZuMjbHzQkA1H6foY4TjhhA3ZUE5wbY4Krs1JTfZ2eUH/jgn6d0oT/yoI+ndc0L/TFmfDSZYBp9j4NBufMGTDGbo+SzhHOG9DNlQUXJszgmtzQZO9XUnQv7OC/l3UxL/Kgv6dE/TvksXZcIFlwEU2vsTG5w3ZcJmurxCuEq7ZkA1VBNfmsuDaXNdkb1cV9O+KoH83NPGvmqB/VwX9u2lxNlxnGXCDjW+y8TVDNtyi69uEO4S7NmRDdcG1uSW4Nvc02ds1BP27LejffU38qyno3x1B/x5YnA33WAbcZ+MHbHzXkA0P6foR4THhiQ3ZUEtwbR4Krs1TTfZ2bUH/Hgn690wT/+oI+vdY0L/nFmfDU5YBz9j4ORs/MWTDC7p+SXhFeG1DNtQVXJsXgmvzRpO9XU/Qv5eC/r3VxL8AQf9eCfr3zuJseMMy4C0bv2Pj14ZseE/XHwgfCZ9syIb6gmvzXnBtPmuytxsI+vdB0L8vmvjXUNC/j4L+fbU4Gz6zDPjCxl/Z+JMhG745rgk/CC6lrc+GRoJr801wbVxL67G3Gwv6913QvxCa+NdE0L8fgv65lbY2Gxz725kBIdjYjY1dSv8+G0LStTshFCG0DdnQVHBtQpaWW5swmuztZoL+uQv6F1YT/5oL+hdK0L9wFmdDGJYBYdk4HBuHNmSDB12HJ0QgRLQhG1oIro2H4NpE0mRvtxT0L7ygf56a+NdK0L8Igv5FtjgbIrEM8GTjyGwc0ZANUeg6KiEaIboN2dBacG2iCK5NDE32dhtB/6IK+hdTE//aCvoXTdC/WBZnQwyWATHZOBYbRzdkQ2y6jkOIS4hnQza0E1yb2IJrE1+Tvd1e0L84gv4l0MS/DoL+xRX0L6HF2RCfZUACNk7IxvEM2ZCIrhMTkhCS2pANHQXXJpHg2iTTZG93EvQvsaB/yTXxr7Ogf0kE/UthcTYkYxmQnI1TsHFSQzakpOtUhNSENDZkQxfBtUkpuDZpNdnbXQX9SyXoXzpN/Osm6F9qQf/SW5wNaVkGpGPj9GycxpANGeg6I8GL4G1DNnQXXJsMgmvjo8ne7iHoX0ZB/zJp4l9PQf+8BP3ztTgbfFgGZGJjXzb2NmRDZrrOQshK8LMhG3oJrk1mwbXJpsneDhT0L4ugf9k18a+3oH9ZBf3LYXE2ZGMZkJ2Nc7CxnyEbctJ1LkJuQh4bsqGP4NrkFFybvJrs7b6C/uUS9C+fJv71E/Qvt6B/+S3OhrwsA/KxcX42zmPIhgJ0XZBQiFDYhmzoL7g2BQTXpogme3uAoH8FBf0rqol/AwX9KyToXzGLs6EIy4CibFyMjQsbsqE4XfsTShBK2pANgwTXprjg2pTSZG8PFvTPX9C/0pr4N0TQvxKC/pWxOBtKsQwozcZl2LikIRvK0nU5QnlCBRuyYajg2pQVXJuKmuztYYL+lRP0r5Im/g0X9K+8oH+VLc6GiiwDKrFxZTauYMiGKnRdlVCNUN2GbBghuDZVBNemhiZ7e6Sgf1UF/aupiX+jBP2rJuhfLYuzoQbLgJpsXIuNqxuyoTZd1yHUJdSzIRtGC65NbcG1CdBkb48R9K+OoH/1NfFvrKB/dQX9a2BxNgSwDKjPxg3YuJ4hGxrSdSNCY0ITG7JhnODaNBRcm6aa7O3xgv41EvSvmSb+TRD0r7Ggf80tzoamLAOasXFzNm5iyIYWdN2S0IrQ2oZsmCi4Ni0E16aNJnt7kqB/LQX9a6uJf5MF/Wsl6F87i7OhDcuAtmzcjo1bG7KhPV13IHQkdLIhG6YIrk17wbXprMneniroXwdB/7po4t80Qf86CvrX1eJs6MwyoAsbd2XjToZs6EbX3Qk9CD1tyIbpgmvTTXBtemmyt2cI+tdd0L9ATfybKehfD0H/elucDb1YBgSycW827mnIhj503ZfQj9DfhmwIElybPoJrM0CTvT1L0L++gv4N1MS/2YL+9RP0b5DF2TCAZcBANh7Exv0N2TCYrocQhhKG2ZANcwTXZrDg2gzXZG/PFfRviKB/IzTxb56gf0MF/RtpcTYMZxkwgo1HsvEwQzaMouvRhDGEsTZkw3zBtRkluDbjNNnbCwT9Gy3o33hN/Fso6N8YQf8mWJwN41gGjGfjCWw81pANE+l6EmEyYYoN2bBIcG0mCq7NVE329mJB/yYJ+jdNE/+WCPo3WdC/6RZnw1SWAdPYeDobTzFkwwy6nkkIIsyyIRuWCq7NDMG1ma3J3l4m6N9MQf/maOLfckH/ggT9m2txNsxmGTCHjeey8SxDNsyj6/mEBYSFNmTDCsG1mSe4Nos02dsrBf2bL+jfYk38WyXo3wJB/5ZYnA2LWAYsZuMlbLzQkA1L6XoZYTlhhQ3ZsFpwbZYKrs1KTfb2GkH/lgn6t0oT/9YK+rdc0L/VFmfDSpYBq9h4NRuvMGTDGrpeS1hHWG9DNqwTXJs1gmuzQZO9vV7Qv7WC/m3UxL8Ngv6tE/Rvk8XZsIFlwEY23sTG6w3ZsJmutxC2ErbZkA0bBddms+DabNdkb28S9G+LoH87NPFvs6B/WwX922lxNmxnGbCDjXey8TZDNuyi692EPYS9NmTDFsG12SW4Nvs02dtbBf3bLejffk382ybo3x5B/w5YnA37WAbsZ+MDbLzXkA0H6foQ4TDhiA3ZsF1wbQ4Krs1RTfb2DkH/Dgn6d0wT/3YK+ndY0L/jFmfDUZYBx9j4OBsfMWTDCbo+SThFOG1DNuwSXJsTgmtzRpO9vVvQv5OC/p3VxL89gv6dEvTvnMXZcIZlwFk2PsfGpw3ZcJ6uLxAuEi7ZkA17BdfmvODaXNZkb+8T9O+CoH9XNPFvv6B/FwX9u2pxNlxmGXCFja+y8SVDNlyj6+uEG4SbNmTDAcG1uSa4Nrc02dsHBf27LujfbU38OyTo3w1B/+5YnA23WAbcZuM7bHzTkA136foe4T7hgQ3ZcFhwbe4Krs1DTfb2EUH/7gn690gT/44K+ndf0L/HFmfDQ5YBj9j4MRs/MGTDE7p+SnhGeG5DNhwTXJsngmvzQpO9fVzQv6eC/r3UxL8Tgv49E/TvlcXZ8IJlwEs2fsXGzw3Z8Jqu3xDeEt7ZkA0nBdfmteDavNdkb58S9O+NoH8fNPHvtKB/bwX9+2hxNrxnGfCBjT+y8TtDNnyi68+EL4SvNmTDGcG1+SS4Nt802dtnBf37LOjfd038Oyfo3xdB/35YnA3fWAZ8Z+MfbPzVkA0uZehxQgiCWxnrs+G84No45i61NiHL6LG3Lwj65yron7sm/l0U9C+EoH+hylibDY797cwAdzYOxcZuZX6fDaHpOgwhLCGcDdlwSXBtQguujYcme/uyoH9hBP0Lr4l/VwT9CyvoXwSLs8GDZUB4No7AxuEM2RCRriMRPAmRbciGq4JrE1FwbaJosrevCfoXSdC/qJr4d13QP09B/6JZnA1RWAZEZeNobBzZkA3R6ToGISYhlg3ZcENwbaILrk1sTfb2TUH/Ygj6F0cT/24J+hdT0L+4FmdDbJYBcdg4LhvHMmRDPLqOT0hASGhDNtwWXJt4gmuTSJO9fUfQv/iC/iXWxL+7gv4lEPQvicXZkIhlQGI2TsLGCQ3ZkJSukxGSE1LYkA33BNcmqeDapNRkb98X9C+ZoH+pNPHvgaB/yQX9S21xNqRkGZCKjVOzcQpDNqSh67SEdIT0NmTDQ8G1SSO4Nhk02duPBP1LK+hfRk38eyzoXzpB/7wszoYMLAMysrEXG6c3ZIM3XfsQMhF8bciGJ4Jr4y24Npk12dtPBf3zEfQviyb+PRP0L5Ogf1ktzobMLAOysHFWNvY1ZIMfXWcjZCfksCEbnguujZ/g2uTUZG+/EPQvm6B/uTTx76Wgf9kF/cttcTbkZBmQi41zs3EOQzbkccyJkI+Q34ZseCW4NnkE16aAJnv7taB/eQX9K6iJf28E/csn6F8hi7OhAMuAgmxciI3zG7KhMF0XIRQlFLMhG94Krk1hwbUprsnefifoXxFB//w18e+9oH9FBf0rYXE2FGcZ4M/GJdi4mCEbStJ1KUJpQhkbsuGD4NqUFFybsprs7Y+C/pUS9K+cJv59EvSvtKB/5S3OhrIsA8qxcXk2LmPIhgp0XZFQiVDZhmz4LLg2FQTXpoome/uLoH8VBf2rqol/XwX9qyToXzWLs6EKy4CqbFyNjSsbsqE6Xdcg1CTUsiEbvgmuTXXBtamtyd7+LuhfDUH/6mji3w9B/2oK+lfX4myozTKgDhvXZeNahmyoR9cBhPqEBjZkg0sIuV71BNemoSZ721XQvwBB/xpp4l8IQf/qC/rX2OJsaMgyoBEbN2bjBoZsaELXTQnNCM1tyAY3wbVpIrg2LTTZ2yEF/Wsq6F9LTfxzF/SvmaB/rSzOhhYsA1qycSs2bm7IhtZ03YbQltDOhmwIJbg2rQXXpr0mezu0oH9tBP3roIl/YQT9ayvoX0eLs6E9y4AObNyRjdsZsqETXXcmdCF0tSEbwgquTSfBtemmyd4OJ+hfZ0H/umvin4egf10E/ethcTZ0YxnQnY17sHFXQzb0pOtehEBCbxuyIbzg2vQUXJs+muztCIL+9RL0r68m/kUU9C9Q0L9+FmdDH5YBfdm4Hxv3NmRDf7oeQBhIGGRDNkQSXJv+gmszWJO97Sno3wBB/4Zo4l9kQf8GCvo31OJsGMwyYAgbD2XjQYZsGEbXwwkjCCNtyIYogmszTHBtRmmyt6MK+jdc0L/RmvgXTdC/EYL+jbE4G0axDBjNxmPYeKQhG8bS9TjCeMIEG7IhuuDajBVcm4ma7O0Ygv6NE/Rvkib+xRT0b7ygf5MtzoaJLAMmsfFkNp5gyIYpdD2VMI0w3YZsiCW4NlME12aGJns7tqB/UwX9m6mJf3EE/Zsm6F+Qxdkwg2XATDYOYuPphmyYRdezCXMIc23IhriCazNLcG3mabK34wn6N1vQv/ma+Bdf0L85gv4tsDgb5rEMmM/GC9h4riEbFtL1IsJiwhIbsiGB4NosFFybpZrs7YSC/i0S9G+ZJv4lEvRvsaB/yy3OhqUsA5ax8XI2XmLIhhV0vZKwirDahmxILLg2KwTXZo0mezuJoH8rBf1bq4l/SQX9WyXo3zqLs2ENy4C1bLyOjVcbsmE9XW8gbCRssiEbkgmuzXrBtdmsyd5OLujfBkH/tmjiXwpB/zYK+rfV4mzYzDJgCxtvZeNNhmzYRtfbCTsIO23IhpSCa7NNcG12abK3Uwn6t13Qv92a+Jda0L8dgv7tsTgbdrEM2M3Ge9h4pyEb9tL1PsJ+wgEbsiGN4NrsFVybg5rs7bSC/u0T9O+QJv6lE/Rvv6B/hy3OhoMsAw6x8WE2PmDIhiN0fZRwjHDchmxIL7g2RwTX5oQmezuDoH9HBf07qYl/GQX9Oybo3ymLs+EEy4CTbHyKjY8bsuE0XZ8hnCWcsyEbvATX5rTg2pzXZG97C/p3RtC/C5r45yPo31lB/y5anA3nWQZcYOOLbHzOkA2X6Poy4Qrhqg3ZkElwbS4Jrs01Tfa2r6B/lwX9u66Jf5kF/bsi6N8Ni7PhGsuA62x8g42vGrLhJl3fItwm3LEhG7IIrs1NwbW5q8neziro3y1B/+5p4p+foH+3Bf27b3E23GUZcI+N77PxHUM2PKDrh4RHhMc2ZEM2wbV5ILg2TzTZ29kF/Xso6N9TTfzLIejfI0H/nlmcDU9YBjxl42ds/NiQDc/p+gXhJeGVDdmQU3BtnguuzWtN9nYuQf9eCPr3RhP/cgv691LQv7cWZ8NrlgFv2PgtG78yZMM7un5P+ED4aEM25BFcm3eCa/NJk72dV9C/94L+fdbEv3yC/n0Q9O+LxdnwiWXAZzb+wsYfDdnwla6/OR4j/LAhG/ILrs1XwbVxKavH3i4g6N83Qf9cNfGvoKB/3wX9C1HW2mxw7G9nBriycQg2/mHIBjfiQhLcCaHKWp8NhQTXxq2s3NqE1mRvFxb0L6Sgf2E08a+IoH/ugv6FtTgbQrMMCMPGYdk4VNnfZ0M4uvYghCdEsCEbigquTTjBtYmoyd4uJuifh6B/kTTxr7igf+EF/fO0OBsisgyIxMaebBzBkA2R6ToKISohmg3Z4C+4NpEF1ya6Jnu7hKB/UQT9i6GJfyUF/Ysq6F9Mi7MhOsuAGGwck42jGbIhFl3HJsQhxLUhG0oJrk0swbWJp8neLi3oX2xB/+Jr4l8ZQf/iCPqXwOJsiMcyID4bJ2DjuIZsSEjXiQiJCUlsyIaygmuTUHBtkmqyt8sJ+pdI0L9kmvhXXtC/xIL+Jbc4G5KyDEjGxsnZOIkhG1LQdUpCKkJqG7KhguDapBBcmzSa7O2Kgv6lFPQvrSb+VRL0L5Wgf+kszoY0LAPSsnE6Nk5tyIb0dJ2BkJHgZUM2VBZcm/SCa+Otyd6uIuhfBkH/fDTxr6qgfxkF/ctkcTZ4swzwYeNMbOxlyAZfus5MyELIakM2VBNcG1/BtfHTZG9XF/Qvs6B/2TTxr4agf1kE/ctucTb4sQzIxsbZ2TirIRty0HVOQi5Cbhuyoabg2uQQXJs8muztWoL+5RT0L68m/tUW9C+XoH/5LM6GPCwD8rJxPjbObciG/HRdgFCQUMiGbKgjuDb5BdemsCZ7u66gfwUE/SuiiX/1BP0rKOhfUYuzoTDLgCJsXJSNCxmyoRhdFyf4E0rYkA0BgmtTTHBtSmqyt+sL+ldc0L9SmvjXQNA/f0H/SlucDSVZBpRi49JsXMKQDWXouiyhHKG8DdnQUHBtygiuTQVN9nYjQf/KCvpXURP/Ggv6V07Qv0oWZ0MFlgEV2bgSG5c3ZENluq5CqEqoZkM2NBFcm8qCa1Ndk73dVNC/KoL+1dDEv2aC/lUV9K+mxdlQnWVADTauycbVDNlQi65rE+oQ6tqQDc0F16aW4NrU02RvtxD0r7agfwGa+NdS0L86gv7Vtzgb6rEMCGDj+mxc15ANDei6IaERobEN2dBKcG0aCK5NE032dmtB/xoK+tdUE//aCPrXSNC/ZhZnQxOWAU3ZuBkbNzZkQ3O6bkFoSWhlQza0FVyb5oJr01qTvd1O0L8Wgv610cS/9oL+tRT0r63F2dCaZUAbNm7Lxq0M2dCOrtsTOhA62pANHQTXpp3g2nTSZG93FPSvvaB/nTXxr5Ogfx0E/eticTZ0YhnQmY27sHFHQzZ0petuhO6EHjZkQ2fBtekquDY9NdnbXQT96yboXy9N/Osq6F93Qf8CLc6GniwDerFxIBv3MGRDb7ruQ+hL6GdDNnQTXJvegmvTX5O93V3Qvz6C/g3QxL8egv71FfRvoMXZ0J9lwAA2HsjG/QzZMIiuBxOGEIbakA09BddmkODaDNNkb/cS9G+woH/DNfEvUNC/IYL+jbA4G4axDBjOxiPYeKghG0bS9SjCaMIYG7Kht+DajBRcm7Ga7O0+gv6NEvRvnCb+9RX0b7Sgf+MtzoaxLAPGsfF4Nh5jyIYJdD2RMIkw2YZs6Ce4NhME12aKJnu7v6B/EwX9m6qJfwME/Zsk6N80i7NhCsuAqWw8jY0nG7JhOl3PIMwkBNmQDQMF12a64NrM0mRvDxL0b4agf7M18W+woH8zBf2bY3E2zGIZMJuN57BxkCEb5tL1PMJ8wgIbsmGI4NrMFVybhZrs7aGC/s0T9G+RJv4NE/RvvqB/iy3OhoUsAxax8WI2XmDIhiV0vZSwjLDchmwYLrg2SwTXZoUme3uEoH9LBf1bqYl/IwX9Wybo3yqLs2EFy4CVbLyKjZcbsmE1Xa8hrCWssyEbRgmuzWrBtVmvyd4eLejfGkH/Nmji3xhB/9YK+rfR4mxYzzJgAxtvZON1hmzYRNebCVsIW23IhrGCa7NJcG22abK3xwn6t1nQv+2a+Dde0L8tgv7tsDgbtrEM2M7GO9h4qyEbdtL1LsJuwh4bsmGC4NrsFFybvZrs7YmC/u0S9G+fJv5NEvRvt6B/+y3Ohr0sA/ax8X423mPIhgN0fZBwiHDYhmyYLLg2BwTX5ogme3uKoH8HBf07qol/UwX9OyTo3zGLs+EIy4CjbHyMjQ8bsuE4XZ8gnCScsiEbpgmuzXHBtTmtyd6eLujfCUH/zmji3wxB/04K+nfW4mw4zTLgDBufZeNThmw4R9fnCRcIF23IhpmCa3NOcG0uabK3gwT9Oy/o32VN/Jsl6N8FQf+uWJwNl1gGXGbjK2x80ZANV+n6GuE64YYN2TBbcG2uCq7NTU329hxB/64J+ndLE//mCvp3XdC/2xZnw02WAbfY+DYb3zBkwx26vku4R7hvQzbME1ybO4Jr80CTvT1f0L+7gv491MS/BYL+3RP075HF2fCAZcBDNn7ExvcN2fCYrp8QnhKe2ZANCwXX5rHg2jzXZG8vEvTviaB/LzTxb7Ggf08F/XtpcTY8Zxnwgo1fsvEzQza8ouvXhDeEtzZkwxLBtXkluDbvNNnbSwX9ey3o33tN/Fsm6N8bQf8+WJwN71gGvGfjD2z81pANH+n6E+Ez4YsN2bBccG0+Cq7NV0329gpB/z4J+vdNE/9WCvr3WdC/7xZnw1eWAd/Y+DsbfzFkww+6dilHHCFEOeuzYZXg2vwQXBu3cnrs7dWC/rmUk/MvpCb+rRH0z1XQP/dy1maDY387MyAkG7uzcYhyv8+GUHQdmhCGENaGbFgruDahBNcmnCZ7e52gf6EF/fPQxL/1gv6FEfQvvMXZEI5lgAcbh2fjsIZsiEDXEQmRCJ42ZMMGwbWJILg2kTXZ2xsF/Yso6F8UTfzbJOhfJEH/olqcDZFZBkRh46hs7GnIhmh0HZ0QgxDThmzYLLg20QTXJpYme3uLoH/RBf2LrYl/WwX9iyHoXxyLsyEWy4DYbByHjWMasiEuXccjxCcksCEbtgmuTVzBtUmoyd7eLuhfPEH/Emni3w5B/+IL+pfY4mxIyDIgERsnZuMEhmxIQtdJCckIyW3Ihp2Ca5NEcG1SaLK3dwn6l1TQv5Sa+Ldb0L9kgv6lsjgbUrAMSMnGqdg4uSEbUtN1GkJaQjobsmGP4NqkFlyb9Jrs7b2C/qUR9C+DJv7tE/QvraB/GS3OhvQsAzKwcUY2TmfIBi+69ib4EDLZkA37BdfGS3BtfDXZ2wcE/fMW9C+zJv4dFPTPR9C/LBZngy/LgMxsnIWNMxmyIStd+xGyEbLbkA2HBNcmq+Da5NBkbx8W9M9P0L+cmvh3RNC/bIL+5bI4G3KwDMjJxrnYOLshG3LTdR7HvAj5bMiGo4Jrk1twbfJrsrePCfqXR9C/Apr4d1zQv7yC/hW0OBvyswwowMYF2TifIRsK0XVhQhFCURuy4YTg2hQSXJtimuztk4L+FRb0r7jFe7sY28PF2bgIGxc17G1/ui5BKEkoZbK3QwivzVl3OT/9hf10Pvcz7j89DRG8Px2c4+FQhNCEMISwhHAED0J4QgRCREIkgichcvAaRSVEI0QnxCDEJMQixCbEIcQlxCPEJyQgJCQkIiQmJCEkJSQjJCekIKQkpCKkJqQhpCWkI6QnZCBkdPhB8Cb4OHwm+BIyE7IQshL8CNkI2Qk5CDkJuQi5CXmC1zsfIT+hAKEgoRChsGM/OfYRoRihuGMPEUoQShJKEUoTyhCCv53cpTyhAqEioRKhMqEKoSqhGqE6oQahJqEWoTahDqEuoR4hgFCf0IDQkNCI0JjQhNCU0IzQnNCC0JLQitCa0IbQltCO0J7QgdCR0InQmdCF0JXQjdCd0IPQk9CLEEjoTehD6EvoR+hPGEAYSBhEGEwYQhhKGEYYThhBGEkYRRhNGEMYSxhHGE+YQJhImESYTJhCmEqYRphOmEGYSQgizCLMJswhzCXMI8wnLCAsJCwiLCYsISwlLCMsJ6wgrCSsIqwmrCGsJawjrCdsIGwkbCJsJmwhbCVsI2wn7CDsJOwi7CbsIewl7CPsJxwgHCQcIhwmHCEcJRwjHCecIJwknCKcJpwhnCWcI5wnXCBcJFwiXCZcIVwlXCNcJ9wg3CTcItwm3CHcJdwj3Cc8IDwkPCI8JjwhPCU8IzwnvCC8JLwivCa8IbwlvCO8J3wgfCR8InwmfCF8JXxz+Xc2/iA4XvyuhBAEN0JIgjshFCE0IQwhLCEcwYMQnhCBEJEQieBJiEyIQohKiEaITohBiEmIRYhNiEOIS4hHiE9IQEhISERITEhCSEpIRkhOSEFISUhFSE1IQ0hLSEdIT8hAyEhwBJo3wYeQieBLyEzIQshK8CNkI2Qn5CDkJOQi5CbkIeQl5CPkJxQgFCQUIhQmFCEUJRQjFCf4E0oQShJKEUoTyhDKEsoRyhMqECoSKhEqE6oQqhKqEaoTahBqEmoRahPqEOoS6hECCPUJDQgNCY0IjQlNCE0JzQjNCS0ILQmtCK0JbQhtCe0I7QkdCB0JnQidCV0IXQndCN0JPQg9Cb0IgYTehD6EvoR+hP6EAYSBhEGEwYQhhKGEYYThhBGEkYRRhNGEMYSxhHGE8YQJhImESYTJhCmEqYRphOmEGYSZhCDCLMJswhzCXMI8wnzCAsJCwiLCYsISwlLCMsJywgrCSsIqwmrCGsJawjrCesIGwkbCJsJmwhbCVsI2wnbCDsJOwi7CbsIewl7CPsJ+wgHCQcIhwmHCEcJRwjHCccIJwknCKcJpwhnCWcI5wnnCBcJFwiXCZcIVwlXCNcJ1wg3CTcItwm3CHcJdwj3CfcIDwkPCI8JjwhPCU8IzwnPCC8JLwivCa8IbwlvCO8J7wgfCR8InwmfCF8JXwjfCd8IPguPgdyWEILgRQhLcCaEIoQlhCGEJ4QgehPCECISIhEgET0JkQhRCVEI0QnRCDEJMQixCbEIcQlxCPEJ8QgJCQkIiQmJCEkJSQjJCckIKQkpCKkJqQhpCWkI6QnpCBkJGghfBm+BDyETwJWQmZCFkJfgRshGyE3IQchJyEXIT8jjePxPyEfITChAKEgoRChOKEIoSihGKE/wJJQglCaUIpQllCGUJ5QjlCRUIFQmVCJUJVQhVCdUI1Qk1CDUJtQi1CXUIdQn1CAGE+oQGhIaERoTGhCaEpoRmhOaEFoSWhFaE1oQ2hLaEdoT2hA6EjoROhM6ELoSuhG6E7gTH34F3/L1xx9/MDiQ4/r6w42/kOv7Oq+PviTr+Jqbj7zo6/n6g42/gOf6Om+PvhTn+5pXj7zY5/j6Q42/cOP5Oi+PvgTj+poXj7zI4fv+/43fYO34Pu+P3fTt+Z7Xj9y47fr+v43fUOn7PquP3eTp+J6Xj9yo6fn9fEMHxe9Qcv6/L8TunHL83yfH7eRy/Y8bxe1Icv4/D8TslHL8XwfHz946fIXf8HLTj520dPzPq+LlHx8/XOX5GzPFzTo6fp3H8TIjj5xoc3z/v+B5wx/cxO75f1vE9n47vW3R8f5zje7wc36fk+H4Yx/d0OL4vwfH/347/w3X8P6Tj/7sc/2fj+H8Hx9e3HV+jdXyd0fH1LMfXZBxfV3B8/ur4HOwU4TThDOEs4RzhPOEC4SLhEuEy4QrhKuEa4TrhBuEm4RbhNuEO4S7hHuE+4QHhIeER4THhCeEp4RnhOeEF4SXhFeE14Q3hLeEd4T3hA+Ej4RPhM+EL4SvhG+E74QfB8abflRCC4EYISXAnhCKEJoQhhCWEI3gQwhMiECISIhE8CZEJUQhRCdEI0QkxCDEJsQixCXEIcQnxCPEJCQgJCYkIiQlJCEkJyQjJCSkIKQmpCKkJaQhpCekI6QkZCBkJXgRvgg8hE8GXkJmQhZCV4EfIRshOyEHISchFyE3IQ8hLyEfITyhAKEgoRChMKEIoSihGKE7wJ5QglCSUIpQmlCGUJZQjlCdUIFQkVCJUJlQhVCVUI1Qn1CDUJNQi1CbUIdQl1CMEEOoTGhAaEhoRGhOaEJoSmhGaE1oQWhJaEVoT2hDaEtoR2hM6EDoSOhE6E7oQuhK6EboTehB6EnoRAgm9CX0IfQn9CP0JAwgDCYMIgwlDCEMJwwjDCSMIIwmjCKMJYwhjCeMI4wkTCBMJkwiTCVMIUwnTCNMJMwgzCUGEWYTZhDmEuYR5hPmEBYSFhEWExYQlhKWEZYTlhBWElYRVhNWENYS1hHWE9YQNhI2ETYTNhC2ErYRthO2EHYSdhF2E3YQ9hL2EfYT9hAOEg4RDhMOEI4SjhGOE44QThJOEU4TThDOEs4RzhPOEC4SLhEuEy4QrhKuEa4TrhBuEm4RbhNuEO4S7hHuE+4QHhIeER4THhCeEp4RnhOeEF4SXhFeE14Q3hLeEd4T3hA+Ej4RPhM+EL4SvhG+E74QfBMcn/K6EEAQ3QkiCOyEUITQhDCEsIRzBgxCeEIEQkRCJ4EmITIhCiEqIRohOiEGISYhFiE2IQ4hLiEeIT0hASEhIREhMSEJISkhGSE5IQUhJSEVITUhDSEtIR0hPyEDISPAieBN8CJkIvoTMhCyErAQ/QjZCdkIOQk5CLkJuQh5CXkI+Qn5CAUJBQiFCYUIRQlFCMUJxgj+hBKEkoRShNKEMoSyhHKE8oQKhIqESoTKhCqEqoRqhOqEGoSahFqE2oQ6hLqEeIYBQn9CA0JDQiNCY0ITQlNCM0JzQgtCS0IrQmtCG0JbQjtCe0IHQkdCJ0JnQhdCV0I3QndCD0JPQixBI6E3oQ+hL6EfoTxhAGEgYRBhMGEIYShhGGE4YQRhJGEUYTRhDGEsYRxhPmECYSJhEmEyYQphKmEaYTphBmEkIIswizCbMIcwlzCPMJywgLCQsIiwmLCEsJSwjLCesIKwkrCKsJqwhrCWsI6wnbCBsJGwibCZsIWwlbCNsJ+wg7CTsIuwm7CHsJewj7CccIBwkHCIcJhwhHCUcIxwnnCCcJJwinCacIZwlnCOcJ1wgXCRcIlwmXCFcJVwjXCfcINwk3CLcJtwh3CXcI9wnPCA8JDwiPCY8ITwlPCM8J7wgvCS8IrwmvCG8JbwjvCd8IHwkfCJ8JnwhfCV8I3wn/CA4vtjnSghBcCOEJLgTQhFCE8IQwhLCETwI4QkRCBEJkQiehMiEKISohGiE6IQYhJiEWITYhDiEuIR4hPiEBISEhESExIQkhKSEZITkhBSElIRUhNSENIS0hHSE9IQMhIwEL4I3wYeQieBLyEzIQshK8CNkI2Qn5CDkJOQi5CbkcXyNlpCPkJ9QgFCQUIhQmFCEUJRQjFCc4E8oQShJKEUoTShDKEsoRyhPqECoSKhEqEyoQqhKqEaoTqhBqEmoRahNqEOoS6hHCCDUJzQgNCQ0IjQmNCE0JTQjNCe0ILQktCK0JrQhtCW0I7QndCB0JHQidCZ0IXQldCN0J/Qg9CT0IgQSehP6EPoS+hH6EwYQBhIGEQYThhCGEoYRhhNGEEYSRhFGE8YQxhLGEcYTJhAmEiYRJhOmEKYSphGmE2YQZhKCCLMIswlzCHMJ8wjzCQsICwmLCIsJSwhLCcsIywkrCCsJqwirCWsIawnrCOsJGwgbCZsImwlbCFsJ2wjbCTsIOwm7CLsJewh7CfsI+wkHCAcJhwiHCUcIRwnHCMcJJwgnCacIp93//fV0x6fUzg/n2PF/AR8j/nz8vvu//525KMG6uHdDVGMlLg8A9xhwTwD3HHAvAPcacG8A9x5wHwD3GXBfAPcdcD8AFyKUmnMDXCjAhQZcOMB5AC4i4CIBLgrgogIuBuBiAi4O4OICLgHgEgIuCeCSAi4F4FICLg3g0gIuQzAX/W6+2G0OLyjEOb9grsC3q0VWjhmQinPZQV1OwBUGPYuCuuKAqwB6VgJ1VQBXD/SsD+oaAq416NkW1LUHXE/QMxDU9QHcMNBzBKgbBbgpoOc0UDcDcAtBz8Wgbing1oOeG0HdZsDtBT33g7qDgDsNep4FdecBdxP0vA3q7gLuOej5EtS9BtxX0PM7qPvXNw0ouHCh1T3Dg7qIgIsFesYBdfEAlwL0TAXq0gDOF/TMAur8AJcf9CwI6goDrgzoWQ7UVQBcLdCzDqirB7jmoGdLUNcacF1Bz+6grifgBoGeQ0DdMMBNAD0ngbopgJsLes4HdQsBtxr0XAvq1gNuJ+i5G9TtBdxx0PMkqDsNuKug53VQdxNwj0HPp6DuOeA+gp6fQd1XwIUKo+4ZJoy6LhzgooGeMUBdLMAlAT0fR//3v0fGndi/cFDd+px7Gl3d8zmoewnq3gLuA+j5CdT9AJx7DHXP0DHUdREA5wl6RgF1sQAXF/SMD+qSAi4F6JkK1GUAXGHQsyioKwW4sqBneVBXFXA1QM9aoK4+4BqBnk1AXSvAdQFcd3C/nqCuH+AGgp6DQd1IwI0BPceBuimAmw56zgR18wC3EnBrwP3WgbotgNsOeu4EdfsBdwj0PALqTgHuLOh5HtRdBdwDwD0G93sK6l4D7h3o+QHUfQPcv76xW9EzREx1XRjAeYCeEUBdVMAlAFxicL+koC414NKBnhlAnS/gsoKe2UBdHsDlBz0LgrrigKsIuCrgftVAXR3ABYCeDUBdM8C1BD1bg7qOgOsCenYDdb0BNwxwI8H9RoO6iYCbAnpOA3WzATcP9FwA6pYBbiXouRrUbQTcHsDtB/c7COqOA+4U6HkG1F0C3FXQ8zqouwu4B6DnI1D3AnCfAfcN3O8HqHOPpebCxFL3DAfqPAEXFfSMDuriAi4B6JkI1KUAnDfgfMH9soC6nIDLA3rmA3VFAFcc9CwB6soBriLoWRnU1QRcY8A1A/drAeraAa4j6NkZ1PUEXG/Qsy+oGwy4YaDnCFA3DnAzATcb3G8uqFsMuGWg5wpQtw5wG0HPzaBuJ+D2gJ77QN0RwJ0H3CVwvyug7hbg7oKe90HdU8C9AD1fgboPgPsMen4FdSFiq7kIgPOMrb5fFFAXC3BxQc/4oC4p4FKAnqlAXQbAeYOemUBdNsDVAz3rg7qGoK4xqGsOuFagZxtQ1wlwPUHPQFA3AHCDQc+hoG404MaBnhNA3TTAzQQ9Z4G6BYDbDnruBHX7AXcI9DwC6k4B7izoeR7UXQXcDdDzFqh7ALhXgHsL7vce1H0F3A/Q0zWOui404MLFUfcMD+qiAC466BkT1MUHXCrApQX3Sw/qMgEuC+jpB+pyAy4f6FkA1BUDXAnQsxSoqwC42oCrB+5XH9Q1BVwL0LMVqOsAuM6gZ1dQFwi4vqBnf1A3FHATADcZ3G8qqJsFuLmg53xQtxRwK0DPVaBuA+A2g55bQd1uwB0D3Elwv9Og7iLgroCe10DdHcDdBz0fgrrngHsFer4BdZ8AFzKumgsdV32/sKAuEuCigJ7RQF0cwMUHPROCuuSASwV6pgF1XoDLAbjc4H55QV1hwBUDPf1BXVnAVQA9K4G6GoCrDXrWBXWNANcWcB3A/TqBuh6ACwQ9+4C6QYAbCnoOB3VjATcB9JwE6mYAbhHgloL7LQd1awG3AfTcBOp2AG436LkX1B0G3DHQ8wSoOwe4m4C7A+53D9Q9Adxz0PMlqHsPuE+g5xdQ5xpPzYWMp+4ZCtSFB1xMwMUB94sH6pIALjnomRLUpQecF+jpA+r8AJcD9MwF6goArhTgyoL7lQd1VQFXA/SsBerqA64R6NkE1LUCXFvQsz2o6wq4/oAbBO43BNSNAtxY0HM8qJsKuBmgZxComw+4RaDnElC3CnA3QM9boO4OqLsH6h4B7ino+RzUvQXcF9DzG6hzi6/mQsVX9wwD6iICLjLoGRXUxQZcPNAzAahLBrgcoGcuUFcAcIVBz6KgrhTgyoKe5UFdVcDVAD1rgbr6gGsJuDbgfu1AXRfAdQc9e4K6foAbCHoOBnUjATcG9BwH6qYAbh7gFoL7LQZ1KwG3BvRcB+q2AG476LkT1O0H3CHQ8wioOwW4q4C7Ae53C9Q9ANxj0PMpqHsNuHeg5wdQ9w1w//pF0IqeIRKo68IALirgYoD7xQJ1CQCXGPRMCupSAy4d6JkB1PkCLivomQ3U5QFcccCVBPcrDeoqAq4K6FkN1NUBXADo2QDUNQNcS9CzNajrCLjegOsH7jcA1A0D3EjQczSomwi4KaDnNFA3G3DzQM8FoG4Z4DYCbgu43zZQtwdw+0HPg6DuOOBOgZ5nQN0lwF0FPa+DuruAewG41+B+b0HdZ8B9Az1/gDr3hGouTEJ1z3CgzhNwUUHP6KAuLuBSAC41uF9aUOcNOF/QMwuoywm4PKBnPlBXBHDFQc8SoK4c4GoCrg64Xz1Q1xhwzUDPFqCuHeA6gp6dQV1PwPUGPfuCusGAGwe4ieB+k0HdTMDNBj3ngrrFgFsGeq4AdesAtxH03AzqdgLuCOCOg/udBHXnAXcJ9LwC6m4B7i7oeR/UPQXcC9DzFaj7ALgQidSceyL1/UKDugiA8wQ9o4C6WICLC3rGB3VJAZcC9EwF6jIArjroWRPU1QZ1dUFdA8A1Bj2bgrrWgOsEenYBdb0A1wf07AfqhgBuOOg5EtSNB9wk0HMKqAsC3AbQcxOo2wG43aDnXlB3GHDHQM8ToO4c4C6CnpdB3U3APQbcM3C/F6DuHeA+gp6fQd2//mCZgnNLrO7pDuo8ABcR9PQEdTEAlxhwycD9UoC6dIDLCHp6g7qsgMsOeuYEdfkBVwj0LALqSgKuCuCqg/vVBHUBgGsIejYGdS0B1wb0bAfqugCuO+jZE9T1A9xIwI0B9xsH6qYAbjroORPUzQPcQtBzMahbCbg1oOc6ULcFcPsBdwjc7wioOwW4s6DneVB3FXA3QM9boO4B4B6Dnk9B3WvAfQPcv/54puJ+IZKo68IAzgP0jADqogIuBugZC9QlAFxi0DMpqEsNOF/AZQX3ywbq8gAuP+hZENQVB1xJ0LM0qKsIuCqgZzVQVwdwzQDXEtyvNajrCLguoGc3UNcbcP1AzwGgbhjgRoKeo0HdRMDNBtw8cL8FoG4Z4FaCnqtB3UbAbQE9t4G6PYDbD3oeBHXHAXcJcFfB/a6DuruAewB6PgJ1LwD3GvR8C+o+A+4b6PkD1LknVXOegIuaVH2/6KAuLuASgJ6JQF0KwKUGPdOCOm/A+YKeWUBdTsAVAVxxcL8SoK4c4CqCnpVBXU3A1QE964G6xoBrBnq2AHXtANcTcL3B/fqCusGAGwZ6jgB14wA3EfScDOpmAm426DkX1C0G3AXQ8xKouwLqroG6W4C7C3reB3VPAfcG9HwH6r4A7jvo6ZJMXRcKcGGTqXt6gLrIgIsGesYAdfEAlwn0zAzqcgAuN+iZF9QVBlwx0NMf1JUFXAXQsxKoqwG4hoBrAu7XDNS1AVx70LMjqOsOuF6gZ29QNxBwQ0DPYaBuDOCmAy4I3G82qFsIuCWg5zJQtwZw60HPjaBuO+B2gZ57QN0hwJ0F3AVwv0ug7gbgboOed0HdY8A9Az1fgLp3gPsIen4GdS7J1ZwH4CImV9/PE9TFAFxs0DMuqEsMuGSgZwpQlw5wGUFPb1CXFXD5AVcI3K8IqCsJuDKgZzlQVwVw1UHPmqAuAHANQc/GoK4l4LoArju4X09Q1w9wA0HPwaBuJODGgJ7jQN0UwE0HPWeCunmAWwm4NeB+60DdFsBtBz13grr9gDsEeh4BdacAdxb0PA/qrgLuAeAeg/s9BXWvAfcO9PwA6r4BziWFumeIFOq6MIDzAD0jgLqogEsAuMTgfklBXWrApQM9M4A6X8BlBT2zgbo8gMsPehYEdcUBVxFwVcD9qoG6OoALAD0bgLpmgGsJerYGdR0B1wX07AbqegNuGOBGgvuNBnUTATcF9JwG6mYDbh7ouQDULQPcStBzNajbCLg9gNsP7ncQ1B0H3CnQ8wyouwS4q6DndVB3F3APQM9HoO4F4D4D7hu43w9Q555SzYVJqe4ZDtR5Ai4q6Bkd1MUFXALQMxGoSwG48qBnRVBXGdRVBXU1AVcH9KwH6hoDrhXo2QbUdQJcV9CzO6jrA7j+oOdAUDcccKNAzzGgbhLgVoCeq0DdBsBtBj23grrdgNsHeh4AdccAdxL0PA3qLgLuNuDugfs9AHXPAPcS9HwN6j4C7gvo+Q3UuaVSc6FSqXuGAXURARcbcPHA/RKAumSASwl6pgZ1GQHnA3r6grrsgMsFeuYBdYUAVwZw5cH9KoK66oCrBXrWAXUNAdcE9GwG6toArj3o2RHUdQfcQMANAfcbBurGAG486DkR1E0HXBDoORvULQTcEtBzGahbA7jtgNsF7rcH1B0C3FHQ8zioOwu4C6DnJVB3A3C3Qc+7oO4x4N4B7iO432dQ55JazbmlVvd0B3UegIsIenqCuhiAiw16xgV1iQGXDnAZwf28QV1WwGUHPXOCuvyAKwR6FgF1JQFXBvQsB+qqAC4AcA3B/RqDupaAawN6tgN1XQDXHfTsCer6AW4g6DkY1I0E3BTATQf3mwnq5gFuIei5GNStBNwa0HMdqNsCuO2g505Qtx9wpwB3FtzvPKi7CrgboOctUPcAcI9Bz6eg7jXg3oGeH0DdN8CFSaPmPNKo7xcB1EUFXAzQMxaoSwC4xKBnUlCXGnDpQM8MoM4XcHkAlx/cryCoKw64kqBnaVBXEXBVQM9qoK4O4AJAzwagrhngOgKuC7hfN1DXG3D9QM8BoG4Y4EaCnqNB3UTATQE9p4G62YA7AXqeAnVnQN05UHcJcFdBz+ug7i7gnoCez0DdG8C9Bz0/grrvgHNNq+7pllZdFxZw4UHPiKAuGuDSgp7pQV0mwGUBPf1AXW7A5QM9C4C6YoArAXqWAnUVAFcLcHXB/QJAXRPANQc9W4K69oDrBHp2AXW9ANcH9OwH6oYAbjzgJoH7TQF1QYCbA3rOA3VLALcc9FwJ6tYDbhPouQXU7QLcUcCdAPc7BeouAO4y6HkV1N0G3D3Q8wGoewa4l6Dna1D3EXBu6dRcqHTq+4UBdREBFxn0jArqYgMuHuiZANQlA1xK0DM1qMsIuOyAywXulwfUFQJcUdCzOKgrA7jyoGdFUFcdcLVAzzqgriHg2gCuPbhfR1DXHXC9QM/eoG4g4IaAnsNA3RjAjQc9J4K66YBbCLgl4H7LQN0awK0HPTeCuu2A2wV67gF1hwB3FPQ8DurOAu4G4G6D+90FdY8B9wz0fAHq3gHuI+j5GdS5pFdzbunVPd1BnQfgYgAuNrhfXFCXGHDJQM8UoC4d4DKCnt6gLivgsoOeOUFdfsCVBFwZcL9yoK4K4KqDnjVBXQDgGoKejUFdS8C1AT3bgbougOsHuIHgfoNB3UjAjQE9x4G6KYCbDnrOBHXzALcQ9FwM6lYCbgvgtoP77QR1+wF3CPQ8AupOAe4s6Hke1F0F3A3Q8xaoewC414B7B+73AdR9A5xLBnXPEBnUdWEA5wF6RgB1UQEXA/SMBeoSAM4f9CwJ6kqDurKgriLgqoCe1UBdHcA1Aj2bgLpWgGsLerYHdV0B1wP07AXq+gNuEOg5BNSNAtwC0HMRqFsBuNWg51pQtxlw20DPHaBuH+AOgp6HQd1JwF0G3DVwvxug7h7gHoKej0HdS8C9AT3fgbovgPsOerpkVNeFAlxkwEXLqL5fDFAXD3AJQc/EoC4l4NKAnulAnQ/gMoOeWUFdLsAVBZw/uF9JUFcecJVAzyqgrhbg6oKeAaCuCeCag54tQV17wPUCXB9wv36gbgjghoOeI0HdeMBNAj2ngLogwM0BPeeBuiWAWw+4TeB+W0DdLsDtBT33g7qjgDsBep4CdRcAdxn0vArqbgPuGeBegvu9BnUfAfcF9PwG6ty81FwoL3XPMKAuIuAig55RQV1swCUDXEpwv9SgLiPgfEBPX1CXHXC5QM88oK4Q4IqCnsVBXRnAVQdcLXC/OqCuIeCagJ7NQF0bwLUHPTuCuu6A6wV69gZ1AwE3BnDjwf0mgrrpgAsCPWeDuoWAWwJ6LgN1awC3HvTcCOq2A+4Q4I6C+x0HdWcBdwH0vATqbgDuNuh5F9Q9Btwz0PMFqHsHOBdvNefmrb6fO6jzAFxE0NMT1MUAXGzQMy6oSwy4ZKBnClCXDnBZAZcd3C8nqMsPuEKgZxFQVxJwZUDPcqCuCuCqg541QV0A4FoCrg24XztQ1wVw3UHPnqCuH+AGgp6DQd1IwI0BPceBuimAOwB6HgJ1R0DdMVB3CnBnQc/zoO4q4O6AnvdA3RPAPQc9X4K694D7BHp+AXWuPmoupI+6ZyhQFx5wSUHP5KAuLeAygJ5eoC4L4LKBnjlAXT7AFQQ9C4O6EoCrBLiq4H7VQV1dwNUHPRuCuuaAawV6tgF1nQDXFfTsDur6AG444EaB+40BdZMANxX0nA7q5gBuPui5ENQtB9wq0HMNqNsEuL2AOwDudwjUnQDcadDzLKi7DLhroOcNUHcPcA9Bz8eg7iXgvgDuO7ifSyZ1XSjAhc2k7ukB6iIDLhroGQPUxQNcQtAzMahLCTgfwGUG98sK6nIBLi/omR/UFQWcP+hZEtSVB1wl0LMKqKsFuCaAaw7u1xLUtQdcJ9CzC6jrBbg+oGc/UDcEcMNBz5GgbjzgggA3B9xvHqhbArjloOdKULcecJtAzy2gbhfg9oKe+0HdUcBdANxlcL+roO424O6Bng9A3TPAvQQ9X4O6j4D7Anp+A3VuvmouIuAi+6rvFxXUxQZcPNAzAahLBriUoGdqUJcRcD6gpy+oyw64QoArCu5XHNSVAVx50LMiqKsOuFqgZx1Q1xBwTUDPZqCuDeC6A64XuF9vUDcQcENAz2GgbgzgxoOeE0HddMAFgZ6zQd1CwK0B3Hpwv42gbjvgdoGee0DdIcAdBT2Pg7qzgLsAel4CdTcA9xhwz8D9XoC6d4D7CHp+BnUumdWcW2Z1T3dQ5wG4iKCnJ6iLAbgCoGchUFcE1BUDdSUBVwb0LAfqqgCuNuhZF9Q1AlxT0LM5qGsLuA6gZydQ1wNwgaBnH1A3CHAzQc9ZoG4B4BaDnktB3WrArQM9N4C6bYDbCXruBnUHAXcacOfA/S6AumuAuwl63gZ1DwH3BPR8BureAO496PkR1H0HXNgsai58FvX9IoK6aICLCXrGBnUJAZcE9EwG6tIALj3omRHUZQZcXsAVAPcrBOr8AVcK9CwD6ioBriroWR3U1QVcfdCzIahrDrhOgOsK7tcd1PUBXH/QcyCoGw64UaDnGFA3CXBTQc/poG4O4JYDbhW43xpQtwlwW0HP7aBuL+AOgJ6HQN0JwJ0GPc+CusuAuwe4h+B+j0HdS8C9AT3fgbovgPsOerpkVdeFAlzYrOqeHqAuMuDiAS4huF9iUJcScGlAz3SgzgdwmUHPrKAuF+Dygp75QV1RwJUHXCVwvyqgrhbg6oKeAaCuCeCag54tQV17wHUCPbuAul6AGwK44eB+I0HdeMBNAj2ngLogwM0BPeeBuiWAWw56rgR16wG3C3B7wf32g7qjgDsBep4CdRcAdxn0vArqbgPuHuj5ANQ9A9xHwH0B9/sG6tz81FwoP3XPMKAuIuAig55RQV1swMUDPROAumSAywg4H3A/X1CXHXC5QM88oK4Q4IqCnsVBXRnAlQc9K4K66oBrCLgm4H7NQF0bwLUHPTuCuu6A6wV69gZ1AwE3BPQcBurGAG4H6LkL1O0BdftA3SHAHQU9j4O6s4C7AnpeA3V3AHcf9HwI6p4D7hXo+QbUfQLcV9DzO6gLmU3Nxc2m7hkf1CUFXArQMxWoywA4b9AzE6jLBricoGduUFcQcKUAVxbcrzyoqwq4GqBnLVBXH3CNQM8moK4V4NqCnu1BXVfA9QfcIHC/IaBuFODGgp7jQd1UwM0APYNA3XzALQI9l4C6VYDbCrgd4H67QN0BwB0GPY+CutOAOwd6XgB11wB3E/S8DeoeAu4N4N6D+30Edd8B55pd3dMtu7ouLODCg54RQV00wMUEPWODuoSASwO49OB+GUFdZsD5gZ7ZQV1ewBUAPQuBOn/AlQI9y4C6SoCrC7j64H4NQV1zwLUCPduAuk6A6wp6dgd1fQDXH/QcCOqGA24S4KaC+00HdXMANx/0XAjqlgNuFei5BtRtAtxW0HM7qNsLuBOAOw3udxbUXQbcNdDzBqi7B7iHoOdjUPcScG9Az3eg7gvgQuVQc2FzqO/nAeoiAy4a6BkD1MUDXELQMzGoSwm4NKBnOlDnA7hcgMsL7pcf1BUFnD/oWRLUlQdcJdCzCqirBbi6oGcAqGsCuPaA6wTu1wXU9QJcH9CzH6gbArjhoOdIUDcecJNAzymgLghwSwC3HNxvJahbD7hNoOcWULcLcHtBz/2g7ijgToCep0DdBcC9CuYKfLtaZOWYAak4FyGnuq5XTnXdipzqea4G3DrAbQH3OwPmeR5wSXKpe+bNpa4bDuqWAe4Y6Hk6l/q53wI93XKre4YBXITc6vvFy62+X27QswDgioL7VQT36wR6ngI9z4C6c6AuRp5//9u+4pP4504+3ci52MHczEUJ1sW9G6Ia5+IALi7g4gEuPuASAC4h4BIBLjHgkgAuKeCSAS454FIALiXgUgEuNeDSAC4n4HIBLjfg8gAuL+DyAS4/4AoAriDgCgGuMOCKAK4o4IoBrjjg/AFXAnAlAVcKcKUBVwZwZQFXDnDlAVcBcBUBVwlwlQFXBXBVAVcNcNUBVwNwNQFXG3B1ARcAuAaAawS4JoBrBrgWgGsFuDaAawe4DoDrBLgugOsGuB6A6wW43oDrC7j+gBsIuMGAGwq44YAbCbjRgBsLuPGAmwi4yYCbCrjpgJsJuFmAmw+4hYBbDLilgFsOuJWAWw24tYBbD7iNgNsMuK2A2w64nYDbDbi9gNsPuIOAOwK4Y4A7AbhTgDsDuHOAuwC4S4C7ArhrgLsBuFuAuwO4e4B7ALhHgHsCuGeAewG4V4B7A7h3gPsAuE+A+wK4b4D7ATjXvGrODXDugAsNuLCA8wBcBMB5Ai4q4GIALjbg4gEuIeCSAC454FIBLi3gMgDOG3C+gMsKuOyAywW4vIArALjCgCsGuBKAKw24coCrCLgqgKsOuFqAqwu4+oBrBLimgGsBuNaAawe4zoDrCrjugOsJuEDA9QFcP8ANANwgwA0B3DDAjQDcKMCNAdw4wE0A3CTATQHcdMDNBNwswM0B3DzALQDcIsAtAdwywK0A3CrArQHcOsBtANwmwG0B3DbA7QDcLsDtAdw+wB0A3CHAHQHcMcCdANwpwJ0B3DnAXQDcJcBdAdw1wN0A3G3A3QPcQ8A9AdxzwL0C3FvAfQDcZ8B9A5xLPjXnBrhQgAsLuPCAiwS4KICLDrhYgIsLuASASwy4ZIBLCbg0gEsPOC/AZQJcFsBlA1xOwOUBXH7AFQJcccCVAFwpwJUBXDnAVQBcJcBVAVw1wNUAXC3A1QFcPcDVB1xDwDUGXFPANQdcK8C1AVw7wHUAXCfAdQFcN8D1AFwvwPUGXF/A9QfcQMANBtxQwA0H3EjAjQbcWMCNB9xEwE0G3FTATQfcTMDNAtwcwM0D3ALALQLcEsAtA9wKwK0C3FrAbQDcZsBtA9xOwO0B3H7AHQLcUcCdANxpwJ0D3EXAXQHcdcDdAtxdwD0A3GPAPQPcS8C9Adx7wH0C3FfA/QBciPxqzh1wYQDnAbiIgIsMuGiAiwm4eIBLALhEgEsCuGSASwG4VIBLA7h0gMsAOC/A+QDOF3BZAOcHuOyAywm43IDLB7gCgCsEuCKAKwY4f8CVBFxpwJUFXHnAVQRcZcBVBVx1wNUEXG3A1QVcAOAaAK4R4JoArhngWgCuFeDaAK4d4DoArhPgugCuG+B6AK4X4HoDri/gBgBuMOCGAW4k4MYAbjzgJgFuKuBmAG4W4OYCbgHgFgNuGeBWAm4N4NYDbhPgtgJuB+B2A24f4A4C7gjgjgPuFODOAu4C4C4D7hrgbgLuDuDuA+4R4J4D7iXgXgPuLeDeA+4j4D4D7ivgvgPOpYCaCwG4kIALBbgwgAsHuPCAiwg4T8BFBVx0wMUEXGzAxQVcfMAlBFxiwCUFXHLApQRcasClBVx6wGUEnDfgMgEuM+CyAi4b4HIALhfg8gAuH+AKAK4Q4IoArhjg/AFXEnClAVcWcOUBVxFwVQBXHXC1AFcXcPUB1whwTQHXAnCtAdcOcB0B1wVw3QHXC3B9ANcfcIMANxRwIwA3GnDjADcRcFMANx1wQYCbA7j5gFsEuKWAWwG41YBbB7iNgNsCuJ2A2w24vYDbD7iDgDsMuKOAOw64k4A7DbizgDsPuIuAuwy4q4C7DribgLsNuHuAewC4R4B7ArhngHsBuFeAewO4d4D7ALhPgPsCuG+A+wE414Jqzg1w7oALDbiwgPMAXATARQJcZMBFBVx0wMUEXGzAxQVcfMAlBFxiwCUFXHLApQRcGsClB5wX4DIBLgvgsgEuJ+DyAC4/4AoBrijg/AFXCnBlAVcBcJUBVw1wNQFXB3ABgGsIuCaAaw64VoBrC7gOgOsMuG6A6wm43oDrB7iBgBsCuOGAGwO4cYCbALhJgJsCuGmAmwG4IMDNBtxcwM0H3ELALQbcUsAtB9xKwK0G3FrAbQDcJsBtAdw2wO0A3C7A7QHcPsAdANwhwB0B3DHAnQDcKcCdAdw5wF0A3CXAXQHcNcDdANwtwN0B3D3APQDcI8A9AdwzwL0A3CvAvQHcO8B9ANwnwH0F3A/AhSik5twBFwZwHoCLCLjIgIsGuJiAiwO4+IBLBLikgEsBuNSASwe4jIDzAVxmwPkBLgfgcgMuH+AKAq4I4IoDriTgygCuPOAqAa4q4GoArjbg6gOuIeAaA64p4JoDriXgWgOuLeDaA64j4DoDrivgugOuJ+ACAdcHcP0ANwBwgwE3FHDDATcScKMBNxZw4wE3EXCTATcVcNMBNxNwswA3B3DzALcAcIsAtwRwywC3AnCrALcGcOsAtwFwmwC3BXDbALcDcLsAtwdw+wB3AHCHAHcEcMcBdwpwZwF3AXCXAXcNcDcBdwdw9wH3CHBPAfcCcK8B9w5wHwH3BXDfAedaWM2FBFxowIUDXATAeQIuKuBiAC424OIBLiHgkgAuOeBSAS4t4DIAzhtwWQDnB7jsgMsJuNyAywu4/IArCLjCgCsKuOKAKwG4UoArA7hygKsAuEqAqwK46oCrCbjagKsLuADANQBcI8A1AVwzwLUAXCvAtQFcO8B1AFwnwHUBXDfA9QBcL8D1BlxfwPUH3EDADQbcUMANB9xIwI0G3FjAjQfcRMBNBtxUwE0HXBDg5gBuPuAWAW4p4FYAbjXg1gFuI+C2AG474HYBbi/gDgDuMOCOAe4k4M4A7jzgLgHuKuBuAO424O4B7iHgngDuOeBeAe4t4D4A7jPgvgHOpYiacwNcGMCFA1x4wEUEnCfgogAuGuBiAC4W4OIALh7gEgAuEeCSAC4Z4FIALhXg0gAuPeAyAs4bcJkAlxlwWQGXDXA5AJcLcHkAlw9wBQBXCHBFAFcMcP6AKwm40oArC7jygKsIuMqAqwq46oCrCbjagKsLuADANQBcI8A1AVwzwLUAXCvAtQVcB8B1Blw3wPUEXG/A9QPcQMANAdxwwI0C3FjATQDcZMBNA9xMwM0G3DzALQTcEsAtB9wqwK0F3AbAbQbcNsDtBNwewO0H3CHAHQXcCcCdBtw5wF0G3FXAXQfcTcDdBtxdwN0H3EPAPQbcU8A9B9xLwL0G3FvAvQfcR8B9BtxXwP0AnGtRNecGOHfAhQZcWMB5AC4C4CIBLjLgogIuOuBiAi424OICLj7gEgIuMeCSAi454FICLjXg0gIuPeAyAs4bcJkAlxlwWQGXDXA5AJcLcHkAlw9wBQFXBHDFAVcScGUAVx5wlQBXFXA1AFcbcPUA1wBwjQHXDHAtAdcGcO0B1wlwXQHXA3CBgOsLuAGAGwy4YYAbCbgxgBsPuEmAmwq4GYCbBbi5gFsAuKWAWw64lYBbDbi1gFsPuI2A2wy4rYDbDridgNsNuL2A2w+4g4A7DLijgDsOuFOAOwO4c4C7ALhLgLsCuGuAuwG4W4C7A7h7gHsAuEeAewK4Z4B7AbhXgHsDuHeA+wC4T4D7ArhvgPsBONdias4NcO6ACw24sIDzAFwEwEUCXGTARQVcDMDFBlw8wCUEXBLAJQdcKsClBVwGwHkDzhdwWQGXHXC5AJcXcAUAVxhwxQBXAnClAVcOcBUBVwVw1QFXC3B1AVcfcI0A1xRwLQDXGnDtANcRcF0A1xNwgYDrA7h+gBsAuEGAGwK4YYAbAbhRgBsDuHGAmwC4SYCbArhpgJsBuCDAzQHcPMAtANwiwC0B3DLArQDcKsCtAdw6wG0A3CbAbQHcNsDtANwuwO0B3D7AHQDcIcAdAdwxwJ0A3CnAnQHcOcBdANwlwF0B3DXA3QDcLcDdAdw9wD0E3BPAPQfcK8C9BdwHwH0G3DfAuRRXc26ACwW4sIALD7hIgIsCuOiAiwW4uIBLALjEgEsGuJSASwO49IDzAlwmwGUBXDbA5QRcHsDlB1whwBUFnD/gygCuHOAqAK4S4KoArhrgagCuFuDqAK4e4OoDriHgGgOuKeCaA64l4FoDri3gOgCuE+C6AK4b4HoArhfgegOuL+D6A24g4AYDbijghgNuJOBGA24s4MYDbiLgJgNuKuCmA24m4GYBbg7g5gFuAeAWAW4J4JYBbgXgVgFuDeDWAW4D4DYDbhvgdgJuD+D2A+4Q4I4C7gTgTgPuHOAuAu4K4K4D7hbg7gLuAeAeA+4Z4F4C7g3g3gPuE+C+Au4H4EL4qzl3wIUBnAfgIgIuMuCiAS4m4OIALj7gkgAuGeBSAC4V4NIALh3gMgDOC3A+gPMFXBbA+QEuO+ByAi434PICLj/gCgKuCOCKAc4fcCUBVxpwZQFXHnAVAVcZcFUBVx1wNQFXG3B1ARcAuAaAawS4JoBrBrgWgGsFuDaAawe4DoDrBLgugOsGuB6A6wW43oDrC7j+gBsIuMGAGwa4kYAbA7jxgJsEuKmAmwG4WYCbC7gFgFsMuGWAWwm4NYBbD7hNgNsKuB2A2w24fYA7CLgjgDsOuFOAOwu4C4C7DLhrgLsJuDuAuw+4R4B7CrgXgHsDuLeAewe494D7ALiPgPsEuM+A+wK4r4D7BrjvgPsBOJcSas4VcCEA5wa4kICLCbhYgIsNuDiAiwu4eICLD7gEgEsIuESASwy4JIBLCrhkgEsOuBSASwm4VIBLDbg0gEsLuHSASw+4DIDLCDgvwHkDzgdwmQDnC7jMgMsCuKyA8wNcdsDlBFxuwOUFXH7AFQRcYcAVBVxxwJUAXCnAlQFcOcBVAFwlwFUBXDXA1QBcLcDVAVw9wNUHXEPANQZcU8A1B1xLwLUGXFvAtQdcR8B1BlxXwHVXcGGC//UO/jds8L8hgv91JbgR8gZfe/29D++wrK90fz+vzF5hXX7/ITz/TGGDe1rpj7OnBf29Qgf3KRn4s7/xuTg+IgRfuzIvnTWOPRPR5ec4NqtxfJRivV0NXGmT+1r5nP28fBs4+4e0oD99+EQ1mX9I9twcHwUCrbi372/7vaAl/b18nf0LWdO/gbN/YSv6e3v95k8Ra+afydm/aHB/F7nev829mERvb/PexQV6eyvm7f/3extb/9a7xH/R2/c/8B4u/86ztMH93Fz++Lrm51ZIpjHLUFWPEIYeZvkU0kVuPZzzdmdzCumiziynPlTwdQimdwd64/My9g/1JzxxAf2N7xlcDDzvHZLxzj3upujL72c2N97LDczFqY3got43EUzqQxg4s73k2JvOvR8y8Pd83uDHvf7GR1a/f++Tfz3H4P7uLr/32cVwf3eD3iv4OhybP/cl7385z4ZZ63o3zFS3Yd3MdevX9w2oG8XQ34V55vBpafCktX4vm8k7wK73spa8L/Kp99v7Lndr5m/6XpY/F553XGes4a+zUkxTSqEpzTSlFZoyTFNGoSnLNGUVmnJMU06hKc805RWaCkxTQaGpyDQVFZpKTFNJoanMNJUVmipMU0Whqco0VRWaakxTTaGpzjTVFZoaTFNDoanJNDUVmlpMU0uhqc00tRWaOkxTR6GpyzR1FZp6TFNPoQlgmgCFpj7T1FdoGjBNA4WmIdM0VGgaMU0jhaYx0zRWaJowTROFpinTNFVomjFNM4WmOdM0V2haME0LhaYl07RUaFoxTSuFpjXTtFZo2jBNG4WmLdO0VWjaMU07haY907RXaDowTQeFpiPTdFRoOjFNJ4WmM9N0Vmi6ME0XhaYr03RVaLoxTTeFpjvTdFdoejBND4WmJ9P0VGh6MU0vhSaQaQIVmt5M01uh6cM0fRSavkzTV6HpxzT9FJr+TNNfoRnANAMUmoFMM1ChGcQ0gxSawUwzWKEZwjRDFJqhTDNUoRnGNMMUmuFMM1yhGcE0IxSakUwzUqEZxTSjFJrRTDNaoRnDNGMUmrFMM1ahGcc04xSa8UwzXqGZwDQTFJqJTDNRoZnENJMUmslMM1mhmcI0UxSaqUwzVaGZxjTTFJrpTDNdoZnBNDMUmplMM1OhCWKaIIVmFtPMUmhmM81shWYO08xRaOYyzVyFZh7TzFNo5jPNfIVmAdMsUGgWMs1ChWYR0yxSaBYzzWKFZgnTLFFoljLNUoVmGdMsU2iWM81yhWYF06xQaFYyzUqFZhXTrFJoVjPNaoVmDdOsUWjWMs1ahWYd06xTaNYzzXqFZgPTbFBoNjLNRoVmE9NsUmg2M81mhWYL02xRaLYyzVaFZhvTbFNotjPNdoVmB9PsUGh2Ms1OhWYX0+xSaHYzzW6FZg/T7FFo9jLNXoVmH9PsU2j2M81+heYA0xxQaA4yzUGF5hDTHFJoDjPNYYXmCNMcUWiOMs1RheYY0xxTaI4zzXGF5gTTnFBoTjLNSYXmFNOcUmhOM81pheYM05xRaM4yzVmF5hzTnFNozjPNeYXmAtNcUGguMs1FheYS01xSaC4zzWWF5grTXFForjLNVYXmGtNcU2iuM811heYG09xQaG4yzU2F5hbT3FJobjPNbYXmDtPcUWjuMs1dheYe09xTaO4zzX2F5gHTPFBoHjLNQ4XmEdM8UmgeM81jheYJ0zxRaJ4yzVOF5hnTPFNonjPNc4XmBdO8UGheMs1LheYV07xSaF4zzWuF5g3TvFFo3jLNW4XmHdO8U2jeM817heYD03xQaD4yzUeF5hPTfFJoPjPNZ4XmC9N8UWi+Ms1XheYb03xTaL4zzXeF5gfT/FBoXHr/1DjHRo0r07gqNCGYJoRC48Y0bgpNSKYJqdC4M427QhOKaUIpNKGZJrRCE4Zpwig0YZkmrEITjmnCKTQeTOOh0IRnmvAKTQSmiaDQRGSaiApNJKaJpNB4Mo2nQhOZaSIrNFGYJopCE5Vpoio00ZgmmkITnWmiKzQxmCaGQhOTaWIqNLGYJpZCE5tpYis0cZgmjkITl2niKjTxmCaeQhOfaeIrNAmYJoFCk5BpEio0iZgmkUKTmGkSKzRJmCaJQpOUaZIqNMmYJplCk5xpkis0KZgmhUKTkmlSKjSpmCaVQpOaaVIrNGmYJo1Ck5Zp0io06ZgmnUKTnmnSKzQZmCaDQpORaTIqNF5M46XQeDONt0LjwzQ+Ck0mpsmk0Pgyja9Ck5lpMis0WZgmi0KTlWmyKjR+TOOn0GRjmmwKTXamya7Q5GCaHApNTqbJqdDkYppcCk1upsmt0ORhmjwKTV6myavQ5GOafApNfqbJr9AUYJoCCk1Bpimo0BRimkIKTWGmKazQFGGaIgpNUaYpqtAUY5piCk1xpimu0Pgzjb9CU4JpSig0JZmmpEJTimlKKTSlmaa0QlOGacooNGWZpqxCU45pyik05ZmmvEJTgWkqKDQVmaaiQlOJaSopNJWZprJCU4Vpqig0VZmmqkJTjWmqKTTVmaa6QlODaWooNDWZpqZCU4tpaik0tZmmtkJTh2nqKDR1maauQlOPaeopNAFME6DQ1Gea+gpNA6ZpoNA0ZJqGCk0jpmmk0DRmmsYKTROmaaLQNGWapgpNM6ZpptA0Z5rmCk0Lpmmh0LRkmpYKTSumaaXQtGaa1gpNG6Zpo9C0ZZq2Ck07pmmn0LRnmvYKTQem6aDQdGSajgpNJ6bppNB0ZprOCk0Xpumi0HRlmq4KTTem6abQdGea7gpND6bpodD0ZJqeCk0vpuml0AQyTaBC05tpeis0fZimj0LTl2n6KjT9mKafQtOfaforNAOYZoBCM5BpBio0g5hmkEIzmGkGKzRDmGaIQjOUaYYqNMOYZphCM5xphis0I5hmhEIzkmlGKjSjmGaUQjOaaUYrNGOYZoxCM5Zpxio045hmnEIznmnGKzQTmGaCQjORaSYqNJOYZpJCM5lpJis0U5hmikIzlWmmKjTTmGaaQjOdaaYrNDOYZoZCM5NpZio0QUwTpNDMYppZCs1sppmt0MxhmjkKzVymmavQzGOaeQrNfKaZr9AsYJoFCs1Cplmo0CximkUKzWKmWazQLGGaJQrNUqZZqtAsY5plCs1yplmu0KxgmhUKzUqmWanQrGKaVQrNaqZZrdCsYZo1Cs1aplmr0KxjmnUKzXqmWa/QbGCaDQrNRqbZqNBsYppNCs1mptms0Gxhmi0KzVam2arQbGOabQrNdqbZrtDsYJodCs1Optmp0Oximl0KzW6m2a3Q7GGaPQrNXqbZq9DsY5p9Cs1+ptmv0BxgmgMKzUGmOajQHGKaQwrNYaY5rNAcYZojCs1Rpjmq0BxjmmMKzXGmOa7QnGCaEwrNSaY5qdCcYppTCs1ppjmt0JxhmjMKzVmmOavQnGOacwrNeaY5r9BcYJoLCs1Fprmo0FximksKzWWmuazQXGGaKwrNVaa5qtBcY5prCs11prmu0NxgmhsKzU2muanQ3GKaWwrNbaa5rdDcYZo7Cs1dprmr0NxjmnsKzX2mua/QPGCaBwrNQ6Z5qNA8YppHCs1jpnms0DxhmicKzVOmearQPGOaZwrNc6Z5rtC8YJoXCs1Lpnmp0LximlcKzWumea3QvGGaNwrNW6Z5q9C8Y5p3Cs17pnmv0Hxgmg8KzUem+ajQfGKaTwrNZ6b5rNB8YZovCs1Xpvmq0Hxjmm8KzXem+a7Q/GCaHwqNS5+fGufYqHFlGleFJgTThFBo3JjGTaEJyTQhFRp3pnFXaEIxTSiFJjTThFZowjBNGIUmLNOEVWjCMU04hcaDaTwUmvBME16hicA0ERSaiEwTUaGJxDSRFBpPpvFUaCIzTWSFJgrTRFFoojJNVIUmGtNEU2iiM010hSYG08RQaGIyTUyFJhbTxFJoYjNNbIUmDtPEUWjiMk1chSYe08RTaOIzTXyFJgHTJFBoEjJNQoUmEdMkUmgSM01ihSYJ0yRRaJIyTVKFJhnTJFNokjNNcoUmBdOkUGhSMk1KhSYV06RSaFIzTWqFJg3TpFFo0jJNWoUmHdOkU2jSM016hSYD02RQaDIyTUaFxotpvBQab6bxVmh8mMZHocnENJkUGl+m8VVoMjNNZoUmC9NkUWiyMk1WhcaPafwUmmxMk02hyc402RWaHEyTQ6HJyTQ5FZpcTJNLocnNNLkVmjxMk0ehycs0eRWafEyTT6HJzzT5FZoCTFNAoSnINAUVmkJMU0ihKcw0hRWaIkxTRKEpyjRFFZpiTFNMoSnONMUVGn+m8VdoSjBNCYWmJNOUVGhKMU0phaY005RWaMowTRmFpizTlFVoyjFNOYWmPNOUV2gqME0FhaYi01RUaCoxTSWFpjLTVFZoqjBNFYWmKtNUVWiqMU01haY601RXaGowTQ2FpibT1FRoajFNLYWmNtPUVmjqME0dhaYu09RVaOoxTT2FJoBpAhSa+kxTX6FpwDQNFJqGTNNQoWnENI0UmsZM01ihacI0TRSapkzTVKFpxjTNFJrmTNNcoWnBNC0UmpZM01KhacU0rRSa1kzTWqFpwzRtFJq2TNNWoWnHNO0UmvZM016h6cA0HRSajkzTUaHpxDSdFJrOTNNZoenCNF0Umq5M01Wh6cY03RSa7kzTXaHpwTQ9FJqeTNNToenFNL0UmkCmCVRoejNNb4WmD9P0UWj6Mk1fhaYf0/RTaPozTX+FZgDTDFBoBjLNQIVmENMMUmgGM81ghWYI0wxRaIYyzVCFZhjTDFNohjPNcIVmBNOMUGhGMs1IhWYU04xSaEYzzWiFZgzTjFFoxjLNWIVmHNOMU2jGM814hWYC00xQaCYyzUSFZhLTTFJoJjPNZIVmCtNMUWimMs1UhWYa00xTaKYzzXSFZgbTzFBoZjLNTIUmiGmCFJpZTDNLoZnNNLMVmjlMM0ehmcs0cxWaeUwzT6GZzzTzFZoFTLNAoVnINAsVmkVMs0ihWcw0ixWaJUyzRKFZyjRLFZplTLNMoVnONMsVmhVMs0KhWck0KxWaVUyzSqFZzTSrFZo1TLNGoVnLNGsVmnVMs06hWc806xWaDUyzQaHZyDQbFZpNTLNJodnMNJsVmi1Ms0Wh2co0WxWabUyzTaHZzjTbFZodTLNDodnJNDsVml1Ms0uh2c00uxWaPUyzR6HZyzR7FZp9TLNPodnPNPsVmgNMc0ChOcg0BxWaQ0xzSKE5zDSHFZojTHNEoTnKNEcVmmNMc0yhOc40xxWaE0xzQqE5yTQnFZpTTHNKoTnNNKcVmjNMc0ahOcs0ZxWac0xzTqE5zzTnFZoLTHNBobnINBcVmktMc0mhucw0lxWaK0xzRaG5yjRXFZprTHNNobnONNcVmhtMc0Ohuck0NxWaW0xzS6G5zTS3FZo7THNHobnLNHcVmntMc0+huc809xWaB0zzQKF5yDQPFZpHTPNIoXnMNI8VmidM80Sheco0TxWaZ0zzTKF5zjTPFZoXTPNCoXnJNC8VmldM80qhec00rxWaN0zzRqF5yzRvFZp3TPNOoXnPNO8Vmg9M80Gh+cg0HxWaT0zzSaH5zDSfFZovTPNFofnKNF8Vmm9M802h+c403xWaH0zzQ6Fx6ftT4xwbNa5M46rQhGCaEAqNG9O4KTQhmSakQuPONO4KTSimCaXQhGaa0ApNGKYJo9CEZZqwTOPGNOGYJpxBE5b15I/nDb72+hsffl6+9S39+xw+9QKcf8+G//0c53Nx3juUNfeu72q4n4sL27fsX+f9wxnmKjofLy9vV8P9nPMx+hMi+F/n38tz/m0dvg+cXMjAPz4PJ+fOOOf6Ov621Y0QP3XGvRXS5feccy6OD+f+Nf5tI8eHc986+j8O8XP8LsTv585r3Az3d3H5498DtGIt/DJ51bP279J4e5mtnRvz1vERknEhDdyfWTvHR1yWF0bv3Cz2zprXibc3+luKzr0SOtDlt4/fzhD2mNM/p09huN7AhWVcyMDf3ydc8LXz74IZeznn4W7QPwpejEjBj4diNc56T5P7hzLc/3fzNnnMueauJr3cTB5z6h1ZcTv4gv9dsV9/o9L049ffqAQfv/5G5f/mb1T2C36BW/031pznPX/fYnwPF9qSe3t7/9n3cM77h3Ox8D0lew8X2jAfoz/GsziMNf789nc9w5jMJ4yJP861DGvCOXs5/3ajO+vF9WHYc+R6PnbW/65f8MJ5mvR0N8whrMnz4Y/xc+yH4f0sXxtXxb/OvsbHnH09Xf7oTSjDHM3ex/P3t/ws5b6FMtHzfu4GffhgkeN6iJt5T75WIf5Ez8huP+cSKXhs9rma8zk4dAn+4r3dFPeOw+4dTdHT9T/0NO4TlachDHNw6mMxT4cbnj9fZ75m8YDOHej4e9dQTGf00zlXNxfzzwsLBprf39nD7F9nP+Njxn3On4sxu/jrVPI9mzFvzJ638f4OeLDn4Obyxwwy6s32FO/vYdD/9jd2Xcyz1N3gjzXZ7uVt3LNe7HWTxs18zi4u5q+bMIbn6PQrlELv7GfM8AwmWWS2h/jr0jnvSC5/XJ9QBi+NGZvX+dz/3odfWJc/7hPB/l5mf7eZZ0Jmw3p5MH//jP9OfQ62B/wMvvLXvvG8572de9+D8eFdfn783SwJzzTGcz0CqzE+b8dHwcB//+tcr0isXvI9rXM+EYP78dd6JJP5uBv0hQ3rGZn542Z4rryPU+9pct/I7Lkazy1Pw30dr79RhnOG5xjfe0UNc43IersZatFzrsH2nr9h7/F7O/deJIMPfG+ENfSWXd+f74sjmTxX/lrgXnB9WebzWOaz44N/Tc+DPR/HR8hAS56Pt2MeEwzrzV+z7uy+/Hm5uPx83lzPPTDueTeXP66N8TXOX5cRDL08THqZnUVm77GdczTLLWdfszw1m38Ek1rj6y+UQs/3DdfXAe/FPVmNMUt47hp7NmCvqwDDGvM14Gd2W8W9+fN3M3k+xrxSvW/2NMzVqW9i8vzDuvwxvwT/HyfAOecobE5uhnny+7sb9C1MXstGH7hvZmebcQ5cH9nEN2f2cd+dtWZr+9vXiV1+rm0kk+cY3sV8/vwc4XrnOWBcxy5sz3VUeBJO0TOU4Xnw58j3VTc3tc7dRGd2L+P5gPKN9+c9VPs9ksl9jD4Fgve74RXzVM2PZ5AzA83O7ohsrkXZa8zxETLwp07qNZbV79/vh/4118CfPvCvZbgY7u9u0A8OFvP3185/Q/6NeTbMWte7Yaa6Detmrlu/vm9A3SiG/o4P52vUw4L7+2aumzWgblZv72y+3g18vTPbfX8fP78s2XzqeflmrR/QsL5vJrvvn8U3i7efX12/gCwBDbP5BtSz+/4N/LLV98rWsEFdb29vn/peDf7T/c3+v42/X3N8OP/Pjv+fHtfz995cP4Vl5jTDe0J3k/s5dEuAzlXx7796mDwWMvD3j5n9Xx//P1Cn3nnvcIF/nKOT82Acfy/p+AgffM394r2c83A36Beyc8zxwf/f0lnvaXL/MIb7/27eJo8Z/w/Uw0TvYaJ3rM8sQ27x5y75tRzn3EIZ+vPHjHNz7h3Hvq4e3CCsyXOWnCf/2ox0fz+vLA3516ksmH8mi783wcfq/2tzfi5UMvBnf/5cfjt3DTpjjRvTlGKaUgpNaaYprdCUYZoyCk1Zpimr0JRjmnIKTXmmKa/QVGCaCgpNRaapqNBUYppKCk1lpqms0FRhmioKTVWmqarQVGOaagpNdaaprtDUYJoaCk1Npqmp0NRimloGjdbfnxj8fVr8NebCnoul35/4F/5v+/+370/0YTrj3kLfn+jcv2bfn+jct47+udi9irr8fu68H/p6gKXfY+eVuaHF55jp9yca1zVk4O/vzTm+diGZnz4Gf6x4n8L9scJ/hz9RFfN3jh0fzs8LXFzM3387PfpffQ9izuDrf/L3IGYOHv/6HsT/+PHrexDBx6/vQfzffA+i8wuHzq9V8/PK1TDm7yHQ+wpPl/987pu9X/sz76fM7mM2Z+d93AXvw9/DGt9HWPP9kz+/xyYMm6ebyx/PNuP3APKvM7gZepjpje+Rjf3D2vN8//D9kPz/RUKZzN/se5xc5ebjZ/zetzHB/zrmUt1wT7PvgzL73gin3sPgoVFj/F6a8OzeRk94rbtBXyf4X8dzyOL6e9/CG+aQN/ja6299/Pz/+9/eb7I5868xh3f5/Zyd+vpsztlczX1wccHv8Y1z4Hr+vJ3zcWYg9z2CoQ79n7RZb653U/Qx/p+g8XmGcPnj65r3MPteG8HXgOn32ria3JOvNde3NcyLf6+Nqwv2zAFPk/vy/7M1fq+Vp+G+jj2U07CHfvu6uYt5vhjXJBSbg9kahjbMwanvGfzvv/6fVtEznAveF2FdzH3JG3zt9bc+fP6wvu4ueF3MssNFbD4/v2/SOZ/uwf861jFP8M2c5zs/0/j35ga6qHWhTXT/9DzsxzzIxjxwfJh9/caO72fKb1gLfha5G+ZkltlmP2/xVzPb0+WPrw3j9yeZff82z1njfcy+Z8n4mlV9362znzEHRgX/65hbFdffz8/dpN5R53yvEcnkPsYa/v8K6L2HlV/XcWwMs6/58e8VmaiYN3898DUpFPiT5/pErj97TnH5/XOz6P92/Ix7gL+3Nt6TzyecNfOB75XDmczH+F52jsvv18L5+uJ7KJRJH6few+S+Zt87bPweaOd9+bnsZnIPng9mX8t3EfQSfb5o8c8JZHM13M/pB3+M3z+ci6X73Nu4r/j6cH+MnwNbtM/9HO/1PF1+vz8cH/zraHxt+DyMP59gzdebvXzMco+/z1jBHufzMss9s9esU7+W9VwdPDb7+QH+MwLG9QzhYp61BQN/75WHNV79llvOdeL5gb6P3anfyubFz36eW2FM+hhzTvVe3niGhzfcl+dWJJc/7jnj16OM30/t+CgU+Mf7GecXSqH3UMxvF5uf8z2G2ecOVpyJZj+TwF+Tqs8N97E5Gz/PN3sPaJY/xjlwvdn7wkgufzyrjN//aXZv/nxU9w7l8tee/1GXn8/fuGYW/ezMb2tm9v3uf+Z76E+yORvXzOz7+NGamX3fu9nXFCK5/HGdjN8j/J/WzPj+hX/P9p9ZM6f+gsvP529cM0/D/fIGX3v9vY/f1ox/j7zZmqm+7/8Km7NxzczWAK2Z2ffce5r4ZvY99JENvdCaOT74/2Xx+/zZNXPqb7v8fP66rNl9Nme714x7avx6neprl2Zfz/uzXy9z6l8G/+tY32eG5+DUqL5e5vyah/HrEcYz9TXQhTbRmd3rr/xcg9nXk9F+DmVyH+N+/hD8L9/ProZ67n1Ek+dofG/5jc3ls4t5z3CKnkbv+b7gXzP5AXShTXToXPoz3qOvK5vlv9l7AmP+hwz228x7s32PvP9tT7v+nEtoRc8/671q34d3VetCm+jMPDH7WXz+OK9DX0+PwO5npue/m4LrI5t4/7/82q2HyXM0zjk6mzP62q3zc4j/61+7dXr2d792a/Z9jq5Mw78fzsjxTHJ+bu48+/jXVZz3t+v3AJn97h5XE3+MnxMn/5N7jP/uC8dHyEBLns9f3mMoPxwfxj0WzkRv/B0Zjg9Pg55nnavBE97LbB+hPflnv+79T/85wMzBDf6v/Rzg//rn8P7qz8H9X/s5wIBsWRpmy5SpnnembPUbZPPO8r/8OcDC7L1WUUNWupvcz6GrDHSuin//1cPksZCBv3/sn/5zgBWCG/yTfw6wpCG3+HOX/r+Rf93T0J8/Zpybc+/8E36+2SP4ANL65xC9fbLY9XOI1vzutICsVv/fsNnPIfLnwr9XkeuMNVxTh2nqMA3Pk7pMU1ehqcc09RSaAKYJUGjqM019haYB0zRQaBoyTUOFphHTNFJoGjNNY4WmCdM0UWiaMk1ThaYZ0zRTaJozTXOFpgXTtFBoWjJNS4WmFdO0UmhaM01rhaYN07RRaNoyTVuFph3TtFNo2jNNe4WmA9N0UGg6Mk1HhaYT03RSaDozTWeFpgvTdFFoujJNV4WmG9N0U2i6M013haYH0/RQaHoyTU+FphfT9FJoApkmUKHpzTS9FZo+TNNHoenLNH0Vmn5M00+h6c80/RWaAUwzQKEZyDQDFZpBTDNIoRnMNIMVmiFMM0ShGco0QxWaYUwzTKEZzjTDFZoRTDNCoRnJNCMVmlFMM0qhGc00oxWaMUwzRqEZyzRjFZpxTDNOoRnPNOMVmglMM0Ghmcg0ExWaSUwzSaGZzDSTFZopTDNFoZnKNFMVmmlMM02hmc400xWaGUwzQ6GZyTQzFZogpglSaGYxzSyFZjbTzFZo5jDNHIVmLtPMVWjmMc08hWY+08xXaBYwzQKFZiHTLFRoFgW6/PbhHBs1i5lmsUKzhGmWKDRLmWapQrOMaZYpNMuZZrlCs4JpVig0K5lmpUKzimlWKTSrmWa1QrOGadYoNGuZZq1Cs45p1ik065lmvUKzgWk2KDQbmWajQrOJaTYpNJuZZrNCs4Vptig0W5lmq0KzjWm2KTTbmWa7QrODaXYoNDuZZqdCs4tpdik0u5lmt0Kzh2n2KDR7mWavQrOPafYpNPuZZr9Cc4BpDig0B5nmoEJziGkOKTSHmeawQnOEaY4YNMb/C3B8OD+ntvb3Kvg2sPbrCt6/fZ8r//qL83la+32j3plcDfdzcfnj11f5/cO5/PHrHoJfY/nt+6TNfl+u2d+6+Ku/s8PDwLkzzrm+jv/zOst0xr1l/LldNwu88PPK4mXtvvPx/d/tO5/M/xf3nZuBCxn4x+fxV/cd98S470Ja4IWfl5+vtfvO1+9/t+98s/1f3HchDVzIwD8+j7+67/jeMu47K35Gxs8rIODXOavXvnM3cCED//g8/uq+43vLuO+s+J1zfl71f72/c9Fr3xl/Z17IwD8+j7+678z+To+Vv5fFz6uh1699p9e+C23gQgb+8Xn81X3H95Zx31nxfZF+3l4+v/adXvsujIELGfjH5/FX9x3fW2GZ7gYbP2YaV5d/yO8B9fb2tfLzH+f+/ddzDPzZH31Nwfh5H1+DkMzPswZ/LPl6FfPHCv8d/vxf+D2g14Ov/8m/B9T5M5G/fg/of/z49XtAwcev3wP6v/k9oHeCD1nnmct/vsKe90P//ddZLfoeSvh+iPtjfC9hzc+h+fz2u0DNfh7L7OernGsZwYRz9jL7vQ1mP98bwqDnY2c9f+xT8L/Gn/FyfDhzw9WEczN5jJ8zbwzPja+Nq+JfZ1/jY8af6+He8J/Fs3CPeVm7Z/79fdjGNbXy8yfulWO9XF1/Pu6E44PvN7Pfaelu0K8M87On8+dvI7n88f2cce+j3+dkze+w/fM55ry/Xb/PKbRhPkZ/jDlmzc86+vzhdxrz+Zj9nkazPWb8GT6zv8fM9fx3Hxlf6zxDjL+rLGrwgnkaejo+jDkW1uT5mH3e7NjDEVx//9z42vzdHOPeGH9PoJnnbia90HMy+11bZj87a/y5dH7vv/sc0d9zt+Z15JPJ7Gc8edYlNGQd/720bia1xt+P59T3YVmXBGQd/53gxv3OdSFdzNeOr62LSQ/V/Yz3MNvrzvfBTs7jT8yN39vsPZeHYp4hXcz/HrXj8bzB115/9cPwLtzpRyQ2p5Am8zL+Hinn5+UhmD4S0Bufl7G/55/wxMXkMefrx7kuRo/5XJzXqr1i5FRnsIuL+T7h+8j5eZ7Z750xfg3b7OuM1v4cu09mx30eGT434l64B/7ehz/7tVPjfuJ6s78Db/Z3uyMaOLOvzxv7uLv8fk0cH85zzPg7VvMGZ4+175e8vIw/s8jvZZZ7qoxyccFnmqeLOicjmNQ552PtuZIpq6vhfi4u5u8Xf/u6oMsfPbHi/aL7n/TV2v2RKYuroT+fj9l7HbP/NzC+DzJ7v2iWPX/1/WLZ4AUzvk9xfBjfL6L3v857Oz4c7wP8XX//3Mw+r/kz+4j3Nfv90799ndfFyj328/v5+Jz5eynnz0wb1/7P/r5Up740ey9VLbjA7O88GPeO2ftxaz8v+vM5YPw9wBblMvw9wNwfYw5Y8/XBnznwn94b8v+D5Oekce34ecr3Fdd7sOfI9XzsrOePNTHkAH9vZcwBs99bxh/jORBgyAGrPqdSfX7N54h+P4/ZczL7+lokk/s5a63+Gp/xbwhZdH79x6zrYMg6s6/JuprM2/g118Qs6zqDrPNgfhn3O9fxz83MPsdxMXnMFdzPeA+zvW78vDHSn5gbv7fZ+2nV51v880ZPw+N5g6+9/uqH4vNG/js0zT4PNP4uW+d7Yv55Y2SgNz4vY/8of8ITF5PHzD5vjGTQehquVXvFyBnX1NjXuE/4PjJ+3qjK/3/VB/7x/tZ+3pgpq9nnjb/7/5LA3/tgtm/NzgDjfuJ6vqbOjPB0Ue8ds9w3rpfqd4U6PoyfNzq1E4Kzx9r3S+afNxp/x7fZ71I17j0XF3ymebqoc9LsPbRTZ/Z549/KFsOH2e/VczXc25ozLUt9V8P9nB7yx/j9w7n8cT3s+j8OszW1dm9mCXA19OfzQf/HYfb+xJgRqt8/avw/jj/7XnVR8IKZvUdSfd7s4mKey/y96hzDexD+fIy/yxN9bs/7eprUGz206v9SjH9LxKK97GPx55lZ/tP70TWuPx/n6/tnfyepU38/9M+e6w17wWyfm+0T4/uFv7pPzO4juU/M/t9B8Hvdfvu/UrPf9272ukPvD/h7Rud80e/oN3tv7Cr23Lx9jXN1PB/03jiCyx+zzHje8fcE/4vzznn/cCbPw4rzLophPkZ/Qhi8i2oyV08Tzvh3GqKa3CeqyX3Mern/6vWr169ev3r96vWr169ev3r96vWr169ev3r96vWr169ev3r96vWr169ev3r96vWr169ev3r96vWr169ev3r96vWr169ef7uX2fcyOb9HIKzh2nnfvMHXXn/rw8fP2Z9/P8Hf+h7Iho6Pn5fWft+Hj5/Z90rxv6k+L4T5eqm+VyoK47l+OfteqYXBPf+vfa/U/2vvW6Aky6oqX2RE5CcyszKrKrMqq7vBNQ4OLGcJEZlZWVkKWgLSAoIzjgsRnZGszCoQ+TXSNB/BQED+tPyElo9oIz/5tSB/aASUbhu/s0bUQUdncImKn6XOuEZmZOY1cert2LHvefdlxo3MrIq3Vq3KeO+8e88959zzue/ccxcdnFWOtLWhZHSI+XDR+66s/xbhOlx8itye2Jxwlac1RPpc2nelctAWBX2Ml0fFM2sL50FdwC/CGHl+Y85Tk+59vEeURWozv3jflcqRw3tG33xOfnCif2wqB22380HtxSjL0fwU6Z2yPUOco2nwXdA7v0p6B/NPDUdvv0WNnmWZn6u4KN5nfaD2fqXNuYyv32P9twRNUugDb08d0jWtvizq98TutTJeqvxTnosov0q3TGSDugLnbJPufZ70Aeow1geefrO+8yufK79D+kDZrd3qA7X/tEwffIH0QVnONtfZMvgHgj74bxNxff8p9T1R0ned+r5EV+j7i6SLJuB9liu1B/agns2RaC+UW6tQ1RRInLe+6eksT74XxDOenyhXSt9MZIP6A+dxk+79A+kIbJPjMU/nWd/5lcvwXzt+/Kht5m51kbevPqQPvkL6AH2PGH1g8HdMFm3+i6MPDEfltyAczwVvfiyK93n8Y70z1jt70TuLPcYNW++0eu1eaXpnpZ71jW23euenQO9cTbRE3D29g3C70Tt1Z/ye3klzNkS83rH+R6V3vPqUSNfEenkzZj4hvqo2Ddc1S1Wb5ptI72CbrHeq1Ka5O80VVX/V45uqk6f0DtNQnd2yW72jcB51/dJUMqpsb21o7a9tl+nnbyb9rORb+TAsv/8R9PN9SObQXzNeKt3NfqE9ywAXvOf5hQbn1RDcrZwonIcpj8pu5Ne53v/tPV4x8zfVWiqfUbWYZowd9Y1riPP2TNm8+m6aV2pt3ZtXBv899aLNHwm0Wcv0en2N/j4O+CkcjhIOBv+wXr+5vHy1JzRG36UsCX0v2e5lQTcc9xLhbPCPAJwnZvrpYO9k0GYD7rEeWhbwOG7DZ4Hohu/O0O9U9DpRQq9lopfBbzn0UuOfcOh1QsAvO/RCWp6gtgy2kRV1CJC+zH+DfwTYo0fRvKnBO16bSk/W6JmqiYBzdSEb5AF/d1P5BJ48KvlF/LmO34IYG9PrBtAz1wX0DPbn8V+N55iDH9L3OLVlbSP/1TcwpY/RD36645NMV2wj5flreZ0iVWtmiDWqOk0a57OA97c6css+FfLZ2kpsF6JjXuu/lQ3KVYqY15uT+cW+XWo7oHT2sqCP8fKEeGZtnez9RpuC8MswRoTHv+19vPdSinmxTY55lU3BezhPn08yjONh/aL4tiTaVblcTEN8rxb43/rhe9yPwtmbd7vtR+Wmlfm2ryX7oHw0fJd9W4O/O9jo1zl6x2ih/CuEC9keLzcP3z9Oz+qin3n6bc/V/1nm80CNh+vLLUeOx5snOO/Z9nq+F/bdEPDTgb4nA/Ah3/Md4Hs2A7461qHC8fB5C0puGL9WAD9eg8Fnqm+m10kx/hPO+A3+FhFfqTqpxve0dVI3dlSdVJSFZrd/3J7M5ddEgE4Ij3QyGV0keOSJylu0PsvyQz9K+qssPxRzJxC+AfrrE0P0oYahy3k9J5Vt4n5CNuO2IdmMO4DOXwy0Wcvi1kNQX8Wshxj8bznrIScJh3O93+09XYVftyLohuM+STgb/H924ns1H734c0XA47gNn4VscG7buzP0OxW9TpXQa4XoZfB/6NBLjf+YQ69TAn7FoRfS8hS1ZbAYDyN9mf+Xxgq66k8i1kNUm0rP1OgZ6gZcD/ki6UQVizDOfw1z/c8JZ+W3ezwoW8Njv0it4dWon9CalLcmYe/mY/o7x04cr9gGx/R/D7Rba4T7Gcf0A9c4ps92H9PXerI27Jj+K+OYPrqf3cT0c43iPvK/qn/2m82izQVH74xj+vLxePPkoMf0d+3x/kqN6b8Bxj+O6dPH9Pci/bXbmP4XQX+tNoq/9+pDDUOXH7SY/t5E87KzldlmGPy3AZ0fHmizlsXF9MuAX0xMb/D3E/PV/LoThMO53u/2nq7Cr1O+GI77BOFs8NcCzhyjqvnrxfRl85fzttSaw36ugcwIfHgN5KEOvdT4vXiybA2E6aXWQFjGMZ5UNonnzdtAV30vzZsavOO1uZeY/uGkE5EHSwGct2Cu/wDhrPb6eTwoO0+D/SLEj3WIvYc8QHgvpkea7Dg08WL6GdEGx/QXgXZvdfphe+SdzZFmf3p8TG/9j+psDiVjas9G4vzBTU+G1Z57jlGYdyhfodyvozBGnvPos7BPdD3F9Ngmx/QqV0jN4VyGn0AyrPYWe3xT+4C9vKx58V4t8L/1w/e4H6/WQqoc2tiYvkv61d6L9c8M/nqwM88hnjXgfaPFQjYoGwiHzzLApemMH9/nGjp10c88/bbn6v8si4vpcTwxZ/Gq8Ri82jvmncWrbJHqW9mu0PnKkwH4UI7/K5yY3vrAmF6dOar4GdqHgjG9Og+zJp6pvmeGNP6bImN63DuSXw14ljqmx303zW7/uJWMqv09VWVU6ahpeobzxYsvMaa/uaL+4pje4L8H9NdbHB8Kx8+1lpQeUWeJDo+/nbUYPYX9t7LBuZXCh1K6W8WWac877azWqH3EZ0rQh/foMO9QNlHG1NmgE9mg3uibe3TvA+RD4T4hrnkSuy81l+H3NvrHhrypBf63dvke21xlv8t8jo/SnLX3YmueGPzdYM5+wpmnhqPyR1ifNWj8IblV+8kaTj8cb9WhzYOuK+pJ8PF1BdJnrCsGdcXvJNIVd4xIV/B8COmK3yNdYe/F6gqD/19g0/+AdIWSfbX3tJZpXLLMl9tF8X7d6SfFHtfxeMbj2Y/xcNv494ToZyJyPPZsNjAm1sOoZ62vSYLJr7T1ONpt1smNTH+fMHy4xslXSR/OAv2UrWKat0S/GK9NUr8t6jfHY3pmFLQq1j9bgJMa40wA53qzwJm/5ag6Ft63r5aAx3FzfV+08S3nPa4FwPfUeOcCuE0G4LmGqMHPAn2axNMWvJ+Cp6rOoaJZk+AXHJ4qHnk8VWsdLUE3r2az59Nl4t5ENsjjB3X7YVkmlJylnXuFL6zmXk3gxrJ1SvBJrYPVYTz51egmGc+aWgdDPjWh35B+UDW4Y/WD0WwxC8uZ8pNZlyvbjPww3aD8ansX/WoVq16utvObmv0wR4COMbZzVvSL68xsO2ep39HZzo1tT896ttPgOxVtp/LbPD0baztnnfeGYTut/VjbafBnHduZpg5UwVNVM1zRrEnw93F4qnjk8dSraV1mO4/Qe5er7Syr5Ryae9dG2s4GjCe/Gt0k40luO8v0A9tOJWcxtlOt7cbaTnsX16+9b777qd9jZOz7Kup37zt1LP88/a6+YTecftQ335hvuJ6eNPgfErqd7cvl/A37Ioyf81xT27bd1hZ8TKTOvFK+u7POrPrdvZYNzvuqOtPexe/0o8qZK6ulxzneBv80Ry+qPDxvfUHluam8dGVHuP5ZzJk8WVbM86YYq8Fjjb+G0zfn+D3b8Xn3o8Yf8jO0P/h5Dj/VHkBvzpXtD2Z+evuDEV+1P/gY9RPa39QQbaI9wfeOOONR+6I433u3+7xudOzpcTEWpBWvRSwJHJoODgb/SmHTauJ9xYujETggzPEADq8ROKj5bTmSB31uvT7S5h6F8eRXo5tkPGeVze3LWYZ+Q/Pf22MZO/8Xs7Acq5xg3n+K+p33uQ7LHncDe6h20y7uS7g3xUZqj2vavfCFL6nqnCLeIX31XsdmDHtfLtsMtS9X7ac65vTj6WaDV3tWVd9Ngv+Qo8vVnl3c01Rlz67hu5c9uycqjn85Yvy3OrFRmj2AhTyrPYC1CJw/Hamnr5R9xqynq+4zrmWD876qzkQf/F4UG+3HXtIYOfpdRy8Oey8p60W1l1Ttmzzu9OPNc4O3fZchvRDaN/qHTmyE9ZlS8PMqwEnx8xThbPB/7PBT1aPy9lleJeC5LlV+LRDd8N2awLch4E9SP6FaWA3RJtoTfO+IM56GaJv3517d+z0ZgEceIfyXHHu6IsaCtGJ9dErgsOzgYPBfdmKjZYED4nUiAge1r5lx+DsnNlI1ig763PqfkTb3BIwnvxrdJOORsRHuT2eb69Wjy6/dzv/FLCzHai/5Cj1D/X6S2le+eaw9xpoQoTpHe23X6lse5thoppfkMI6NBv2jo0CbKzE2WoHxH5bY6Bohz+PY6ODERlaH+aDHRv/W0YtXemy0JvTiQfffzjj8HMdGxZUyNvp2x56OKjb6DmHTauL9lLHRAwUOhzk2emikzR3HRgcvNuJzXY7toV2sUf3dZOcT1ZwaqKkUkl08Oxzhtxy7oOoPeTm0ZbXJ2C7gd8Gj9Azfm3b6aYi2uE/kS8Ppm3Nnftix82nqcBf8xG/Uip+hb/KPc/ipfNg63GN+lp25x/z0YjzEV+VyHKV+VP4B2iW8j3Ye3wvFjVnm56iwjpkMwIfyCG5w7PwxMRakVeicxJDsMg4G/wzHzi8IHGJqrCEOCBPKr/pxx87j+2YPD/rcem6kncd8l/xqdJOMR9p5tF9N6Dc0/z0/P3b+K1u+QM8wD/MYPUP9zrlJKi801h5jvvA3kz1G3TA8nqyuM94hGcM9Lwj/Kkd/qz0qVXNqWSdmmc5jX6D3VL6t6Q/Vtup7QYzf2lB+Un7/XO93u+LVod82XrQzVXyHiUzbGIbncXH7xyJokjntKx5l9Ix9r/yyfUXKLwvxU9EF21C4WBvKx+N8bmszdh8m1x8/1/vd3uPFsoE0OCbwYR/6XZP9MEtAJ88PZr2M/aIu5X2Yx6lftQ8zDa0KG6rqrsb4BLdE2lCTm/2woRhfsA31cuDzi3WwZ3ORZirmZV2t9D/SnPeCov1T8CEb9DEn7kkdx6p9DkcEvThW+2SkXO1n7i7qa5ar2BrNnhwq3qrvb7xfBvUyxx/Toh/UX57/Ze/mrFk5JP7Xb1X0v7z1kLH/VVxsY8f+1+B7zM+x/xXnf31pn/yvLx1C/+vLY//rwPtf/3QI/a+vjP2vA+1/faU3AFXH0HBNuyc+3jcL7Ymf7SXoDKPeS+x+82H5ZorHmbhXE+3MEux0oP/8enC3/9kw/IzQGSXoNx6l++d6v9tVL3Iceb6h34h4hfaEo994zIFX30TUnkaPJpm4Z3JnfGEaIy72OyQrSkaRp9wuywnK0QO7X/t/Jhscf4o5j3ZDzXnUCQj/9WLOK7uCNbXzq9FNMp7Tyq4gXdmueHomywb1kmeHkGZq3+1ReoZ2m+VG1apVdoXHETpj0NpjnX1P4B9/C1V2QNXe5TY7UwUuD+j9ndY/KuT4aAnOoTyL047tUjz3ZKQsz8LgvTwLxjfLwrZsVDqijLasIwz+PpE6YhbGk1+NbpLxSB2BflyMjkD4GP4jb7jOtFovUToC/UWbV1X1hfJDJ6DdP53I5Nhr2WBOCreD+If0EOsMg38IyAjn8qep3VPUzdtt7Z5/7+gMJQOev1u1do9aS2B7l/+NtZofNqVxxHEr34bn8w+Cfv9+alP5+bFyiLUxv0DxkJc3pGinYgX7G/NlFHxobWZL2Mq0NVMK3atqpqh8Ls51uuDIqMof8dZqyuqRcA0pVY8o7X6ztQ3DVe03mxX48H6zxzr0UuP37EDZfjOuRaj2fDG+EwKWfQQ+g3v0fCjkVvHhmMCH+XB9pM8wmvUq7TN4tX6GvTeRc7JUHr7yGTgfTNklnBesn/GZvYu2ZEH0yfHQ5fId44Vk60b1HeOFMBdG8x2j2Oe42+8YL3X0qGev82u33wiUr3DceY9jrdD88L4hKF9CxfxMn1c7vkSa/NqCpyq/Nqae3E0OTxWPPJ6W5a56+w2W6D0VP2Xi3kQ2yGOu580yoeQs7dwrfBg192oCN5atmyNtJ35XyK9GN8l4zijbiXxi2+l9u8mvqvrBaKa+IfKanJfroL4vIj+82MbezfXEpybK8Vfv8twJxdih+ftLjs7Zj/oPyi9lP/ADFf1xT+eU+ViGT0z9B1VLg/HC2gvKXzfa4965FLTHfZ5KXkL7qG+N1CP7WasAecp6xNvXnl8sHysCnvc15tciwbMcIU1CNTPYR7ZnU1lcTVj2EUK6iGUSdQbD5BevH3zOWZfbD7lVe05Zbn/b0RnDlgnWGSgHvC+9rP7BUqDvqvUPPr+Per6MZ8sBnP9rpK4ZzR5trWvQZ2Vd462N5VeMXClbpHTNSXqG9ie0rxP7UXqirC7KL/QGkPZbU+H77vZ79F86c9/L982v3X7rtbmPayWL9B76kgh3UPM8QvnBhy3Pg9tXPMromVoL5/zgo+I95qeiC7ahcLE2VNzLfqa1GbuulmZdYVA2kAZqPyp/R6sH6pzgupr6FmZ/L4l+UZfyutoS9avW1Q7qGswU4Lz/e5y1nRzlHmeO3z0fW+l/pDn7w+pbtjoXhW3QMeAR+19pvmX767VeLQ2DPxEpV8ar/ZArb83IW7fNr5g1I8VbtWY0S89QL/Oa0bC+h7+v90B9b5kNjJvhYnyN0DhCe5fwmaI757sejcCtzG6G9hehH8R1PM71frerXoF8V/RD1L4nXn80vYR+kFfbhMfF7e9lDTy/MN81tOZtv0OyonQs8pTbZTlBObJ8V5UTx3luaXRo/Lp7SIeeidSho9m7U33dfdg61GimdKhXY4R1j7LbSod6dhvhQ3b7fiO324XMqRw0z24b/LVC5jx+TsK9qjloho+Xg8awWRa2STH7a4b1zeX63oNR7aFRZyYjbqEzk/+Dw8+qZzaWnZls+Kg9NPYun7+b/405hQ+f1jjiuPHd+ax/3Ab/n6aLNn+A2pwS44iVgSnA9ftq/eNFWjSz/j7L5I5j8bL8+9Bewm1H56TJlS90jsr/9PYSGvyjHBkddq684ePlyu9nnvCUwId19ONHqKP5bHtPR+P6UcgGh36Png++rVR+J/Phhkj/bDT7ELR/5u2B9fYV5FdVWfH2wPI+BNSPbKOVXcJ5wfoZn2GMa7bEZBdr0vFeOeQ3woX2dKraEZxXMSPw4j7UdwOOcRcicDtItUBCMe5hqwVyBPrPL4xxQ/6o/Q7JCj9jnnK7LCdqT6fyP/g8lv3Yy1UT42Lb/9oDpUN1Xjbyj3Vo1W+AZXu5jGYxe7lQ77HuiV0n5LkT8jdD8cWbHX9zP/YYe/uNDP5tjv+k+FmHe1W/6fKeDOUPM2yWhW2SWt8I6RPESfG+7Czcr+s9MH6izU7hD6sYF3VjE54j/Psdfto7SAuM/2Ji3Kagz0LWLxv4rqIrxrgfntY4hnQnx7gGfyvEuB+jNu19HAfSkmUAn9UA11qtf7xIC5a7IyV91uhvFeMifCjG/czIY1zfzsXEuLdVjHFRbi+3GLcm8OHY6rcqxrjTDr2GsReW8Z0AmmWZ1uf7H+MWcrvbGPf3I/2zJownvxrdJOM5fZhiXG8dWtmlWBtt76ItSUn3M5tfi+HuxLXXvskRXw14jvBf6uHZgnHY/3uJNS+e2epcXNu6uHV6a2dnfXvrGLWfX8bjnB+XbE63eI5ynF9Tvd8WXzM81j5B+L8Ge/y3IKN3wor+crh/ceBqgf/vbEPca3T77810B+Hr3UF467vVHcTRns3CM5xj+TXX+430wrYMjybBfwXWZ/JrGt6x9xdF/9PUfx/e4h7OcW6rLu5h/Yp/JLnFsQ8x561zyeei9vEe42ayM5sNf16tbm5unF09314/s7N9cWd9rWxeDbv/C5tnd9pnL17Y6nQ6qzvtC6Puf/301pntrTOdztn1zoX1zulR97+xvtHZ3Nza3N7Yvnh2fft8Wf+v6hmMGXo2bDmdEeMcVvubnTMdjF0T4L9m/tZ8kvZ3ttPWu263LXZ9SLdoH8eCOTEIx+8gzCMB5pEAg/p8C2C2AjDnAeZ8AGYbYLYDMDsAsxOAuQAwFwIwFwHmYgDmUQDzqADMowHm0QGYHwaYHw7APAZgHhOA+RGA+ZEAzGMB5rEBmMcBzOMCMI8HmMcHYJ4AME8IwDwRYJ4YgLkOYK4LwDwJYJ4UgPlRgPnRAMyTAebJAZjrAeb6AMxTAOYpAZgbAOaGAMxTAeapAZinAczTAjBPB5inB2CeATDPCMD8GMD8WADmmQDzzADMswDmWQGYHweYHw/AdAGmG4B5NsA8OwDzEwDzEwGY5wDMcwIwzwWY5wZgngcwzwvA/CTA/GQA5vkA8/wAzAsA5gUBmBcCzAsDMC8CmBcFYF4MMC8OwLwEYF4SgHkpwLw0APMygHlZAOZGgLkxAPNTAPNTAZiXA8zLAzCvAJhXBGBeCTCvDMC8CmBeFYB5NcC8OgDz0wDz0wGY1wDMawIwrwWY1wZgbgKYmwIwPwMwPxOAeR3AvC4A83qAeX0A5g0A84YAzBsB5o0BmJ8FmJ8NwLwJYN4UgPk5gPm5AMzPA8zPB2BuBpibAzBvBpg3B2B+AWB+IQDzFoB5SwDmrQDz1gDM2wDmbQGYtwPM2wMw7wCYdwRgfhFgfjEA806AeWcA5l0A864AzLsB5t0BmPcAzHsCMO8FmPcGYG4BmFsCML8EML8UgHkfwLwvAPN+gHl/AOaXAeaXAzAfAJgPBGA+CDAfDMB8CGA+FID5MMB8OADzEYD5SADmowDz0QDMxwDmYwGYjwPMxwMwnwCYTwRgbgWYWwMwnwSYTwZgfgVgfiUA8ymA+VQA5tMA8+kAzGcA5jMBmF8FmF8NwPwawPxaAOazAPPZAMxtAHNbAOZ2gLk9APPrAPPrAZg7AOaOAMzEswsY+7vW+20wywCzHIC5B8Dcg2B43T+/LH63NYYUazyb7fULadcwOqs2tnkYm40zbe5IZ61G/SE/8Jn13yJch4vP19Z9sT/Dh+ljvPZq4duzRndwHPx9AfmbLyOfrxVwLFv27gyMf9i02GxvtNPK3er6/snd6unLUe7q9KzRHRxHVblDmrDcNRLQYrO9uZ5W7tY390/u1s9ejnLXoGeN7uA4qsodyhbLXYq8t8329vbYzh4uuWvSs0Z3cBxV5Q5li+VuMgEtNts7Y/8uO1xyN0nPGt3BcVSVO5QtlrupBLTYbF9M7N+1O/snd+3Vwy53afMQ2+20NY4H62jgeNWeyrT1CwtZ5LMTsO8TafqOlkXrv0W4ppJFVS9X1TQ0+qykweeSLJ5K1L6N9yoxXqxZsULjvSYJPoU9vhrwYVm8S5q+o+2x9d8iXFPJ4l2yQd4gfTx7fBU9a3QHx6HssfEX7XGNniE+qB9MVhezQVlBWqFOw7bUPsjFbFAHLgH+rDvZT8A9SEPzEzrt1bGfMPYT9sNPQHke+wnF/wfVT/BqxyvdfIKeoW42/irdPEx9ijLG+hRza4eoT9fG+nSsT/dDn6I8j/Vp8f847krTvo13HHeN4y607Ycx7kLdyX4C7jUanp/QOT32E8Z+wn74CSjPYz+h+H8cdw3is1t9ijLG+jRF7db/r083xvp0rE/3Q5+qM5bT6tPC1x29Po33dcf6dBCf3epTlDHWp1hbbnj6dHVzrE8PV97KHD1rdAfHUTVvBWVrHuAeVyv+firJveX24RhqYgxJ8/06q2dT5nWZDr5zjN2ifS9XkvPZkAeTQNvzEfScGDk9185fzvSsj5ye6ztp6fm1/PuU9EyaJw7zN00dzPXN4wJ/7Cu/prrZpatO9EQaXdKNCE/PZuBZo9vfj9VPwn1P2Jbh0ST4x/YaUHW27P1F0f8k9d+Ht7iH+1O4rbq4Z/C53FzovZT7MLbOdr9u0d4Qedq29u+fpP32urX/HWnav2DtPyBF+532Jfpcmwb/NWv/O3vtZ9lwY7z8euAw2u7oth80hLY7AbwfvPe2uelLbX/XLtpeL3mez9dc3z+25wTG+OuJctyjY07rf1T+uqrB661/JMrDX/XiB1V333gZOmsw/6dq76rzeicIHv+29/He83sMW6Q288v0Rk08q4t7aGeeTbELnwOQXwc1rkwVY3tyoermK7mwdxfFs3l6j89TUP8bDnxvgvpRcqvquuMcD83JI04/86KfGBlKU/s6Xoas/1HJ0GIkXY123lkK+IxliOs4q/8NB77HvPXqdKeWocTrZwPndiOuXs197wxnRSd1rvUC9cNwjIOHl5IJPp9NjXF6iGOccsY47eA1HYmXOkNk2ulnfo/9zIt+5sV7e51fCmcbD9Kbz+dT/Dzm9IPv81m73h4kbMvgy84kP+KMYymi76ND7HtK9J34W1pnRuA1TF+Va97/RU/Ach/uV3p/zwPNmDY53Kdr/XQ1WQ2de4BnAiP8Z6HvX4O//7bWzwecC3yecZrvWoVPv1wytiUam8F/rgeU4/ukuX56KTlUa6CMA8LzXEB64ZxZpmf4HuvTJacfxEvpU54fqb69Gq72XTDEF+Qbwv+ewxdFZ0+XqW+eywSTX4r2+C73HdJ7o5L5MtqyzBv8HwvaqnXwS2uWvf8b3STjWcvxuJ7WT9DONaHfkPwru+jxX83LRYJHfitbzja2LvpBfpgtUnrb3kW9Xabf/2pI+v2+c0Wbf+Pod2yL/TLU/bVM45Vlvh5dzMJ0mRfvGVzKGgHtCrGm9d/KBmmSItaciqQr+7T4rpJrng+8DpRlWib47EuF34zAr0Y4ILw6T9DzN5RPWI/Ay4u58P2Y2KaVhcc4I+CnnTFifzP0bBxzhfvxYi7MY+eYS/FnxulHncNnbbVEW56fMi/gMUf0iDOO+Yi+60Ps2zvv3vD69l4nuS051fub9TjbtKsn+vGagbbr4t3jgb6/Dvq+K/x97UT/OJCGHLOk+S7in0NXd+hq8HfrjUH5xoqPns5Vaww8bqQXysQxeobvsT6ad/pBvJQ+4ly+NPmrBV/Qb1Z8Qb4h/D0dvlRdf/R8XMUXpD3nu/J5gV7eeWqZL6Mty7zBbwjaqphlBsaTX41ukvHImAV1bhP6LdOv+RXDfzUvFwke+a1sYYv6UfYO+cExCz6zd1Fvl+n3+w1Jv69AzPIAR7/vp4+o5NN8lrTy2V5V8on4s3x6vjeO15Mb5ccuZoN2lmUX4wakHdIry/ppxzQf5tyuUX9ZpuM9u9ciXIfMy0vxnre+kF+cR5EmHi50uTdHEF8Vf/J8U3pAxTcT2aA8oSyyntjqEYV1YX5xHkVsLJPrmR8I6DtrT/2fZXGxC9Mmv1S8zbFLTeDv9dMU/Xi8nRNtxegP1AfeWpLX1qzT9zBi6ibh9RqwKU8gXtdE2zncdWTbys5QZ9tm8NdD30+Gv99Ato1zfrMsbd0WnPutkrExXQ3+6Y6PrPjonTmuYlyOwZFeyg9ScSDHLlXXBJR8pdwnj3yxeRLiC/IN4Z/r8KXqOsasgGe/M78U7fFd7pt5yLRNLfNltGWZN/iXRMYuozmvXMcuqHOb0G+Zfs2vGP6reanOJG/RM+W/s37FfpAf3vcWPK/8ukj9fhPpd8MnVr8b/N/MFm2+vqJ+V3EN2/Gq31tUP/v3vSX+XIqD+r0lZS3KfM8Syx/io3xmVb+FbZyy52ptdCIb1Od96x507z3kf6MuYf871s7mc+XtNGeRN7XA/9Yu3/PsN8+HkG54P+kGe6/qt9iXg274oLOWYTh6usLTk01n/Eq3zIv39kpnT+8ofiaeV9F6x/pvZSn1YKF3Ytdm0vpBhd7x5iniy+uizDu0/ThPEH4Gxojw+Le9j/c+R3oHdRTrHeXfqrXZO/PfSO+k+mbJutubD4n4HT0frP9RzQclf958SBNzFfPBkx/EV9WpYL/Y1lhwPij/eILg8W97H+/9Ec0HnDs8H5T/rtZf8vnweZoPyJu9zocYfwVxVL6YN6bY79v2rvrOs9cxtsQYE/vXa2W+zF+QL1MW907Bc4TfBl/my44v0wJ6sbwjXCPTvEPeZqKNUH/ch5J124/Ka6Aebtg3zknVxiy1ob7D5vfP9X63q160G9bosQA4NQRenE9i32gmAH7BgedxcfuLETTJxD2bP8YXpjHiYr9DssLPmKfcLssJypHtt1Z5Eqj/73y/O9h/2jWf1dNqzafPf+r200HJrbcGr/ZOIk8531DJjtL7zC/WNajzzY41CbbVA0rrL7XbmJ+RUV9K74V0VJbFrdsoPan6mdhjPxOin/1bH1o7U6P+suxwrg+lkcO1jRq1j/gon0rFaexvKb/Ui9Ni/dK79gg07Dhtpd4/ttTrQ2lzEopzghFn9NnuVi/uIz9CPhuuTyF8G3y2u/eATKdgDabQ2mKWDeqBNPFXvB6w/ltZUv3f8eRUrWMafVLUJkQ9UOaDGr5cu4R5h3Yb5Qrh52CMCI9/2/t4b4P0APpwrAdic0lzeW2THkgVu4XieMRxUrTljQl5FJP7PS/63usY58QYE9uvUl13X9J1mDOqdB1/lzX4CdB13+HoujmgF8s7wmEMqGKpTNyrOf1xH0rWOT5diMAN+y6rhcNxqKrrkSI+PQY4qXiT9xpZ/ivGp8cceB4Xt78UQZNM3FPxKdd74dodIVnhZ8xTbpflBOWI49OQ/r/z/e5g/2nj07UzKj5FWjS7/XSIrQHL8oTwyFMb32IWlh2l95lfrGtQ53N8arDbFJ+m8Zd0fMp5UOoMZpa9LPNtmtrrNUnPvP0drLfODWn8+/ctZWOnRv0ZDfEe9n9lfUvZ2K5R+4iP9y1F+SesI9AvUHqvqq/6FPJVsc1JwsHzva3vrPfeE8kHSZ2TOKpvNmnXg4qzWRPFmRtl/miX/FG1VqJ0Lq+FfLZVtPkckgUl50pO2F+oKieqn2HKifq+MTxerV/6JqvqsHn568o/UDX8jObqjALlG9eGNrbOOuOahy+eb+zVGzRc09Qoibd31n9LjCOFvVP76pA+E0Q7dd6EOouCa4GoGjXLoh/V1uS4rXFb47bGbY3bGrc1bmvc1ritcVvjtsZtjdsatzVua9zWuK1xW+O2xm2N2xq3NW5r3Na4rXFb47bGbY3bGrc1bmvPbalcJssRmKHf+d97ylG8mF/Fz7Q1rlc3Vd5HbYjtq1wpq8OV0/dJDc2vUK4U19o2+BshV+r6XpuXW67UooOzypG2NpSMDjEfLnrfFZ/fmibnyz+/VeWEqzytIdLn0r4rlYO2KOjDZx4x73C+4jxROeoT2eD8xpwnrqv+ot7cWaQ284v3XcWeR5jPyec2+seW6sxb3vuEbWKO5o2kd8r2DHGOpsFvgd55BekdzD81HL39FjV6lmV+ruKieJ/1gdr7lTbnMr5OkPXfEjRJoQ+8PXVI17T6sqgTFLvXynip8k95LsaeO466ou9sNbr3ZtIHqMP2cu74G0kfKLu1W32g9p+W6YO3kz4oy9nmen0G/42gD97ZiOv73dR3WS3lOvVt8H8+U7R5i6OLYvaHJs7LPjvWES59Ng+TjvhkQEfkf3M8VkVHfIRkWM1rj2/eeUJqj+VB0UW3VdRFrA8M/p2gD+6I0AeXv28y1jsl9DlUeuePEumdz1+heufPhqR3rgO98yWiJeLOeidU5w+fZYDLrDN+fJ/rNXINsfxKW3slXu9Y/60ATc4NBZ9C78TWdUuslzdj5pOS5QXxjOc8yq/SYRPZoP5A3dCke/9MeidUY6NMj1rfWe+9f3TWLbk2XFU7rGpQpq4PEzPvdtsPjsdormQ0/3eu97u9p2ttO7XtLdPPU83+cSn5xndxvzvCfyvo51avTaWfjZfKZ2T9HFuLTelnrjeVqiZTnfoZhjwqu5Ff53r/t/d4xczfxSGMQ/lQczTGNN+g1s+ob1BDpGGnbF5dQ/Oq7BsUzyuD/7pm0eZmoM1aptfra/T3CcAv5juYwf/rXr95/ZwX9xho9D1JOJzr/W7v6Sps94qgG477JOFs8HcHnPmsKXsngzYbcG8i64dfEfA4bsNngeiG787Q71T0OlVCrxWil8Hf06GXGn/dodcpAb/i0AtpeYraMthGVtQhQPoy/w3+W8AerdO8qcE7XptKT9boGeo20zU4VxeyQR4sUnvWd37FyKOSX8Sf6/gtirExve4PeuZbA3oG+/P4r8az7OCH9D1BbVk/yH+Et7EpfWzv5mO61vFJZiu2kbYO68Yln5Drmw+n/XanSeN8MPD+JY7csk+FfLa2EtuF6JjX+m9lg3KVIub15mR+sW+X2g4onb0i6GO8PCWeWVtX9X6jTUH4FRgjwuPf9j7ee0RP1hZFmxzzKpuC9zDm/V6SYRwP6xfFt5Oi3cUsbCfmxXu1wP/WD9/jfhTO3rzbbT84nknqB9tE3/YC2Qflo+G77Nsa/DTY6Ec7esdoofwrhAvZnhPO+PH9E/SsJfrhmj32XP1vOPC9CWc8XF9uJXI83jzBec+21/O9sO+GgJ8N9D0ZgA/5njeA7/mygK+OdahwPLYuo/h5MoBfK4Afr/HgM9U30+sqMf5TzvgN/lkivlJ1Uo3vaeukbuyoOqkoC81u/7g9mcuviQCdEB7pZDK6SPDIE5W3aH2W5Ye+gPSX0TX2m4TB/9l00eaLh+hDDUOX83pOKtsU+x3o1UOyGa8FOt8SaLOWxa2HoL6KWQ8x+Nc76yFXEQ7ner/be7oKv+5qQTcc91WEs8G/yYnv1Xz04s+rBTyO2/BZyAbntr07Q79T0euaEnpdTfQy+Lc69FLjX3bodY2Av9qhF9LyGmrLYDEeRvoy/w3+v4OuelfEeohqU+mZGj1D3YDrIbeQTlSxCOP8EZjr7yecld/u8aBsDY/9IrWGV6N+QmtS3pqEvZuP6eOOnThRsQ2O6W8F2pljP47po65xTJ/tPqb/zUQx/W3jmD66n93E9H8wJP/sPWBnvjCO6e/8+0qM6f/qCo/p/34c0480pv8/Q4rpXwL666tD9KGGocsPWkw/M1ncx/dibYbBz00WbX5DoM1aFhfTrwB+MTG9wS/2+lUx/SnC4Vzvd3tPV+HXKV8Mx32KcDb4JcCZY1Q1f72Yvmz+ct6WWnPYzzWQOYEPr4Fc7dBLjd+LJ8vWQJheag2EZRzjSWWTeN68EHTVv6J5U4N3vDb3EtN/A+lE5MHJAM73hLl+D8JZ7f31eKD8QtQN7Bchfjxeew95oM4SVzrR3s2H05ks71O1MSfa4Jh+DWj3ZKcftkcqly9x/l10TG/9twjX4eJTxPTeGSz5xTH9chr6XNJlXi0RxJd9C+YdzzmVF7QMY+R5jb5Ek+7dtydrXnzpzUkV2+Tv3Ztk2DtLMbYugMrLYhrie7XA/9YP3+N+FM6pc2hjY/qHkH6192L9M4N/GNiZf0c8a8D7Rgt1zh/C4bMMcJl0xo/vcw2dluhnnn7bc/W/4cD3JpzxhM6BKxuPwau9Y7gHwLNdi07fynbNBvqeDMCHcvx/CPwnjumtj9B5URzTNxz8cL+SyvnjmJ7z5LjvuSGN/6KIEVRMj3tH8qsBz1LH9LjvptntH7eSUe+8slgZVTpqlp559YVwPmJM/8SK+otjeoNfA/31o44PhTqAay0pPaLOEh0efztrMXoK+29lg3MrhQ+ldLeKLdOed9pZrVH7iM+MoA/v0WHeoWyijCH8DIyR9Ubf3KN7zyEfCvcJcc2T2H2peZPPnOwfG/KmFvjf2uV7bHOV/S7zOV5Ac9bei615cgkec2uceWo4Kn8E4VhGPblV+8kaTj8cbykeJJ4L0bqCz/5No7v8s3+VX5T2fNVCV1Q9+1fN/VhdwWf/xuqKNybSFa8lXZGqfmBsfHJzRfvOusLgPz9VtPkWJz7hOo2p4xPVT32P/dQj+xmPp3w8Mfo6zXnS8fra+h+Vvp6KpOtB8e0MX97nzbxDvYj6Ren+iWxQl6NObdK9z5C+RhvD+jp2T3ve5CdIXyNv9qqvkTa2pl+mr28nfW30itXXBv8p0NefI32N8j1F79uz3+79kfjM9zau7TFOZbT63SHZthuBVv+F5MF4yjji/1lWfW2rmfXjHuvDeTKOc5bXtpB/LQev6Yh+PLyUr9Ry8EKcua6D9TMpxjDj9IH4xdifNLV64uupWv+jsj+KR4qnvN6F76q6MXutOYfPWKeP2xq3NW5r3Na4rXFb47bGbY3burLbsmcYf7CPz9+dVPzA8W1+nev9326vt/dycV+25qHWTzJ6psbAOE8KnDtnN3YurG3vtDe2Ouub50+fvrC5deHC+oXTF87stFfPru102mtn2u3zq2vnd7ZOb59d3Vi/ePps5+z62Z3tjQtnz8fgzGt7qer+8XjTrIOtrpZ9I/+WqeJ+/k+tcdUE3ryGdX9YZ/jW3t8L4n2Ov3itAJ+h/HvfD+v0DHlh7c9mul6UPU98/sil8zWOAP0UfefhOcI/sEdTlXus6tOqbziMA8JzTkyW6dwhXuPA93iuHKHfc2Kco6I75uTE0N3gv0fQXeXszMJ48qvRTTKe01VzdmJruDOdEF7JhqozfITg1FqM0kPWFuoCw1HJoK3jjepMnN3WtH2kM2eHnUvFcxZ5tkjPkJYh/tcyn2eM1yTAHxV4MW0eDbTh/TKJzhW8xE9cK1e05D0+Bv9Yh58qv9jj53EBr85WUzUY8V18byIblJXv6vbDck7xvGiHf9sa9RHRTl3gh+3MEM6peKrOnqsJmjUJ/oZI/T4H48mvRjfJeKR+7ztvAvotk6P8YrlbEvDHCSa/FgkeeaziE5adOWoTZYfPlPBq3nMMcZB8CmUXVM4y676frOjLefxUdgHH7Z3xF9IFnG+UX6xH9sJffNfLxeezSHA+m2+BMcyocgrKzkLjGMngX+nwXX0jrcO9qt9I2R9Q30j5+yHy8c58rymNI44b3w19r38jxIavozZVHg7S8ijhis/wG+rvUh4A0iLmu69q1+6jrCl4PofT4G8Gfr+MfBycAyl0E+oe9R15jnA2+Lc6MqrWttTZw54umxN0U3H5aHR5MadVfDgp8OH48N0VdfmEQ6+y2Ivz25CW+K7SuTj/5wiWf4+eD36crmwC8+GDkX4crrvlV6ObZDzSj+vLAYN+Q7LireGUyYrRTMXpc/QM9SPvpfJyd5R+Vmu6aEuUfjbZTJuzUsx11H1Kn+MaKMJ/1pnraq3Dq5egdKk6J0Cdc4OxSDpbUtBL2ZKawIdtyW9WtCVe7lWZLWF6KR0WwhdpyzxoCXzUXjSVF8k5Q2ouIR09Xwfn0u1OzuOMg39d4Gh9pJWldpvnSSPz+ci+1J+Q37gAdFR2okZ/z4t+USdyrug89ZvL8MtH4sMNnjtX1Yf7YsV55+mpYfhw6j3OhwzpUBzv0QBukwF41uMG/2XHL0/j3wyeYRra8xPyb/6uop/p8bTMdzB8lO1ZoPfUfqVM3OOc+Px6ULcflmVCydlBt3n/HOmHjmaPd2dN+aHIpyb0G9IPan9BrH4wmi1mYTlTe8BYlw9rneBmZ38Xx/2YJ3CYbeeR6X4YZTvV2tFebaf1OzrbubHtzV/ltzHOxwDnGNvprdGVzQ3eTzhs24njjbGdar8C0+cqoM9obGfB093azrs6PFU88nha1XYiTT3bibEB39ur7eRco4NqO+8h+KRsZwPGk1+NbpLxSNuJfIqxnXtZH61iO70YUNUtiLWd9i7WZvDizlHp97J8HpYxg9+sqN+9NQkvhwPxUfrd+y7XcPpR9Yy4T1WfSPXN3yXPCd3O9uVyrs90LYyfc1LS5BgV8rzbHKMHR+rM0cQb+19TinVm1ZpStWxw3u8l3ngi7TVOXQ+yrG41niON8I9w9KKqMemtL5Sd38p6Ee3ICXoWe+5tQ7TFfVo9yskAPNIO4c87Pu9+nMeM/AzVz7/o8FOdH+DNubLzA5ifMecHYF1hda5FnX5znw3RJtoTfG/eGY+qbRw662Qyi6uvbPBPdOypOkfAO+tkReAw6eBg8E8WNq0m3le8WI7AIeYs9acKHNT8tjyngz63nhlpc5dhPPnV6CYZz1llc/vq8UK/ofmvzrepOv8Xs7Acq3q3fG4D6neurz0se8w1bef20O4ctDtDsZE6vyWtXBe+5G7l+uUVbcZezpyJsRnqrIBlpx/vfBlPl6u+WZffFKHLMTbCOcCxkXcejbJlVc+jOVVx/DG27E1ObJTmfItCntX5FrUInN8cqaevlDN0WE9XPUOnlg3O+6o6097N5c/O3EkrR/45KTFy9D5HLw77nBTWi+qcFHUmyAmnn5hzquxMkZBeCJ2J8lEnNsKzR1Pw8y6Ak+LnNYSzwd/q8FOdteqdIXIXAc9nrubXAtEN360JfBsC/irqJ3TOa0O0ifYE35t3xtMQbfPZM3ft/Z4MwCOPEP52x55eLcaCtGJ9dI3AYcXBweB/w4mNVKyJeJ2KwEGd2cM4/I4TG6nzNw/63Pq9SJt7CsaTX41ukvHI2AjPXmKb6521nF+7nf+LWViO1TlJV9Mz1O9XUfvKN4+1xxjTh87w3Gu7dnb7YY6N/nIcGwX9o7+/wmOj/30IY6P/O46NDnRs9IJDEhvN9Ygxjo0GY6MloM1hiY1WHH6OY6PiShkbfb2Qm5roI2Vs9G8Ah/2Kjb5R4HCYY6N7ibk1jo0OR2x0gWKj5T20uwztXkN2PtF5qpdkt6xOCte+Mfj7OnZB1b7x9gyoGiTqTG5V+2aJnuF7s04/DdEW94l8aTh9Nwn+QY6dR9lMwU91ZivyM5TT8lCHn8qH9XKiTwp4dR60+ubPMR7iq3IMlqifJTFWtEt4H+08vheKG7NM55PE5EWcEGPkvIiHO3Z+WYwFaRXKhQrJLuNg8D/o2PlFgYPK1/BwQJhQ7tkjHTuP7/O+54M6ty5E2nnMd8mvRjfJeKSdR/vVhH5D89/z82Pnv7LlXFMK8zCX6Rnq9yVqX+WFxtpjzBeeInt8UGsLXu/ob5VT69WSqFpbcE7Qrp4N6gzOaVdtq74XxfitDeUn5ffP9X63K14d+m3jRTtTxXeYyLSNYXgeF7e/HEGTzGlf8SijZ+x75ZftK1J+WYifodp/dQcXa0P5eGyPsb6htentw0yTYz0oG0gDld/MPvTLZvphTgKdPD+Y9TL2i7qU92GeoH7VPsz9yEeP8QleEWlDTW72w4ZifME2VMWHCF81Z95opmJe1tVK/yPNY2q4qlqkbIPe4MQ9qeNYlBtlVziONfifi5Qr49V+yBXqa5YrpV8RnuVKyaHirfr+xrVtVE1htjfYD+qv2DzaP+t9IDjo/td7K/pf3nrI2P8qLraxY/9r8D3m59j/ivO/bt8n/+v2Q+h//cbY/zrw/tfvH0L/6wtj/+tA+1+39fwvVfuLa8EeVN/sy5ehb5ZlPt95bMrPwPYe3O1/Ngw/41gAT/Qbl+j+ud7vdtWLHEeeb+g3Il68bmx6HP3GZQdefRPB9k9E0CQT90zujC9MY8TFfodkRcko8jR0VgPLYH49sPu1/2eywfGnmPNoN9ScR52A8PXeJC6zK1hHML8a3STjkfWfka5sVzw9k1+slzw7hDRT+26X6Jk6L6KWDepGz67wOGJr5Rv8AvDvZYHvkKE6qPVAm8daBS537/2d1j/yz6NBnEN5FieEHHs892SkLM+Ca7eqXAfGN8vCtmxUOqKMtqwjDP6ukTpiAcaTX41ukvFUPstN6QivbofiP/KGa8Sr9RKlI9BftHlVVV8oP7QF7b670d8u+5o477mdGD0U0hn3BBkZzblkRd283eZmrVbUGRNwL0VuFsty/jeeK3OmpXHEcXv1ugz+PqDfv5naHFY89HaKh5AWvE6maMd1pfBvzDdT8KF8s/sKW5k2J6bQvSonRuVgcU7MAxwZVWsv3plXZfkmnCOo8s1m6Pdw6bW2YbiuCHrNCXw4N+whDr3U+L0Y1qv3gvio/Xn4Lr43IWA5BjlBv0fPh0JuFR+WBD7Mh4dF+gyjyeXSPoOXy6VkxcvlKpMVjh1wL8AJeob6kdfny75TsH5W8SvakgXRJ8cyGGvHfMdA+UjxHcPGgWssSwIftnuPIVuHaw5eLMh2B/vFeczfMZapX/UdIw2tin2Oar05Jjf78Y4e9ex1fsWs5arzMZWvsOy8x7FVaH7geI8GcJsMwIfW45/i+BJpvk0VPN3tt6mnOzxVPPJ4GvvdR/m7e1nrYx5zPe/Q2h+2k3buFT6Mmns1gRvL1nMjbSd+V8ivRjfJeM5U/dbjxc/5VVU/GM3Utx6Ot9Xabo3ohf0gP7zYBuv+39gox1+9y3MnFGOH5u8rHZ2Txg8sdI7yA2NqWL6moj/u6ZwyH8vw8fxxFdtw3XdVe0H56we9VsGbIvXIaOptHo5aBTynQ7VxQ9/DpjL9PWwh0H4ty6K+D2AN5noAJr94/eBdzrrcfsgtjjskt7c4OmPYMsE6A+WA98SW1YUJ1UuoWhfmQ/uo58t4djKA88cidY3xaj90DfqsrGu8tbH8ipErZYuUrjlFz9D+sAwNa7/0k0aSH1z4vrvNQbnDmfveGUL5Nc4PLq5xfvDByw9mP/NyyQ/+Iq2rjSo/+IvOutpBXYP5UqSdHE1+sLaTV3p+8D84/leab9n+em1MfvA/RcrVaPKDtVwd1Pxg1Mup8oO7vcQJ9b0llG/KcHvJd1Xfd7gPRXcv3zWE2zjf9fDmuyJPuV2WE5XvuiDa5TOo0+jQ+HX3kA5d6RV7OBh5btXX3YetQ41mSofy92yVR+jZbaVDPbuN8CG7fTfg32jsdiFzKgfNs9sGfw8hcx4/vXM1y3LQ+OxML2+VbYSyScZ7lXPG+gRxirWf+M3lvj37mfac1CLvZbdn8a47/FS+hFdfJvacW2/PEZ+/m/+NOYVnZzWOOG5893jWP26D/7bZos17U5szYhyxMjADuN6NfCikBcfNZXLHsfgC9ON9w2sS/P0dnZMmn7vQOSr/U+114zyY73RktGqudFm+heGj/ALM/Uqno/084RmBD+vo7x6hjp4hesXsLbC8CGWDQ79HzwffViq/k/nw8Ej/DPdV5Fejm2Q8Z6ruVRr2PhS2wyrXxZ6hfgztccN+cF6wflbn/6ItMdnFunMtal+dyZ7/jXHknBhrJu7VRDtzBDsb6D+/OMZdiMAtFE+rNjhOVvYhRYx7DHBS53+zn27ygzHuMQeex8XtL0XQJBP3VIwb8kftd0hW+BnzlNtlOUE54hgX2+XzWFLv8S7b7xna+/G0A6VDdV428o91aNVvgJ7ORZqp/Z6sQ1Hvse6JXSfkuRPyN0PxxfMcf3M/6gp4+40M/oWO/6T4WYd7Vb/p8p4M5Q8zbJaFbZJa3wjpE8RJ8V7FN/ZuLgd/MdEPVwc4jNleSfFV70iaPr7guxyzGfwvQ8z202S78X3zHUzOcB6kkLOWGA/SbIbGY/Cvc+RMxaCenKn9mBwzIr2m4Rmvd7aS0KuIa2ZL6MV7xw3+5x16qfE3HXqpOdAiGKQX0hLf5b6ZtmxnU8tiGW1ZFg3+HZF2tg7jya9GN8l4pJ01ut6JP/Qbmi8IH8N/NV8WCR75rWKVaWqjLvqJ1bX2bq7v3j/R3+50Sbt1wgPXpRQ86mSE/7Cw32pOsM6dJVzO9X6393QVcq7W/ZD2szQeg/+Eo0M8mcgvliFvfRTxUeudbPeVj2/9zDv9KLyUD4m+whHqW+25U3jF+BEKL7XubnAzAr8UNqcs/uD1UoP/nCMv3no3jj+WL2xzkPbMl1AuV6ifqvUjMK5geUGclxy8YmIOhZdXi2I/115Rp4bW/P6w4tqrFwuW8cXwUbTntVdcqwjN6ywbnMOst7g23H5815oWuHPc+T8i/Rn0z/Kr0U0yHunPoN/YhH5Dc8Xb+1/27c1opuYWx47oz7BPrPwOnBfsz9QFDhgTqngEfUzG4SDFI/9QMR6p6o9WjUfS+l4FvZTvVRP4sO/1zxV9Ly9+K/O9mF7K92J87TfSlmtnKZ+3Rs8QJ+U/qnnGcWJqmS/jIcv8JfjeH7EyPyXGH6PjymSeecjvoSwwbQ/q/JgXtFU2axrGk1+NbpLxrCmbhfLMNmvY8ZPRTMUPHIOjneE4vixW9mJwtFk39Qag5BF5wvZ1VPEM0iAUz9zFmb/Kh/D4VxbPsH+q6iIedH/+bg691Pg9m1XVn1dxFuNrv5WPrujONkvpbOVner7hqGS+jIcs8wZ/r4oy79ksxcNYmQ/FZCxPirYHdX6cibRZo4mztM3y4iw1h/dypq3RTOW4cP6L+gZTywb1btU4C9d670c2S8VjaevLFDK22/oy1zrzd8mhU37ttnaLV9sp7Z69gl5qz15N4MN79h7q0EuN37NZZfvhmF6qRiTja7/V/hVFd7ZZ3h4dHIOyWex3pJb5Mh6yzBv891eUec9mKR7GyjzzkN9TeyMP+vzYirRZuA6VX41ukvFIm4XyzDbL2weTX7udw2pPK++bQZvFe2+G9a3zr3oPUtL9zObX8g7vxLXXfpPGkFH/TYK/rscztN32/17yIy+e2epcXNu6uHV6a2dnfXvrGLWfX8bj2QT9X9g8u9M+e/HCVqfTWd1pXyjr/9JehG7xHOdRfk31fltOKsNbe02Cf1qPxrlcPIPmalP0l8O9yIGrBf6/sw1xr9HtvzfTHYSvdwfhre9WdxBHezYLz3CO59dc7zfSC9syPJoE/3z4Rp9f0/COvb8o+p+m/vvwFvdQx3BbdXHP4O/cW0zzBsc+PL3a7hhuk9Q+3mPcTHZSzKvVzc2Ns6vn2+tndrYv7qyvjXper5/eOrO9dabTObveubDeOT3q/jfWNzqbm1ub2xvbF8+ub58v65/XOdOsibdXZ6DPBO230TfLaCzYL9OgId6rBX5P0P8eLN/He/PimbVpeZmIL5+zY/8nqv3SsfZT1WxWvEJ/i+tRIL3PDQkHa890VTMbvNheGizPmdrw8etkdCm7aZfJDMYsRs+jhGsT2hkmT3E9JEH7l2RyKk37a0om8R7LAPKBfWyep0PGdeuSvwc4cBzFOCKM0nkT9LtB9+sRsEo27RnXLlLv8Xoc3zPZUvqT+cL579wW1o9C+CmCTcXD4wInw/3/AQs5jc8uYHsA","debug_symbols":"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b5+8/vbJ62+fvP5efV4gPP7J62+3XX8ft3/G3/57wPEav+36K8dvu/7K8duuv1L8dbFdf+X4bddfOX7b9VeO33b9leO3XX/l+G3XXzn+uetvXeauv3WZu/7WZfL6Gyavv2Hy+hsmr79h8vp79Xks8Pht19+WtnflWql78ZuuvyUuz/hLjG0vftP19434TdffN+I3XX/l+KPp+vtG/Kbr7xvxm66/b8Rvuv6+Eb/p+vtG/Kbr7xvxT15/4+T1N05ef+Pk9XedvP6uk9ffdfL6u05ef6/udw2Pf/L6u05ef9fJ6+86ef1dJ6+/afL6myavv2ny+psmr79X92eFxz95/U2T1980ef1Nk9ffNHn9zZPX3zx5/c2T1988ef29up8gPP7J62+evP7myetvnrz+5snrb5m8/pbJ62+ZvP6Wyeuv7f5Xb8Q/ef213f/qjfgnr7+2+1+9Ef/k9dd2/6s34p+8/truf/VG/JPXX9v9r96If/L6a7v/1RvxT15/bfe/eiP+yeuv7f5Xb8Q/ef213f/qjfgnr7+2+1+9Ef/k9dd2/6s34p+8/truf/VG/JPXX9v9r96If/L6a7v/1RvxT15/bfe/eiP+yeuv7f5Xb8Q/ef213f/qjfjnrr/Ndv+rN+Kfu/422/2v3oh/7vrblrnrb7Pd/+qN+Oeuv812/6s34p+7/jbb/a/k+G33v3oj/snrr+3+V2/EP3n9td3/6o34J6+/k/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT979qk/e/apP3v2qT97/qk/e/6pP3v+qT97/qk/e/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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"// This is an auto-generated file, to change the code please edit: src/ts/scripts/circuit-builder.ts\nuse commitment::commit_to_dsc;\nuse sig_check_rsa::verify_signature;\n\nfn main(\n    certificate_registry_root: pub Field,\n    certificate_registry_index: Field,\n    certificate_registry_hash_path: [Field; 14],\n    certificate_registry_id: Field,\n    salt: Field,\n    country: str<3>,\n    tbs_certificate: [u8; 700],\n    tbs_certificate_len: u64,\n    csc_pubkey: [u8; 256],\n    csc_pubkey_redc_param: [u8; 257],\n    dsc_signature: [u8; 256],\n    exponent: u32,\n) -> pub Field {\n    assert(verify_signature::<256, 0, 700, 32>(\n        csc_pubkey,\n        dsc_signature,\n        csc_pubkey_redc_param,\n        exponent,\n        tbs_certificate,\n        tbs_certificate_len,\n    ));\n    let comm_out = commit_to_dsc(\n        certificate_registry_root,\n        certificate_registry_index,\n        certificate_registry_hash_path,\n        certificate_registry_id,\n        country,\n        tbs_certificate,\n        salt,\n        csc_pubkey,\n    );\n    comm_out\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/other_zkpassport_circuits/src/noir/bin/sig-check/dsc/tbs_700/rsa/pkcs/2048/sha256/src/main.nr"},"63":{"source":"use common::{\n    calculate_certificate_registry_leaf, compute_merkle_root, CSC_CERT_TYPE, hash_salt_country_tbs,\n};\n\n/*\n############################################################\n# Circuit A\n############################################################\n# Verifies the CSC signed the DSC\n############################################################\n\n# Inputs/Outputs\n############################################################\ncertificate_registry_root (public)\ncertificate_registry\nsalt\ncountry\ncsc_pubkey\ndsc_pubkey\ndsc_data\ncomm_out                `H(salt, country, dsc_pubkey)`\n\n# Checks\n############################################################\n- Check that leaf `H(registry_id, cert_type, country, csc_pubkey)` exists in tree with root certificate_registry_root\n- Check that dsc_pubkey exists in dsc_tbs at offset dsc_tbs_pubkey_offset\n- Check that dsc_sig is the signature of csc_pubkey over dsc_tbs\n*/\n\npub fn commit_to_dsc<let CSC_KEY_SIZE: u32, let HASH_PATH_SIZE: u32, let TBS_CERT_SIZE: u32>(\n    certificate_registry_root: Field,\n    certificate_registry_index: Field,\n    certificate_registry_hash_path: [Field; HASH_PATH_SIZE],\n    certificate_registry_id: Field,\n    country: str<3>,\n    tbs_certificate: [u8; TBS_CERT_SIZE],\n    salt: Field,\n    csc_pubkey: [u8; CSC_KEY_SIZE],\n) -> Field {\n    // Verify csc_pubkey exists in certificate registry\n    let leaf: Field = calculate_certificate_registry_leaf(\n        certificate_registry_id,\n        CSC_CERT_TYPE,\n        country,\n        csc_pubkey,\n    );\n    let root = compute_merkle_root(\n        leaf,\n        certificate_registry_index,\n        certificate_registry_hash_path,\n    );\n    assert(root == certificate_registry_root);\n    // Output commitment glue\n    let comm_out = hash_salt_country_tbs(salt, country, tbs_certificate);\n    comm_out\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/other_zkpassport_circuits/src/noir/lib/commitment/csc-to-dsc/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n\n// Returns the merkle root of the tree from the provided leaf, index and hash_path, using the Poseidon2 hash function\n// Arity is expected to be 2 and the the tree depth is equal to the hash_path array length\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let index_bits: [u1; N] = index.to_le_bits();\n    let mut current = leaf;\n    for i in 0..N {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = Poseidon2::hash([hash_left, hash_right], 2);\n    }\n    current\n}\n\n#[test]\nfn test_compute_merkle_root1() {\n    let leaf = 0x2fe190f39de3fcf4cbc2eb334d0dc76e4d06f2350aa6056c91ff5f11ded9fb4a;\n    let index = 0;\n    let hash_path = [\n        0x00,\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1,\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290,\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20,\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e,\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf,\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76,\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b,\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1,\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972,\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686,\n        0x0f320b0703439a8114f81593de99cd0b8f3b9bf854601abb5b2ea0e8a3dda4a7,\n        0x0d07f6e7a8a0e9199d6d92801fff867002ff5b4808962f9da2ba5ce1bdd26a73,\n        0x1c4954081e324939350febc2b918a293ebcdaead01be95ec02fcbe8d2c1635d1\n    ];\n    let root = compute_merkle_root(leaf, index, hash_path);\n    assert(root == 0x0742857aba0058b2167c4ac94fede8ec480600911aa871153b988c3f71095449);\n}\n\n#[test]\nfn test_compute_merkle_root2() {\n    let e00 = Poseidon2::hash([1], 1);\n    let e01 = Poseidon2::hash([1], 1);\n    let e02 = Poseidon2::hash([1], 1);\n    let e03 = Poseidon2::hash([1], 1);\n    assert(e00 == 0x168758332d5b3e2d13be8048c8011b454590e06c44bce7f702f09103eef5a373);\n\n    let e10 = Poseidon2::hash([e00, e01], 2);\n    let e11 = Poseidon2::hash([e02, e03], 2);\n    assert(e10 == 0x113d8ff59c2e15d711241797c380264e39dc1b9e00f2713e707d8d7773b6d912);\n\n    let expected_root = Poseidon2::hash([e10, e11], 2);\n    assert(expected_root == 0x0f4f16b234c1d5054b15d408282cb45ba6c10a629fe068e7f3cc253ceae4f08d);\n\n    let hash_path = [e01, e10];\n    assert(hash_path == [\n        0x168758332d5b3e2d13be8048c8011b454590e06c44bce7f702f09103eef5a373,\n        0x113d8ff59c2e15d711241797c380264e39dc1b9e00f2713e707d8d7773b6d912\n    ]);\n\n    let leaf = Poseidon2::hash([1], 1);\n    let index = 0;\n    let root = compute_merkle_root(leaf, index, hash_path);\n    assert(root == 0x0f4f16b234c1d5054b15d408282cb45ba6c10a629fe068e7f3cc253ceae4f08d);\n}\n\npub fn get_vkey_hash<let N: u32>(vkey: [Field; N]) -> Field {\n    Poseidon2::hash(vkey, N)\n}\n\n#[test]\nfn test_get_vkey_hash() {\n    let vkey = [\n        0x0000000000000000000000000000000000000000000000000000000000004000,\n        0x000000000000000000000000000000000000000000000000000000000000001e,\n        0x0000000000000000000000000000000000000000000000000000000000000001,\n        0x0000000000000000000000000000000000000000000000000000000000000001,\n        0x000000000000000000000000000000000000000000000000000000000000000e,\n        0x000000000000000000000000000000000000000000000000000000000000000f,\n        0x0000000000000000000000000000000000000000000000000000000000000010,\n        0x0000000000000000000000000000000000000000000000000000000000000011,\n        0x0000000000000000000000000000000000000000000000000000000000000012,\n        0x0000000000000000000000000000000000000000000000000000000000000013,\n        0x0000000000000000000000000000000000000000000000000000000000000014,\n        0x0000000000000000000000000000000000000000000000000000000000000015,\n        0x0000000000000000000000000000000000000000000000000000000000000016,\n        0x0000000000000000000000000000000000000000000000000000000000000017,\n        0x0000000000000000000000000000000000000000000000000000000000000018,\n        0x0000000000000000000000000000000000000000000000000000000000000019,\n        0x000000000000000000000000000000000000000000000000000000000000001a,\n        0x000000000000000000000000000000000000000000000000000000000000001b,\n        0x000000000000000000000000000000000000000000000000000000000000001c,\n        0x000000000000000000000000000000000000000000000000000000000000001d,\n        0x000000000000000000000000000000014d18053025847e890b73d1bd851d8010,\n        0x00000000000000000000000000000000001604875484cd0af6333f892d9db03c,\n        0x0000000000000000000000000000001aa505665b96ff23e66c8cc50617d912dd,\n        0x000000000000000000000000000000000023761d0fc8b989dd96889c0e1dd500,\n        0x0000000000000000000000000000005ec6b7adcaad33a31d00c481cada512ff2,\n        0x00000000000000000000000000000000000619dc9f99c6e6318f58a3cd578e03,\n        0x000000000000000000000000000000ca65a4903d4105e8ffb945a804fe5e758b,\n        0x0000000000000000000000000000000000013d6fe1a9ccad8cf0da0cbb325a50,\n        0x000000000000000000000000000000c3d521df3cd944a41cc6c93814e4bfb108,\n        0x00000000000000000000000000000000002967d970e732ce06f745a1676e907a,\n        0x000000000000000000000000000000bea006927efee453f22d7e5001156d8236,\n        0x000000000000000000000000000000000003da37e3170387f7fc7fe67f3fd02d,\n        0x0000000000000000000000000000007ecadab7d0191e9b27b8c118bcf63e39d7,\n        0x00000000000000000000000000000000001aceee76600298bda7debc2a13e65f,\n        0x00000000000000000000000000000094109ace5115b62b817510419b345bafb3,\n        0x000000000000000000000000000000000007478caa1879b0d66eafb700c8eaff,\n        0x000000000000000000000000000000c66580c6bd58511b6f734408a36072b4cb,\n        0x000000000000000000000000000000000012a966c244f2d7aef31bf501d4c7b3,\n        0x00000000000000000000000000000066953254478df3e72cd967c81f9d7520dd,\n        0x000000000000000000000000000000000012836bbc2291cc1a76e191beeeff55,\n        0x00000000000000000000000000000085f16f224863af3a2eb1640916d6e2f661,\n        0x00000000000000000000000000000000001d2c4076e8dcb9be0e997d8c5715d9,\n        0x000000000000000000000000000000e7e736564c69478322d60bf28db04d2180,\n        0x000000000000000000000000000000000001bac3d335ee7aece9c8e8b83c4a0a,\n        0x000000000000000000000000000000418412d57fe3f9d88befaf72e3f049aed6,\n        0x00000000000000000000000000000000002640a81c852ebd44791d208778e3d4,\n        0x0000000000000000000000000000003f0de2660faefec496cddfcf172d70f88a,\n        0x000000000000000000000000000000000023f365597e5a0fe284fe40ba6df049,\n        0x0000000000000000000000000000001ff3fdb800a12685d0225869a709c59ea1,\n        0x000000000000000000000000000000000010485496ac517ce4626468b80c20d1,\n        0x000000000000000000000000000000eae802a6cf93d2041722bcc7b827850d9c,\n        0x00000000000000000000000000000000002c3eb537afd8670ec12382677e9dfd,\n        0x000000000000000000000000000000da72208a8ea7aa2e70b8fc00cf95fbe413,\n        0x00000000000000000000000000000000001994c139d6d63fbb02a95416dd2057,\n        0x0000000000000000000000000000000c243e99da3df894bd68564c1f2189c436,\n        0x000000000000000000000000000000000004714d9481f6dbd276728639c54996,\n        0x0000000000000000000000000000007ffd262875ae684deba001fcc5fdea3bbf,\n        0x000000000000000000000000000000000026c3846eed3340f6f2e861943f6f27,\n        0x0000000000000000000000000000009e45b69b687387629e72688f33382df553,\n        0x000000000000000000000000000000000017612f582a3500568851ebdcb62e72,\n        0x000000000000000000000000000000898a13479bd1c1e27a6e0681a5d43985af,\n        0x000000000000000000000000000000000002f9352d7ab76f7b9eda17515fd7b8,\n        0x0000000000000000000000000000003c13860bb6a8f804652839fa9abe19bb7b,\n        0x00000000000000000000000000000000000ea81714a4cd7294ac6300617eb610,\n        0x000000000000000000000000000000dc6620bff3175f56800f1e44c3e79b256e,\n        0x000000000000000000000000000000000003c53e0fb2f68008220ac57a71c7f4,\n        0x000000000000000000000000000000ab9926a5dd872d669530c99c7d9be65720,\n        0x00000000000000000000000000000000002ea70327e45061f95597e2ccf26540,\n        0x00000000000000000000000000000032d9d845b89a70f07980c48344f7a599e6,\n        0x000000000000000000000000000000000020828423a9331f84edb915eeb4733d,\n        0x000000000000000000000000000000f020304aa06e327c9294f1254859db8ab6,\n        0x00000000000000000000000000000000001f5964632befb3e8707483b77e7881,\n        0x0000000000000000000000000000004d882ed48ddc17fda49a2e3c07bfa0b4a7,\n        0x0000000000000000000000000000000000238a9bda3f2d414f43b6d68db016da,\n        0x000000000000000000000000000000871bf5d454ed7a84525d3d52325dfb377c,\n        0x000000000000000000000000000000000007584c1032621909192d308449ced1,\n        0x0000000000000000000000000000005b72000fb18ad1bd936839038a2bc2b9e5,\n        0x0000000000000000000000000000000000268cfce53a1c077c835540eb73a23c,\n        0x00000000000000000000000000000000c747ae5e9a310b1d8baa8c34f92e8d0e,\n        0x00000000000000000000000000000000002701e27eec246967ec650bbe990bab,\n        0x000000000000000000000000000000a6783a604d35e125327e5fe8cf22398fdd,\n        0x00000000000000000000000000000000002309c7ceac11535749dab8c9f4d851,\n        0x00000000000000000000000000000065720cd086bae46f673f548239ceafb0b4,\n        0x00000000000000000000000000000000000a8ac00f8a2042f8f81c554dc404f6,\n        0x000000000000000000000000000000907c095579b757be6b50e41dc3692a224c,\n        0x00000000000000000000000000000000000a45377f92a8d6d44afe54e3717f8a,\n        0x000000000000000000000000000000d8642735ec11ef526dcffa791f1ad641ab,\n        0x00000000000000000000000000000000001e4fbc154b0c6b4c559f58a7d19ac0,\n        0x000000000000000000000000000000eff01a355a79835cc29ccf88cd9e3ca07f,\n        0x00000000000000000000000000000000002af5e29ca00459725e2680c6a78a6f,\n        0x000000000000000000000000000000da6c16f1483ae4228c68cc091f40d39aad,\n        0x00000000000000000000000000000000000ea734a85cf7a6d1d775a08afc61e0,\n        0x000000000000000000000000000000fd722ec69b8a01085785be11e41f873afe,\n        0x000000000000000000000000000000000006b8a63c9cf273d4724fbb10d5f57a,\n        0x000000000000000000000000000000f7d9fd5e858349061430d351c45499dfad,\n        0x0000000000000000000000000000000000046edaae51ba84f2dabcd56e9eed5b,\n        0x0000000000000000000000000000002f225a95524043ea68cc704f77ef4f6045,\n        0x0000000000000000000000000000000000038d07b151361621e074699b374a85,\n        0x000000000000000000000000000000da6a36c7ae48c4791868c3d10c8533fe6e,\n        0x000000000000000000000000000000000014ce118be5ef951902f6e84a561e88,\n        0x000000000000000000000000000000beabc4f9b42059a77a1b15b98856b48453,\n        0x00000000000000000000000000000000002114644c4953246a959f25a4bf2052,\n        0x0000000000000000000000000000009d10f2f38322da8ecb0b296bc729ff1c4e,\n        0x000000000000000000000000000000000027f1245b7ec2b0cb360bb134218ed1,\n        0x00000000000000000000000000000032957a466beb19e0675e0f739616187ecd,\n        0x0000000000000000000000000000000000235e20011670e41d045fd8446ae100,\n        0x000000000000000000000000000000691d28ce28c9ae3f7e8d3220cbfdb0fd36,\n        0x000000000000000000000000000000000004d8e62001cadc95344edcfd429fed,\n        0x0000000000000000000000000000008a34b9ab23bd2cd471701a5a76de4076b8,\n        0x00000000000000000000000000000000002c853787226778520baf3c5f0ed65e,\n        0x000000000000000000000000000000f357d89b0302e34eac204bc55974f0c37b,\n        0x00000000000000000000000000000000001a04dfa8543c150c4f07b768f1752d,\n        0x000000000000000000000000000000709f2727a8adda78f9cd125c85fc061557,\n        0x0000000000000000000000000000000000180b5e9b2901b08360c598f18581d0,\n        0x0000000000000000000000000000003f99f9fd98707c98fd62328a676c38bb38,\n        0x000000000000000000000000000000000004880ff78661543813929232e5c4db,\n        0x0000000000000000000000000000003fb3d6fdb1fe407fc26479a67309987378,\n        0x0000000000000000000000000000000000152830347b8e35a842ea020f557635,\n        0x0000000000000000000000000000004aed3df71695a6a5295e2117cc6c0a80df,\n        0x0000000000000000000000000000000000007ee2c78519eb92faa04d10b2ae9e,\n        0x0000000000000000000000000000000000000000000000000000000000000001,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000002,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x000000000000000000000000000000feb33855ac28e08d8b02991fb3f3c211cf,\n        0x000000000000000000000000000000000007d8476506cdef23b023ca072ed709,\n        0x000000000000000000000000000000e985e0b015edca55f69192bdb7139b7224,\n        0x000000000000000000000000000000000020470f3258600e780b46d6c7db1bc6\n    ];\n    let vkey_hash = get_vkey_hash(vkey);\n    assert(vkey_hash == 0x159c7f9777839c2449c0a0f90b411569ed72aaa9d090c82c9c028adf5419d3d6);\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/other_zkpassport_circuits/src/noir/lib/commitment/common/src/lib.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn pack_be_bytes_into_fields<let NBytes: u32, let N: u32, let MAX_FIELD_SIZE: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(MAX_FIELD_SIZE - (N * MAX_FIELD_SIZE - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..MAX_FIELD_SIZE {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\n#[test]\nfn test_pack_be_bytes_into_fields() {\n    let pubkey_bytes: [u8; 512] = [\n        0x40, 0x5d, 0xd3, 0xb8, 0x01, 0xcb, 0xc8, 0xe2, 0x37, 0x62, 0x0d, 0x8d, 0xd9, 0xad, 0xc2,\n        0x95, 0x51, 0xfb, 0x22, 0x97, 0xb7, 0xff, 0xc0, 0xde, 0xeb, 0x3a, 0x1b, 0x27, 0xef, 0xfc,\n        0x6b, 0x6c, 0xae, 0x87, 0xec, 0x42, 0x62, 0xfc, 0xfd, 0x07, 0x5f, 0x55, 0x54, 0x47, 0x55,\n        0x47, 0xa3, 0x7e, 0x46, 0x3b, 0x5e, 0xba, 0xf8, 0x1c, 0x14, 0x85, 0xef, 0xeb, 0x44, 0xe6,\n        0x34, 0xf9, 0xa0, 0x4d, 0xa3, 0xf9, 0x8c, 0x5c, 0xfe, 0x8d, 0x4d, 0x8f, 0x9e, 0x1f, 0xb4,\n        0xe8, 0x9c, 0xe0, 0xe6, 0xd9, 0x59, 0x82, 0x80, 0xb0, 0xaa, 0x0f, 0x29, 0x02, 0xb0, 0xaa,\n        0x3b, 0x3a, 0x43, 0x2d, 0x27, 0xb5, 0x33, 0xc1, 0x03, 0xf1, 0x50, 0x9b, 0x4f, 0x4f, 0xc4,\n        0x3a, 0xc7, 0x0b, 0x42, 0x7e, 0x93, 0x91, 0x89, 0x3f, 0x58, 0x96, 0x8f, 0xc2, 0xd9, 0x6a,\n        0x27, 0x75, 0x5e, 0x9e, 0xa1, 0x56, 0x07, 0x6a, 0x09, 0xe7, 0x8b, 0x91, 0x9d, 0x8c, 0x5d,\n        0xee, 0x0f, 0x2e, 0xf1, 0x9a, 0xff, 0x06, 0xbf, 0x67, 0xab, 0x42, 0x26, 0xa3, 0x31, 0xff,\n        0xa7, 0x37, 0xd9, 0x47, 0x8e, 0x0d, 0xcd, 0x3f, 0x2a, 0xb1, 0x25, 0xcc, 0xc6, 0xa6, 0x8c,\n        0x44, 0x47, 0x2f, 0xb5, 0xc8, 0xf5, 0xd8, 0xdd, 0xac, 0x8d, 0xf1, 0xc6, 0x91, 0x7e, 0xb3,\n        0x1b, 0xad, 0xa6, 0x7a, 0x19, 0xf7, 0xfc, 0xec, 0xb8, 0x12, 0x35, 0xe7, 0x70, 0x6b, 0x20,\n        0xec, 0xc4, 0xdc, 0xed, 0x3d, 0xbe, 0xa6, 0xd6, 0x7f, 0xe4, 0x9c, 0x3f, 0x31, 0x56, 0x2f,\n        0xfb, 0xa7, 0x5d, 0x3a, 0xae, 0xbc, 0x67, 0xb2, 0xba, 0x64, 0xa2, 0xf9, 0x54, 0x63, 0x49,\n        0xfb, 0x9e, 0x2c, 0x9a, 0xd4, 0x40, 0x42, 0x44, 0x50, 0xb8, 0x1c, 0x30, 0x3c, 0x51, 0xd4,\n        0x05, 0xd3, 0xc8, 0x1a, 0x37, 0x0e, 0x67, 0x27, 0x04, 0xf5, 0xf3, 0x14, 0x50, 0xf9, 0x15,\n        0x6d, 0x93, 0x4f, 0x3d, 0x7a, 0xb2, 0xe4, 0x1b, 0xa2, 0xcb, 0x40, 0x4c, 0x3d, 0x6c, 0xef,\n        0x87, 0x40, 0x56, 0x98, 0x9a, 0x61, 0x76, 0xdf, 0xd1, 0x00, 0xae, 0x89, 0xdd, 0x79, 0x36,\n        0xe9, 0xf0, 0xef, 0x83, 0x11, 0x1b, 0xf9, 0xb7, 0x81, 0x9f, 0xd1, 0x2b, 0x33, 0xff, 0x68,\n        0x25, 0x90, 0x53, 0x98, 0xa2, 0xf7, 0x49, 0xa7, 0x73, 0x19, 0x0f, 0x5d, 0x83, 0x80, 0x13,\n        0xb8, 0x98, 0x35, 0x96, 0xb4, 0x19, 0x57, 0xa1, 0xa7, 0x8a, 0xf8, 0x1f, 0xbe, 0x9f, 0x41,\n        0x8d, 0x92, 0x21, 0xa1, 0x7a, 0xe6, 0x8f, 0xdd, 0xad, 0xbb, 0x6d, 0x54, 0xc9, 0x7e, 0xcb,\n        0xe1, 0xe3, 0x17, 0x44, 0xb7, 0xad, 0x88, 0xa8, 0x20, 0xd4, 0x28, 0xb0, 0xf1, 0xc7, 0x9a,\n        0x66, 0x60, 0xc5, 0x77, 0x49, 0xfc, 0x14, 0x5d, 0x2a, 0x6f, 0x68, 0xc9, 0x5a, 0x0b, 0xf1,\n        0x34, 0x5a, 0x0c, 0xdf, 0x23, 0xc0, 0x48, 0x10, 0x9f, 0x11, 0x8d, 0xbc, 0x4f, 0x06, 0x25,\n        0x26, 0xec, 0xca, 0x6a, 0xd5, 0x5f, 0x4d, 0xc9, 0xe1, 0x43, 0x7a, 0xe5, 0x28, 0xbf, 0xf4,\n        0x44, 0x0b, 0x7f, 0x04, 0xe8, 0x17, 0xf0, 0x86, 0x1b, 0xa1, 0x8f, 0xfd, 0xc4, 0xe9, 0x65,\n        0x6b, 0xd2, 0xb1, 0x05, 0xcd, 0x7c, 0x3f, 0x8b, 0xdf, 0xff, 0xfa, 0x89, 0x76, 0xa1, 0xd6,\n        0x71, 0x2b, 0x59, 0xc5, 0x8b, 0xff, 0x77, 0x1b, 0xcb, 0x10, 0x07, 0xab, 0x52, 0x92, 0x03,\n        0x4b, 0x01, 0x20, 0xde, 0xee, 0x9d, 0x92, 0xdd, 0x32, 0xe9, 0xd1, 0x66, 0x1c, 0xad, 0x3f,\n        0xd7, 0x48, 0xd2, 0xaa, 0x63, 0x4a, 0x40, 0xe7, 0x86, 0x07, 0x2d, 0x1a, 0x84, 0xa7, 0x26,\n        0xee, 0x35, 0xa0, 0xa6, 0x52, 0xbc, 0x1a, 0x96, 0xef, 0x6f, 0xa8, 0x5a, 0xaa, 0xac, 0x8a,\n        0x27, 0x93, 0xa9, 0x06, 0xa6, 0xbf, 0x52, 0xc2, 0xd3, 0xb6, 0xdc, 0xc3, 0xe5, 0x3e, 0x8d,\n        0xf2, 0xc2,\n    ];\n\n    let pubkey1 = pack_be_bytes_into_fields::<512, (512 + 14) / 15, 15>(pubkey_bytes);\n    assert(\n        pubkey1\n            == [\n                0xa906a6bf52c2d3b6dcc3e53e8df2c2,\n                0xa0a652bc1a96ef6fa85aaaac8a2793,\n                0xd2aa634a40e786072d1a84a726ee35,\n                0x20deee9d92dd32e9d1661cad3fd748,\n                0x59c58bff771bcb1007ab5292034b01,\n                0xb105cd7c3f8bdffffa8976a1d6712b,\n                0x7f04e817f0861ba18ffdc4e9656bd2,\n                0xca6ad55f4dc9e1437ae528bff4440b,\n                0x0cdf23c048109f118dbc4f062526ec,\n                0xc57749fc145d2a6f68c95a0bf1345a,\n                0x1744b7ad88a820d428b0f1c79a6660,\n                0x21a17ae68fddadbb6d54c97ecbe1e3,\n                0x3596b41957a1a78af81fbe9f418d92,\n                0x5398a2f749a773190f5d838013b898,\n                0xef83111bf9b7819fd12b33ff682590,\n                0x56989a6176dfd100ae89dd7936e9f0,\n                0x4f3d7ab2e41ba2cb404c3d6cef8740,\n                0xc81a370e672704f5f31450f9156d93,\n                0x2c9ad440424450b81c303c51d405d3,\n                0x5d3aaebc67b2ba64a2f9546349fb9e,\n                0xdced3dbea6d67fe49c3f31562ffba7,\n                0xa67a19f7fcecb81235e7706b20ecc4,\n                0x2fb5c8f5d8ddac8df1c6917eb31bad,\n                0xd9478e0dcd3f2ab125ccc6a68c4447,\n                0x2ef19aff06bf67ab4226a331ffa737,\n                0x5e9ea156076a09e78b919d8c5dee0f,\n                0x0b427e9391893f58968fc2d96a2775,\n                0x432d27b533c103f1509b4f4fc43ac7,\n                0xe0e6d9598280b0aa0f2902b0aa3b3a,\n                0xa04da3f98c5cfe8d4d8f9e1fb4e89c,\n                0x7e463b5ebaf81c1485efeb44e634f9,\n                0xae87ec4262fcfd075f5554475547a3,\n                0xfb2297b7ffc0deeb3a1b27effc6b6c,\n                0xd3b801cbc8e237620d8dd9adc29551,\n                0x405d,\n            ],\n    );\n    let pubkey2 = pack_be_bytes_into_fields::<512, (512 + 30) / 31, 31>(pubkey_bytes);\n    assert(\n        pubkey2\n            == [\n                0x35a0a652bc1a96ef6fa85aaaac8a2793a906a6bf52c2d3b6dcc3e53e8df2c2,\n                0x4b0120deee9d92dd32e9d1661cad3fd748d2aa634a40e786072d1a84a726ee,\n                0x656bd2b105cd7c3f8bdffffa8976a1d6712b59c58bff771bcb1007ab529203,\n                0x062526ecca6ad55f4dc9e1437ae528bff4440b7f04e817f0861ba18ffdc4e9,\n                0xf1c79a6660c57749fc145d2a6f68c95a0bf1345a0cdf23c048109f118dbc4f,\n                0x1fbe9f418d9221a17ae68fddadbb6d54c97ecbe1e31744b7ad88a820d428b0,\n                0xd12b33ff6825905398a2f749a773190f5d838013b8983596b41957a1a78af8,\n                0xcb404c3d6cef874056989a6176dfd100ae89dd7936e9f0ef83111bf9b7819f,\n                0x50b81c303c51d405d3c81a370e672704f5f31450f9156d934f3d7ab2e41ba2,\n                0xd67fe49c3f31562ffba75d3aaebc67b2ba64a2f9546349fb9e2c9ad4404244,\n                0xd8ddac8df1c6917eb31bada67a19f7fcecb81235e7706b20ecc4dced3dbea6,\n                0xff06bf67ab4226a331ffa737d9478e0dcd3f2ab125ccc6a68c44472fb5c8f5,\n                0x7e9391893f58968fc2d96a27755e9ea156076a09e78b919d8c5dee0f2ef19a,\n                0xe6d9598280b0aa0f2902b0aa3b3a432d27b533c103f1509b4f4fc43ac70b42,\n                0x7e463b5ebaf81c1485efeb44e634f9a04da3f98c5cfe8d4d8f9e1fb4e89ce0,\n                0x51fb2297b7ffc0deeb3a1b27effc6b6cae87ec4262fcfd075f5554475547a3,\n                0x405dd3b801cbc8e237620d8dd9adc295,\n            ],\n    );\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n\npub fn get_issuing_country_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n    // No need to check if it's an ID card since the issuing country\n    // is always at the same index for both passports and ID cards\n    get_array_slice(\n        mrz,\n        PASSPORT_MRZ_COUNTRY_INDEX,\n        PASSPORT_MRZ_COUNTRY_INDEX + 3,\n    )\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/other_zkpassport_circuits/src/noir/lib/utils/src/lib.nr"},"66":{"source":"use bignum::{params::BigNumParams, RuntimeBigNum};\nuse common::{\n    sha256_and_check_data_to_sign, sha384_and_check_data_to_sign, sha512_and_check_data_to_sign,\n};\nuse rsa::rsa::{\n    verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n    verify_sha512_pkcs1v15, verify_sha512_pss,\n};\n\n/// Okay so in RSA the sig is (m^e) for private key e and public key d\n/// And then the point is that e * d = (p - 1)(q - 1) = 1 mod n\n/// So then (m^e)^d = m mod n\n/// So we should be just checking that m =? s^d (where s is the signature)\npub fn verify_signature<let SIG_BYTES: u32, let IS_PSS: u32, let DATA_TO_SIGN_LEN: u32, let HASH_BYTE_SIZE: u32>(\n    pubkey_bytes: [u8; SIG_BYTES],\n    sig_bytes: [u8; SIG_BYTES],\n    redc_param_bytes: [u8; SIG_BYTES + 1], // What dis\n    exponent: u32, // Also what dis\n    data_to_sign: [u8; DATA_TO_SIGN_LEN], // I assume we have to hash this first???\n    // So we first compute H(data_to_sign) and then check whether H(data_to_sign) =? sig_bytes ^ pubkey_bytes\n    data_to_sign_len: u64,\n) -> bool {\n    assert(\n        (SIG_BYTES == 512) | (SIG_BYTES == 384) | (SIG_BYTES == 256) | (SIG_BYTES == 128),\n        \"Only modulus of bit size 1024, 2048, 3072 and 4096 are supported\",\n    );\n\n    let pubkey =\n        utils::pack_be_bytes_into_fields::<SIG_BYTES, (SIG_BYTES + 14) / 15, 15>(pubkey_bytes);\n    let redc_param = utils::pack_be_bytes_into_fields::<SIG_BYTES + 1, _, 15>(redc_param_bytes);\n    let params = BigNumParams::new(false, pubkey, redc_param);\n\n    let signature = RuntimeBigNum::from_be_bytes(params, sig_bytes);\n\n    if (IS_PSS == 1) {\n        if (HASH_BYTE_SIZE == 32) {\n            let msg_hash = sha256_and_check_data_to_sign(data_to_sign, data_to_sign_len);\n            verify_sha256_pss::<_, SIG_BYTES * 8>(msg_hash, signature, exponent)\n        } else if (HASH_BYTE_SIZE == 48) {\n            let msg_hash = sha384_and_check_data_to_sign(data_to_sign, data_to_sign_len);\n            verify_sha384_pss::<_, SIG_BYTES * 8>(msg_hash, signature, exponent)\n        } else if (HASH_BYTE_SIZE == 64) {\n            let msg_hash = sha512_and_check_data_to_sign(data_to_sign, data_to_sign_len);\n            verify_sha512_pss::<_, SIG_BYTES * 8>(msg_hash, signature, exponent)\n        } else {\n            false\n        }\n    } else {\n        if (HASH_BYTE_SIZE == 32) {\n            let msg_hash = sha256_and_check_data_to_sign(data_to_sign, data_to_sign_len);\n            verify_sha256_pkcs1v15::<_, SIG_BYTES * 8>(msg_hash, signature, exponent)\n        } else if (HASH_BYTE_SIZE == 48) {\n            let msg_hash = sha384_and_check_data_to_sign(data_to_sign, data_to_sign_len);\n            verify_sha384_pkcs1v15::<_, SIG_BYTES * 8>(msg_hash, signature, exponent)\n        } else if (HASH_BYTE_SIZE == 64) {\n            let msg_hash = sha512_and_check_data_to_sign(data_to_sign, data_to_sign_len);\n            verify_sha512_pkcs1v15::<_, SIG_BYTES * 8>(msg_hash, signature, exponent)\n        } else {\n            false\n        }\n    }\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/other_zkpassport_circuits/src/noir/lib/sig-check/rsa/src/lib.nr"},"100":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/constrained_ops.nr"},"101":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/expressions.nr"},"103":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/serialization.nr"},"104":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_helpers.nr"},"105":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]; M] = std::mem::zeroed();\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_ops.nr"},"107":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/params.nr"},"108":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self;\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus(self) -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    fn __neg(self) -> Self;\n    // unconstrained\n    fn __add(self, other: Self) -> Self;\n    // unconstrained\n    fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    fn __div(self, other: Self) -> Self;\n    // unconstrained\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    fn __invmod(self) -> Self;\n    // unconstrained\n    fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_field(self);\n    fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    fn udiv(numerator: Self, divisor: Self) -> Self;\n    fn umod(numerator: Self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/runtime_bignum.nr"},"115":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/split_bits.nr"},"116":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/u60_representation.nr"},"118":{"source":"use sha256;\nuse sha512::{sha384, sha512};\nuse utils::check_zero_padding;\n\npub fn sha256_and_check_data_to_sign<let DATA_TO_SIGN_LEN: u32>(\n    data_to_sign: [u8; DATA_TO_SIGN_LEN],\n    data_to_sign_len: u64,\n) -> [u8; 32] {\n    // Check that the data signed does stop at the specified length\n    // to prevent the prover from using the bytes beyond that point\n    // to manipulate it in their favor\n    check_zero_padding(data_to_sign, data_to_sign_len as u32);\n\n    sha256::sha256_var(data_to_sign, data_to_sign_len)\n}\n\npub fn sha384_and_check_data_to_sign<let DATA_TO_SIGN_LEN: u32>(\n    data_to_sign: [u8; DATA_TO_SIGN_LEN],\n    data_to_sign_len: u64,\n) -> [u8; 48] {\n    // Check that the data signed does stop at the specified length\n    // to prevent the prover from using the bytes beyond that point\n    // to manipulate it in their favor\n    check_zero_padding(data_to_sign, data_to_sign_len as u32);\n\n    let data_to_sign_vec = BoundedVec::from_parts(data_to_sign, data_to_sign_len as u32);\n    sha384::sha384_var(data_to_sign_vec)\n}\n\npub fn sha512_and_check_data_to_sign<let DATA_TO_SIGN_LEN: u32>(\n    data_to_sign: [u8; DATA_TO_SIGN_LEN],\n    data_to_sign_len: u64,\n) -> [u8; 64] {\n    // Check that the data signed does stop at the specified length\n    // to prevent the prover from using the bytes beyond that point\n    // to manipulate it in their favor\n    check_zero_padding(data_to_sign, data_to_sign_len as u32);\n\n    let data_to_sign_vec = BoundedVec::from_parts(data_to_sign, data_to_sign_len as u32);\n    sha512::sha512_var(data_to_sign_vec)\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/other_zkpassport_circuits/src/noir/lib/sig-check/common/src/lib.nr"},"122":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/ryan.cao/nargo/github.com/noir-lang/sha256/v0.1.1/src/sha256.nr"},"129":{"source":"use crate::types::{\n    Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n};\nuse dep::bignum::params::BigNumParams;\nuse dep::bignum::RuntimeBigNum;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i as u32 < 52 + ps_len as u32 {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i as u32 == 52 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i as u32 == 53 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-256\n *\n * @param msg_hash The SHA-256 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (either 3 or 65537)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        for _ in 0..15 {\n            exponentiated = exponentiated * exponentiated;\n        }\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (either 3 or 65537)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        for _ in 0..15 {\n            exponentiated = exponentiated * exponentiated;\n        }\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (either 3 or 65537)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        for _ in 0..15 {\n            exponentiated = exponentiated * exponentiated;\n        }\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig;\n    if exponent == 65537 {\n        // Exponentiate the signature assuming e = 65537\n        for _ in 0..15 {\n            exponentiated = exponentiated * exponentiated;\n        }\n    }\n    // Otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig;\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig;\n    if exponent == 65537 {\n        // Exponentiate the signature assuming e = 65537\n        for _ in 0..15 {\n            exponentiated = exponentiated * exponentiated;\n        }\n    }\n    // Otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig;\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig;\n    if exponent == 65537 {\n        // Exponentiate the signature assuming e = 65537\n        for _ in 0..15 {\n            exponentiated = exponentiated * exponentiated;\n        }\n    }\n    // Otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig;\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"hello world! test#123\".as_bytes(), 21);\n    let params: Params1024 = BigNumParams::new(\n        false,\n        [\n            0x483fd4238ca29c3a06f8161ee16faf,\n            0xf366b16a37c2db80d2977eab0ebbdc,\n            0x92ba4d77ff2425727ad38eea1cc2fe,\n            0x3fc50862a0e6afbcae13d5f85c220a,\n            0xe634dcea239a6a896597d4f75af455,\n            0x32e1448d1489bca56d983562715680,\n            0x1a81ef873140c0cfc191a44bfe6e88,\n            0x96066f4df0e14de07329df952aba45,\n            0xc2e161b4944381bb,\n        ],\n        [\n            0x9c0b9f33d5b6960db5d70095a87724,\n            0xfb5245423548a808b8aee833d783b8,\n            0x790c0d7558b38dc24122455bf48f92,\n            0x39227725aaea9c83a99acf4b847682,\n            0xbd468a00b83cb026568150030eff3a,\n            0xcbb4f5cef905ca04f92f266e0493e8,\n            0xe19ad572a7bc2bb8168c81b0867c04,\n            0xbe2075bf10bc8a16725befb36d7f49,\n            0x15049cee2f37078121,\n        ],\n    );\n\n    let signature: RBN1024 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xe6fe1016893fed66550af77d706698,\n            0x9dd3b648afbbdb748ab97b4d609f0d,\n            0x83098d3b45c588c69c0e36ff9b210a,\n            0x5a793d529a382b34a491f68e4d959d,\n            0xa8c43b964794a4c11da2e57ef226df,\n            0x68654e3681728df9daff17a3b0bc66,\n            0x8aa4c9accfffae4fd5cd453c8c5335,\n            0x8b243f7074dacdcd869b94f3eef7fe,\n            0x3a8c12564704f5ad,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n    let params: Params2048 = BigNumParams::new(\n        false,\n        [\n            0x6d235ca5aab99a4c05ff2a03574427,\n            0xec267a6bbe7ffe4b6e8da9cf24897c,\n            0xcdaa2e64a6116d5bdf82460a108af3,\n            0xf6c184c2d2f4cc7ed3b7eaf28e257e,\n            0x7511d2771cdf315a07ba2e0058cb8b,\n            0x641d6eb5119b1b8e643eda5ade2dc3,\n            0xffc28bdb9f8f0ddc596675feae14fc,\n            0xcbc67f77f37393c3419a2340f859ad,\n            0x5cd500e0341275ce468e62db47107d,\n            0x3049eba2be3f9408f2c9ed2ae27d90,\n            0xc2f431dd169858ac5269d2512f4189,\n            0x36ace99a589959ea0425444cfb440d,\n            0x825fbf23e4e49a3b8f1fa714681f77,\n            0x8125cd82c2776832cf839ee1a9332c,\n            0xacbefb6a860c88ecbef30d52472137,\n            0x24166d0e0b434e207d4e8ecfd66cc9,\n            0x180955377f255f7bc29506fb45a8cb,\n            0xf7,\n        ],\n        [\n            0xd08ee8d0e8ac5ce306aa570cfe1c05,\n            0xed045b877e042b6c144e6aa9cce044,\n            0x845096769616e1351bd198cb0938ae,\n            0xe4512a74991f500c166befa3c2f524,\n            0x81a05d9646ce1212d658399b5b566d,\n            0x1211121678c29a52c6d66eeca965b9,\n            0x93dfb350c2b86c8a2a2464cd84e03c,\n            0x9747aff06e0b9527bc5ad313c8173e,\n            0x1ca0a8eb7986c264406bf2a8752034,\n            0xe6abe17cf0f33ec2f655a85c027269,\n            0xd157b2f2739eec33b38908711b45df,\n            0xecc0246c32b828f0f603c9feea2daf,\n            0x76cb733ba6093e7fc2cfc29e07d7c4,\n            0x7c6f3519480fc9490894acf0c7087f,\n            0xb92c0644fa19196c5be9d142611269,\n            0x4db094df57cae1fa0bf4e8faec435b,\n            0xa2426a309776b8e5d0be5257586c59,\n            0x1093,\n        ],\n    );\n\n    let signature: RBN2048 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad8c7c5ec9162b4769e0cfe5ebf840,\n            0x0d57cdde315319930d4e9eda1a7c1e,\n            0xafc455e0e01ef5a57160f0df8a786c,\n            0xbf1c1e64e91e316ec3ec02e68c23d6,\n            0x8df9a02bb6a52c932ad0d2832e33a6,\n            0xa3eacb4ebcb99a4a48be662698a9b8,\n            0x4fef3847f3e94050802ab50f29a01d,\n            0xa493fa7d68bd2b0d9e1a1d768053c0,\n            0x707d984f377f71262954eabd10e268,\n            0xfec30d40733948f36919b3ffa07366,\n            0xc9bf002b29ce6a860ba284a4426e34,\n            0xbc839ec24aad3c05a9aaccefca9e63,\n            0x07fe1918a7d98dd52e49e9d775461c,\n            0x098fdfe7d87d48732502814ee90808,\n            0x64de99868676d8b02d7b43b0474636,\n            0x27910e77bdc54ba42a4322a5ce8200,\n            0xc3b7b95e779c9a11895c88fe24bced,\n            0x96,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha384_pkcs1v15_2048() {\n    let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n        \"Hello World! This is Noir-RSA\".as_bytes(),\n        29,\n    ));\n\n    let params: Params2048 = BigNumParams::new(\n        false,\n        [\n            0x1dccbc1b553aef560cd665aa2ca411,\n            0xdf1b70d8f0ff39013065a5a886490f,\n            0xc3952220c2f6ba45b86fd1842f6db5,\n            0x13403323f2e86127e7d30ca5c3741f,\n            0xdd9593e1b80868ee660cff6aed224d,\n            0xa768ff67951f621cf220c3f11fb7d0,\n            0x827a30c8fc6da6d9e0002ccbab7354,\n            0xd4f4b3326c1822490ba84bf7d8f2ff,\n            0xbc1aed9983525cf9795c5ee886efbe,\n            0x95eca388e0ef68d9e1b51bfdb3f38b,\n            0x5f250161202b7d91724180734cd057,\n            0x5f6a6e4b2adf9db128af321e90bc61,\n            0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n            0x8fea1754c39077bbc232d8380c4eac,\n            0xa113212c3d6ba516cdf08b1c0c0cae,\n            0x9ba6c1d51332cd846f88cfe28dabb,\n            0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n            0xb4,\n        ],\n        [\n            0xeb993de4326322c7d2e7979b705653,\n            0x1d611f18aa83085ef385333ec454c3,\n            0xb7a3bee73153dae2577781e9a435b0,\n            0xee599bc9d964a749c73673b0559c2c,\n            0x35c1adbbcbfe860f721aa7a0fc3f13,\n            0xa8c28cff73d6ab769ff07f77246062,\n            0xa6263efec60ed7d395f486a0a96b2d,\n            0xa6da86e3c3abd7bec42b6fab8927bf,\n            0xc5a27d894e67e310bc4490762e53dd,\n            0xea29c3c6430885ae7b68d1399dd42e,\n            0xb5a82288241107dcc02e4d04cc0fd,\n            0xf9dbe42935c2111913f05933346bb8,\n            0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n            0xbc6d3e01593e9d1c9399245a306ccd,\n            0xf5da9e23e54b7ace54fc14e9b8fe89,\n            0xc087aabdf746e1a12a8792cf7ac5d1,\n            0x5c825b2c8353558dd371d57b1d31af,\n            0x16b6,\n        ],\n    );\n\n    let signature: RBN2048 = RuntimeBigNum {\n        params,\n        limbs: [\n            0x0d643395f61610f78e0965ff28b34a,\n            0x991a18b16cd776f8ba0dc7d3a2c0ac,\n            0x59ad92fdc6573338573a5ec3a8ac1f,\n            0x39fa3c545c220904560f89449e0cb6,\n            0x77c0492bb5f8faeab6484258164fef,\n            0x32f66a824fc81c4bc3a10228c9d875,\n            0xaf5a933d03c5c769af3e1c43112418,\n            0xe4b3c71e29d230dbcd784dfd344cc6,\n            0x08f5fd6f3b0782eaae154fe56fbe0f,\n            0x9b785970ee35b2cd656cd9f098565c,\n            0xc6c649021334fff3d4ba072255eb0e,\n            0x1fb7d5c84e2fc4e975ea5793a92fc9,\n            0xcbb718f2f6c780b4f6e3a17575b89f,\n            0x04f7eb7174814ff492727916397bb8,\n            0x77790f451d53ce4d4229791f142d38,\n            0xd9ab6403501d48c29b3abbad760d43,\n            0x20d90ee7975dcbd1761fa7f6487391,\n            0x17,\n        ],\n    };\n    assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha512_pkcs1v15_2048() {\n    let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n        \"Hello World! This is Noir-RSA\".as_bytes(),\n        29,\n    ));\n\n    let params: Params2048 = BigNumParams::new(\n        false,\n        [\n            0x56acc9475dd0568166f6d519d2b123,\n            0x4388e4291f2a16d58441e4c966d869,\n            0x3b6cbbf6524f2e12e274d96a598cf3,\n            0xcb7b28845e13e53fc8827fadcbf5c2,\n            0xc2f20ecad4360634ca81a3f2700df9,\n            0x71b5ed85f3cc58e9820fa9cdabf2b4,\n            0x8e15d0237c7dbee5369ccbf8f6e25e,\n            0x280d4771bcddaebaa691b4870d4a92,\n            0x3f8ab4c278a35f45149814c95c1c6a,\n            0x4b88bb3a4f16adaa8a9ffa781086ad,\n            0xb4e8dad6bc3fd7d666683e872832e1,\n            0x3135b2958becadcb9e25ec25e55b23,\n            0x405ef523d210399f9def6302a36221,\n            0xb9aaf3a3c5b2e3f4f86393bde7b852,\n            0x5f66a3d278b5759b92269481eb94ca,\n            0xb0ae491acfb3d0a8a46a92b7adffb7,\n            0xa61f0e1720a3cc4594121de7aedf34,\n            0xc0,\n        ],\n        [\n            0xa1818833c46a2c4799148d9f1264d9,\n            0x91008bc32d17f31c4f28b53cf3b9a,\n            0xbf512971ab01254af711f37837279b,\n            0x4f98e0725dbc7d52fba2f5d5482d5,\n            0xc06343b59716c402d33ae0d15ce9b,\n            0x96e236079ec038a21029aba4ff7ffb,\n            0x76e91c4ee8870b1d1c06b73a00f0f9,\n            0xc5018d4394283930ab64cc401b3809,\n            0xc8b4f3f863b01b0fe223822f163552,\n            0x6a94ec6a63708552ac0ab6a824f380,\n            0xc3cf47d1d72b08284f9c04e265a5bc,\n            0xa9d863c6820f2ec1cd35de9327b153,\n            0x85983ec02cffd866801e790bbfa7d2,\n            0x5ee89f7c98ece0aaf4150b6c5b6abe,\n            0x7255ef31994f3cb4b731d0bbf76c57,\n            0x3aba2e537e9003f447c62153c3dcd7,\n            0xf005726db837e60cff0feaac8d326d,\n            0x1542,\n        ],\n    );\n\n    let signature: RBN2048 = RuntimeBigNum {\n        params,\n        limbs: [\n            0x8c1ac22b4f25479bd4d63adc5647a5,\n            0xc226d235d17e3ce2d6303804edd317,\n            0x75992147cd0883367aac32c28927e2,\n            0x7f131d0a5dc76ac9a3982bc3430a66,\n            0x1e5c5471a794bede59e42c5125df77,\n            0x7d4d8bffa69b08eb5a9338c96eb042,\n            0x44bc5745bdb2ed1944e61939c9b325,\n            0xa9c536593f93201b1493257bfceedb,\n            0x9f00b9f27e424f9724c1486fb54314,\n            0xeae7e1250521e254ee2d31f94002f9,\n            0x9ee4db7dbe46139670393a1250fa79,\n            0x014039fcd5bcfa3db273bf7188b3ce,\n            0x4967a88c2ddaf359c3c813cfa3ccc6,\n            0x9c3f74383a8c3326b47401d5815c45,\n            0x2f666d5fbe8464dcfaf569bffa0248,\n            0xfeccacb7e9e0e44320651e58344e8e,\n            0x8942c708df7e40a175d44fee7cf5ec,\n            0x4c,\n        ],\n    };\n    assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"hello world\".as_bytes(), 11);\n\n    let params: Params2048 = BigNumParams::new(\n        false,\n        [\n            0xea12ae77c634ac18e8914b0f112919,\n            0x7a385b52ed45602b3166e3006cab17,\n            0xce91edcb26009ae4ca5ec9032ace54,\n            0xec45aa323af9389e814dfa59e4e106,\n            0x50332220bbc7184b2b54c87acb79fb,\n            0x1fead59aea9260a545bb9b1e098753,\n            0xb362f1fc50b04e6581b34f97a769b5,\n            0x409c9d7b3a3ecb214e9dc5524e21a3,\n            0x88974631f1a1eed0c9d1fa6cc3c622,\n            0xadacc23ed4a6e2c0e968ad1da6e5b5,\n            0x480a5bbcc4e18d45937957d44adff2,\n            0x4d54fd4d3ab7ac249866b6aeaaf37f,\n            0x7eb6e94460e5dab5f15c55faf1bf5b,\n            0xc0bca2fb49828eb02a02cb3d95f48a,\n            0xeeb45b7149ee2bffe342120c8ef177,\n            0x9108e90248dfab616da128279b0391,\n            0xd446716c4e0be2123afd277a2cf8a7,\n            0xe5,\n        ],\n        [\n            0x8653d918663eb92721c6efedf149e4,\n            0x3dbb26bf3a033499240fd8ef578107,\n            0x69a15f7a032e80ef1496b60b3b95ae,\n            0xc9aff3026bae96644fc904d80d3c0a,\n            0x4cb0ae9774e8045235dd864f81314f,\n            0x65c558cd398b18126e7f3788d196c6,\n            0x5d7cdb26a9343a94726693b0b5a6c6,\n            0x4b3cd2b0ef752aa26ba6a7fba6f795,\n            0x6632fa88182883e987e0db1bcaaaea,\n            0x38098156f929b4fda6d3026667b3a0,\n            0x5d5bee367212e64a7d1bd3307082a4,\n            0xf2622828a7f6e5d906388ec2aa850c,\n            0xacfdba93e953a71ce0a75f3f88c96f,\n            0xf8a2b79dfe7264e30b058d44747277,\n            0x8cf6a50c2e0723546a03d684e3fda,\n            0xc95e8eb25fe50e2ad34e494492abf,\n            0x6a078f758586eb4b1e60059a1826b1,\n            0x11d2,\n        ],\n    );\n\n    let signature: RBN2048 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xcd01362e23da8aa633cb5a0fb9808d,\n            0xd3be03e14b0c1eea086ef6aca3d51a,\n            0xc7bb806d6723bb12c95ce0e3bc5588,\n            0x05f9843f35688f97a88273cc30b661,\n            0x25679e918a53da7baa6840d660305c,\n            0xb89d2c648f85e1372ae090aa89e19c,\n            0xb90686c46e3c9be1e0f4006047bf5b,\n            0xd2d27921c3c5b8613d4fec51eb7045,\n            0xf5e86133acb02bd34dbac6805c5958,\n            0x84fe10899677d060461b0c3619dcfc,\n            0x8c9a26f5a68450509aca9d347f0d51,\n            0xccb9f4406f2c75407b871d39a06cb1,\n            0xcc95879813f3f90c64f7b5c21b3b0e,\n            0xc519654312dce978c9f368724d8c8f,\n            0x5ec258287e34b65bd13cb4c05381ae,\n            0xd8b5e5f82508cde542538a1973f37f,\n            0xe035ef2e15b18975521e6ff25072c0,\n            0x34,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n\n#[test]\nfn test_mgf1_sha256() {\n    let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let expected_mask: [u8; 32] = [\n        106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40, 232,\n        179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n    ];\n    let mask: [u8; 32] = mgf1_sha256(seed);\n    assert(mask == expected_mask);\n}\n\n#[test]\nfn test_verify_sha256_pss_2048() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params2048 = BigNumParams::new(\n        false,\n        [\n            0xb2cae9b4d726643aef459696fb80d7,\n            0x46585d789783e6f0ea6a4a17001b8e,\n            0xfdf7476659c117564ca991f3d635f4,\n            0x9bb5835a63f78d2ff06927d5f5a64d,\n            0x18ce92c21c9a7dad5ed41c66790811,\n            0x38003b2699273864cc87b363714855,\n            0x7c19d41f8dbe41e03505fe1e061a5a,\n            0xd63a7a6d91625495e46db9161b0d7c,\n            0x3dffb1f7121946f6e04dc642a85da9,\n            0x389eabe29dbf38c1be95c9b9c0c029,\n            0x77a14dc6452603a154cc463e4c2a3a,\n            0x68eaeef1963fa3866c934d1225ac67,\n            0x3a66b9b64048ed95cec6bbe4235189,\n            0x113fd1c23822a8dd63e7d97b034eeb,\n            0x28b7376afc6109602ed94eb40284f6,\n            0x4d331f4da82c798979e7d9d2c5f7bf,\n            0x716d8b401bea115cf1265f976aaccf,\n            0xaf,\n        ],\n        [\n            0x399ea4dac74d4757a7a2956b5b0493,\n            0x954c409a53ce8d70f35be10b94d284,\n            0xee4d330032d52a65e66f54f9e091f4,\n            0x7522b6ca940bfc5133b8fd77ca4bc8,\n            0x43485c2c6ac94d8041c5a056da794b,\n            0xa464924f3a28ab23c5ffa0493dddee,\n            0x8fe3f1bc6a09e1103acbb53acbf6f1,\n            0x5e47597909e86c168b5748cc089ce1,\n            0xc86b6b4de2aa786e144d0ef5556c30,\n            0xf45a9d9d93fbe0cd5f2ddca2316648,\n            0x5edab2328b0b639407f9c773a06c5c,\n            0xb61d4e287c0c6a969f5decfd036ea5,\n            0xd47864f47e49cd0e0ec34f120ba0a4,\n            0x3eaa94f799b276ef6a790eb61722d4,\n            0x5c18da1341811cee5de6f76ed1a186,\n            0x5ef0641da7cac0c45ba74d4355befa,\n            0xbb04586630e92ea5ece8e5db45caea,\n            0x1758,\n        ],\n    );\n    let signature: RBN2048 = RuntimeBigNum {\n        params,\n        limbs: [\n            0x6d3125fde00a57fb5971460c38a826,\n            0xba2092dd58c4de8ffff2bf13f5ef57,\n            0xf0ad4ed46727881e7e7f6a103d7713,\n            0x7e8b2203a7a6e3a3a30219d6edf8a2,\n            0x9b0b861dd1cb2751f30d54d07ad167,\n            0x4373e863b15edba97439182a6a9043,\n            0x61621211db5f34a0786d5ef38cd90c,\n            0x63001609f7dffdc70761c67617b580,\n            0x8b2b817a0508e4be6f2c50df23962d,\n            0x6d6f9396978782a90fe06ca78c4f88,\n            0xc567a9fe5f7175225384d7c1e4c991,\n            0x38926dfee8636b9e36728c1cf51198,\n            0x0eb84e90f89a0bd21536a537618b92,\n            0x23dbdcda1fee2b57c8dc2e605777b7,\n            0x6acac69b2fc1c12c204e790034a01e,\n            0xee44b77264385863ccef2e133241cd,\n            0xe9c67049c219997cc8c43b0b1f420b,\n            0x78,\n        ],\n    };\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha384_pss_2048() {\n    let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n        \"Hello World! This is Noir-RSA\".as_bytes(),\n        29,\n    ));\n    let params: Params2048 = BigNumParams::new(\n        false,\n        [\n            0xc3034c17b5578d9c029b22158a8e45,\n            0xa84c80b43a68c9eb7cde67f1f60e07,\n            0xa8d82a4aef2cd733a9fdf43439ffbb,\n            0xa1b9aae31832c2815b81f0db70962e,\n            0xcfcbc51338d691443e702bd18354a7,\n            0xaa2c5f465a247efc9d97fb052579b8,\n            0x571f3c233fa322a933a4cfc0c4b213,\n            0x3280f1f7238a3416c5e1140077537a,\n            0x8685f03e3076c1bb62550cb363ae08,\n            0x55ebdcb84073ad2dfd3553c5e2d21a,\n            0x1e5a0a662b44f5250377abcd1069e6,\n            0x178357493184215e38603004f6c9f3,\n            0x75cb8889b33c6b78bab0a378453376,\n            0x4f5f7baa56492d5ac52c1bf7b998b,\n            0x16cf48a7c416bbf67657a263376e22,\n            0x1d8ab41c7021ebcb15da705dab5343,\n            0xc5e43d48377059df0aa5d7e5441586,\n            0xc7,\n        ],\n        [\n            0x721a52a87ca82263e96fd6d2bf3417,\n            0x74bfd742af70020df01f6cae960793,\n            0x1091edcad411cdbfc254bbb2ab2906,\n            0x9d1a2951a8e50de9c90b803c3d4931,\n            0x506ad1760d06b52708ccc0ed9fe629,\n            0x11b96266505a62523f9cfa1101a9c8,\n            0xbe5243b0f30ee090c4181e19f45f1a,\n            0xa2a56edaec8f9fe12d4d07d725931e,\n            0x50723b780f7ef18393031ced4f1489,\n            0x1ef7d8dc5b567db0b1a65b745625f2,\n            0xf9f37b5efea9a93029d7d5dda26bc2,\n            0x759247cff5570cb9075ae0e8b5cfee,\n            0xfb2e6c00b4ce0feedc40f3633d354e,\n            0xc9051ad4f912e7a5753e614d892320,\n            0x3cf78d852f5f76bc267b0ebcf13c39,\n            0x7b3cb2df2619a3020f2080dd555657,\n            0xd649e6032585f42250ac6c95111c09,\n            0x1480,\n        ],\n    );\n    let signature: RBN2048 = RuntimeBigNum {\n        params,\n        limbs: [\n            0x06d24f9dbd859780c7684e7733ebb1,\n            0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n            0x67878f2493de5cb48ae107df08dbf1,\n            0xf268bc940d64e42b8719216fef188e,\n            0x2c4701120db41532e6d195ba1f8faa,\n            0x03d3b537eefd6f0c99fbb7c1f359d9,\n            0x35b732ca45b03bb17b1f3564f18464,\n            0x468584d7dac0a4ba51032e2a5f95e2,\n            0xe10042eb30d1662517aed3b89e1154,\n            0x0e5743acb366c6251627e64f751256,\n            0xb06e6af3e06ed5c656e66aa0295f63,\n            0x67378aabfe17e33e305825eb4f6c5a,\n            0x8cd4c7aa81b660325dba4b0d899a9c,\n            0x40c83a9c74f99c026aa845fa222b69,\n            0xd52f8e19032a33a1d9a01063fff8f9,\n            0x7dc36972054edf46bbfe918711e693,\n            0xb035fca3baf4329ff5d588baf7b034,\n            0x1c,\n        ],\n    };\n\n    assert(verify_sha384_pss(sha384_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha512_pss_2048() {\n    let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n        \"Hello World! This is Noir-RSA\".as_bytes(),\n        29,\n    ));\n    let params: Params2048 = BigNumParams::new(\n        false,\n        [\n            0x928a173c3947c058b084e258b8a4c1,\n            0x5f1179c22cfacb440464695cfa393e,\n            0xc409e532b3077ce4d90e66e913f125,\n            0x29e8696374f86380ff45d0f29a98d5,\n            0xf931d155d89d3753ee931433a8e2fd,\n            0xfc3d1c2a999f0112f5c5416c2e0428,\n            0x4d21692b210bec2ab8e1b52fe78e66,\n            0x9df364fad350d314b146e84f114203,\n            0x8511a74031596831dda8ac9d18dcf7,\n            0xab5f9ad71b33284aae738988284229,\n            0x3332aa31681f69a5f470caadad7469,\n            0xf1fcad281e0fea144e1f4208d38e38,\n            0xe83d3b0afb20bc39814ea22df000ef,\n            0x3d9244664808f54fc4f0702adc9399,\n            0xc087b5dc693953e6371b9c7c175a21,\n            0xd5910d0d4232e8f92148482a72baec,\n            0x44e57b58ec4e75250116ce2f1abf3b,\n            0xd2,\n        ],\n        [\n            0x74b3f4c907125a6150549b8b5a387e,\n            0x9c2ecc9981d5fc27f5a6a7b4f23756,\n            0x57ee194ec44b4a44df198809f8d673,\n            0x7ffa9a1ec7d9a9b915e1abc75c493f,\n            0xde339596c27c993135a7ee132cf774,\n            0xfdb788951d3777aeea6afee171b569,\n            0x8dda93126970270ed42ae605e9824f,\n            0x3fa6e07b4429f0ee8370c988553ee3,\n            0x26d95e43ed1e1960a316eebf6b3b0b,\n            0xfd155b9025d16ecdbdac73725d9a89,\n            0x2f5a47107ec03b05f5a10fba4fa1df,\n            0x61a45285c5dc3355741713d6d71a24,\n            0x8644f1f46cecd803e531110da3bd5f,\n            0xaf989d56c5412bee6598af25829723,\n            0x52f7827f7aee453f9c3eb9753fbe4b,\n            0x9f38d6f5f1a3ff0d40c601d799dbb0,\n            0xd401bd1620fdd206413a8977de6375,\n            0x137a,\n        ],\n    );\n    let signature: RBN2048 = RuntimeBigNum {\n        params,\n        limbs: [\n            0x2058f7115f339e55a93f8dcefe81b9,\n            0x38a20cdbfc439a1fea423c119f2879,\n            0x7ac4e03a5fa662754e6e21a78984d4,\n            0x69d714829d29b235d588476152b5af,\n            0xce3db2102990c27bb66bc32da8dec4,\n            0xb4914f6f0e73718b5f1e422fac6ddf,\n            0x7d812b554c81ccb7932d1e78c6e002,\n            0x438fe60d9e0912328374513ab91b69,\n            0x56abaf2b8d9a6dcb9201586d2f0d0a,\n            0x4151c524481066bd81b4cd17829481,\n            0x7c63b445e245d09ca91057032ad22b,\n            0x9f242d5a655035a028a68d337ae40d,\n            0xb5f91b99b495862044bc7122913806,\n            0xc123aa56dff5b23d7d8ad097748efb,\n            0x6892e3a32a7b6963d97b3bdd81b91d,\n            0xcd7aa9e3e77f68f0ed195bff92a162,\n            0x583a32fd5a399f3acd867dd7d6a1b6,\n            0x7f,\n        ],\n    };\n\n    assert(verify_sha512_pss(sha512_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pss_4096() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params4096 = BigNumParams::new(\n        false,\n        [\n            0xd78653b3d43a72784415fc0537129b,\n            0xc725d4fb19419a03b58e0fb5ea4ad2,\n            0x1d866cfc050224a0eb317e835ee283,\n            0xd298018e86d3225a264a449c63d69d,\n            0x824db5365a077bf704acd2446baa7f,\n            0x5c419e562b5b5ccb0dcb151a3f48c9,\n            0x198a6627edcbc2afce1893217c2e25,\n            0x29a693a0bb3f6f02d80e660f681d6d,\n            0x5656562a9622f87bfb969db2542f63,\n            0xb9408b08a3ee3b25b6dc6ae12899ef,\n            0x4ce9b767219e1e0593782ce46a041f,\n            0xc5a4f318b34ff79121677f283ceea1,\n            0xbd5e62c599453a94e0bf5f48c6b58a,\n            0x6ce23c4978ae07af4c46ea9b9964ad,\n            0x68d4db6209ac89538e6d986cb77459,\n            0xf2ada72cff01696e2efdf123ab60f3,\n            0xf951c3c1965c355f460fa815587ed2,\n            0x6063ac0275e6592b878d5a66e68501,\n            0x594eb3db288ad091bc1db2b2a90101,\n            0xb72899c91edcdf890053f87d5b1dab,\n            0xdfd45eab0c435e275202bff1e22f5d,\n            0x3da05e1d0d3cd0012e6c40e1878ab7,\n            0x4fe053feaf486a27dd119cbee9ce1e,\n            0xa3781b036bd3a3411c2af8377ad0d9,\n            0xdf4410ba8397cbe580fc5eca7d230d,\n            0xdc34151036d459fc3c21d8ba0702fc,\n            0x4ea71eb1b0b1a2f36741b61e8765d8,\n            0x22cb66b4eb0b34b34320402ef652dd,\n            0xd19167b88620fc6b60709fd39cd48b,\n            0x524e4fbe4d75e4817de075ac70c72f,\n            0xd0de26679602cd331c3e5534ce668a,\n            0xf5aa120ff51d4bd3d57c1d68359f95,\n            0xaa06f0791b623cddd53d787035bd66,\n            0x122e014d565fa26417a5ed0f786fbb,\n            0xb95e,\n        ],\n        [\n            0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n            0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n            0x3e936bb516c60dec6e7bde90a54056,\n            0x78a92edbea967a370dc928b2f4cb53,\n            0x99df0977952d4278e6b4c792b31c39,\n            0x7d894ebed8702b158c7a51dff502b8,\n            0x6da93f37eabadd8e55d4f450bf48a6,\n            0xfb59acbad033856be388bf59b73c4a,\n            0x8644dd32dc773e5e12e03380dbff01,\n            0xdff59e8aefb7acc81bde30f7b22890,\n            0xa646c3f6a98819547eae677e99679,\n            0xc777d7da058b7a0d88b7ec84400a6,\n            0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n            0x6f2cc8babdde75a318872b952885fa,\n            0x6fc91aadc8ce227e9039c8f3148d9c,\n            0x67773f804221d4f58ca3bd11952bc7,\n            0xcf5a20affc5a099ad25abb5b9cc622,\n            0xf60a9108eb36c8068e93e524c23512,\n            0x8b67af87617dcd94e38a62a7297673,\n            0x656343f8e1802e8c043b2621f5b08d,\n            0xd82c8e1a8d3e458e7979a77cd76424,\n            0xd2bf783c787be340bd66fb8a07d1d7,\n            0xc94d16e2ea48369f57abca5909b81c,\n            0x2ff442542b4e904ad3ca20d06ee11f,\n            0xa1fa20565627dd7eb96b4027b6714f,\n            0xd3a82d484df4983db5fadd7b93048a,\n            0x5f4e993b09d0ab81b8312bc09f069,\n            0xcd135a6daa623b906fb62c6e28e9e1,\n            0x1a5abe5655f62a0a0d0d9479ae7675,\n            0xcfa89adba08b924725c940a56ad9e,\n            0x6023b1d30936eb9ee54bf789026e22,\n            0x9e91f11aa269f381122653c704cd5,\n            0x2116e976d592737e0c57dc12269efc,\n            0xe88a3202a09bdeaa3db69af98a651,\n            0x1618be,\n        ],\n    );\n    let signature: RBN4096 = RuntimeBigNum {\n        params,\n        limbs: [\n            0x5d9212d0c25acc14b61c6ce61a844e,\n            0x9d369ae765eb0545f83f552b8d7bb6,\n            0x5f0f5d383bd70d7726a851c422fe29,\n            0xcff5886575636efcde5d9843e59a10,\n            0x5820fa1e3158154641adb2c28a8954,\n            0x03ce0301512be13c0317fb679e6348,\n            0x13ec0af966303ca69b6f7fece6c2f4,\n            0x58dcc592b80e4756a8d01224e6174f,\n            0x73610ba199750de1e35cd658cbae92,\n            0xeb1d49f1ecc3bf332b4048d978a46a,\n            0x8c9ad13691accdce88ce1e6fda0bf5,\n            0x425e80441351444e751cd86b97b464,\n            0xd25a9581921c44fba102ed92a75658,\n            0x698c73a7fc85fee22b1c7f04fb4600,\n            0x70267fc50db236dfcf1e9405e25856,\n            0x1a35b94cf56f801be96defed712afe,\n            0xa3ecae6965b3bdee416f8d506f64fd,\n            0xc875faf0fb4e4fa47ff65aba633529,\n            0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n            0xa666b5d8c9f3217c412610ae91c862,\n            0x517ccc77102fa7799e521ef0e6d4e7,\n            0x7a50f7e553db75f0e0bd18d43bd622,\n            0x98e8da14444b6cf3d2b91d84da3506,\n            0xd1f5e4f7a725babc988cc7822c3d0a,\n            0x09ee2caa2e6f8b02db37ebe2352624,\n            0xd500b790312328a681b89b5de51b4f,\n            0x5ce0ebb445d4c82c3ecf21134c00bf,\n            0x83b6fafae79bc59f07e9b6802ef018,\n            0x8efd78556c637f8af6299ace0cd790,\n            0x5e99cf54d0f7e491cd72bcf20701fe,\n            0x19f15da137fe1bbe44c5531300829a,\n            0x0aae159f54317b49ec6b083292f57e,\n            0x37c2bba2237a59a35556f2d351c728,\n            0x7ec51821f03bde0c862e19e6ebe62c,\n            0x2081,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pss_2048_exponent_3() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params2048 = BigNumParams::new(\n        false,\n        [\n            0x1c961b234309c24fdab3f3e8a09da1,\n            0xf4aa851a30a198c359f3779b6bf4e0,\n            0x844034a1488c79edf31b1711a5e547,\n            0xc83ad2f9b30cfcb6d5f7c152a78e62,\n            0x16e97e0f8d8bad08da76d859c575c6,\n            0x6a85158069b211820a596359d0dc47,\n            0x1b834ed69818f1aa7d9944dee07b20,\n            0x4d7148da361f1881cd4fd396ef46d2,\n            0xc4cf36bbfa2781703699abf19a1e6d,\n            0xca4bd632c8eb2c8051915c3530aef9,\n            0x9cbfd5681aa95ade8eb256925d60ea,\n            0x3b8153585ff5f1d7b1ed37ac709dc6,\n            0x7d741c118fd653af3c21848f789ed8,\n            0x7aefa65093c124e46405849ca82ad1,\n            0xf9dbb9414e8eb849e2532d3f55d0b9,\n            0x35aeee862ac76c20be58527220f6a,\n            0xa3b6f81f07963c34ff0168634f8a99,\n            0xc4,\n        ],\n        [\n            0xaf8e2d749a5966b98ffa10ea071d41,\n            0x83704b0ef8ae71e3f1a7d24d871556,\n            0x82903be42859c5bd5cbb935d1097fb,\n            0x5bdc4e1e26670ed73580e2c8c144c1,\n            0xce5178ff7019c4a6c0a2743ab2fae1,\n            0xfd9ba73654ecf2020bdfa6ed9dc777,\n            0x9ba95e3e7551ee261a4f10eca35f05,\n            0x9e09b71274e5df10e06a6ce6319c3f,\n            0xb14781efad91be0888f5150771eea5,\n            0x15d2f490d6ba3cf25ad91e5e2539b0,\n            0x7887aca3df2194cdbed904e6d42977,\n            0xb797f21802a052c11e5c205bcb7d21,\n            0x94d15b35eaf46e2fe69f2b60c02922,\n            0x73814f1d160107a3ff1081b0cd1fea,\n            0xaa4c31b61839c41980a8bb9c922a0c,\n            0x123cc9f0ad08747529171a2e286eb6,\n            0x7a8b658fe4e9b448debf21d8ea0cc0,\n            0x14d4,\n        ],\n    );\n    let signature: RBN2048 = RuntimeBigNum {\n        params,\n        limbs: [\n            0x091a8c417287e046ec96c62b5ac66f,\n            0xbe71db0fe3122ea5624e8e7a0a72dc,\n            0xf35e5f3537c0ad0e938fdedd454de9,\n            0xd53c652cc3aac5d11fe6f5bc7ec536,\n            0x5d6869f0dd8b00697743f956b9b112,\n            0x5d46286274a1128a8fe0d96e859837,\n            0x951ee9dcb59dacebba972e9b9d7cfd,\n            0xd22245a462bff840a882f6869689a5,\n            0xcf7605b64a20dc2c3e6d5ceb88a03a,\n            0x7831aa25052c11411c3e5bdbe7dc10,\n            0x8e3bce799814987c984a2cc0e5d283,\n            0x7fdb0ce6e413e0f32742f4652f14a2,\n            0xa896a360bd70243209390e00761c57,\n            0x0d326051ac677371678f92bd182f13,\n            0xfcc593faaa9f45448ab756d70def,\n            0x2fd6d46ec8d25a6648dadf8246daf0,\n            0xe4aea2700222e610c1d94d82dd0f52,\n            0x9b,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 3));\n}\n\n// Test an unusual key length that is not a multiple of 8\n/*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n// Test an edge case where the key length in bytes is greater than the encoded message length\n#[test]\nfn test_verify_sha256_pss_1025() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1025 = BigNumParams::new(\n        false,\n        [\n            0xf278b138628000b2652c779e852235,\n            0x6d0676977e76ef0429002673ce9be2,\n            0x6cfc0db4d97f20ad2a1ad48cd899a0,\n            0x64024c19a1b1540e23ba4531e677f2,\n            0x3696125dd256ffed9567fccff06be6,\n            0x2dc09476b0c7629eed3c7c2cb591e3,\n            0x2e007f2f978504c5cfea0ec51ba0e9,\n            0x84ec9458cc6d0e95e06a7f404f26b4,\n            0x174fd186dca48668a,\n        ],\n        [\n            0x7ab08c63fb6eeee6204bd814d3134a,\n            0x20d51c551c06e8ae471cc43e84d131,\n            0x5eac3eae8238c6c2c37c1ce5bec407,\n            0xcff61632bd2ea6bc1dc8da002aa0c5,\n            0x801c1e85137856c4a6dc8c25078a59,\n            0x5ce8ee248cac12cbc3faa426acd58b,\n            0xe72384bb8302bbb78a3766fc61c5f0,\n            0x6ea716c0a657933b91b2d488b29cec,\n            0x2bed1ff958b58c194c,\n        ],\n    );\n\n    let signature: RBN1025 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa90e06eff7cbd20dd9c1241fe89290,\n            0x9ff719ce8f34229cd248e1f0ef4246,\n            0xd1d032dbf236cd711aa4fb49f0c71f,\n            0x454abf136ae14c7617df3b4d505e08,\n            0x45f30ac2c023205d35803f114f8ee3,\n            0xc8b1265c786d6da808ab31d35795a1,\n            0x1f75005a85f3636b099c58edd9fb8e,\n            0xac251bf9bb342b551c0f5c80449a3f,\n            0x03e2bc114292962b,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}\n","path":"/Users/ryan.cao/nargo/github.com/zkpassport/noir_rsa/v0.5.0/src/rsa.nr"}},"names":["main"],"brillig_names":["__split_60_bits","build_msg_block","attach_len_to_msg_block","__mul","__compute_quadratic_expression_with_borrow_flags","directive_integer_quotient","directive_invert","directive_to_radix"]}