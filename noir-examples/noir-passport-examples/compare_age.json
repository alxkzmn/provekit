{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":9033045103428484902,"abi":{"parameters":[{"name":"comm_in","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"private_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"current_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"min_age_required","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"max_age_required","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2916126463910380353":{"error_kind":"string","string":"Age must be less than 100"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3fbu3IfWbfpa99wfpDsiqvMhgETuIEBgw7cJwBBoHffdjusyn5kMPPapaOqr7FmwCdMFu/VVtSreLWWfyfn/7td//y3//xz7//47//6b9++qf/9T8//eFP//rbv/z+T3/c/ut/fgrT/Lf/5X/952//+PN//9dffvvnv/z0T+s8/ean3/3x3376p7Isf/3NT//++z/87qd/Wta//uZwaYhr+XZtiDW8XVz++r9/s73+8smvv37y65fbr1+X1+unqR5ev37u64fpk18/3F//dX/9MB1eP37y66e7r5+W+nr9PK3vX/94cVper5vW+frSdYnp27Xrkt5dPP8ydx507nnQuZdu587TPvccD3Ovg85dBp27/si54/p63e+2ruOlZU6v3+Nlzsv3c8dp0LnDoHPHQedOg86dB517HnTuZdC510HnLoPOPeh+mQbdL9Og+2UadL9Mg+6XadD9Mg26X6ZB98s06H6ZBt0v06D7ZR50v8yD7pd50P0yD7pf5kH3yzzofpkH3S/zoPtlHnS/zIPul/Og++U86H45D7pfzoPul/Og++U86H45D7pfzoPul/Og++U86H65DLpfLoPul8ug++Uy6H65DLpfLoPul8ug++Uy6H65DLpfLoPul+ug++U66H65DrpfroPul+ug++U66H65DrpfroPul+ug++U66H5ZBt0vy6D7ZRl0vyyD7pdl0P2yDLpflkH3y/JD98ua4uvaKcTra9cwf7t2ze/+mVo9m2F9/VOf7ef1/aV/Iyz2hNWdsE4OhGX/h5d1ORAGe8JoT5i8fg5PCLM94WxAGKcXYXz/qt8IF3vCfp2mhNcMYb6zH/brNK0I+3WaNoRx6tdpPkB4sR/GqV+naUXYr9O0IuzXaX7Vz+EJYbYn7Ndp/nHCqx0/Tv06TSvCbp2m5P3+Ul0PY3crKtdjd2sfNb1mqEu+YR+hW/toRtitfTQj7NY+PkJ4ZR+hW/toRpjtCbu1j1/3c3hC2K19NCPs1j4+QHjpV6FbUWlG2K/T1L3oOKVwY0OM/UpNM8R+raYZYr9a8xHEqz0x9us1zRCzP2K/ZvPrfhZPEPtVm2aI/brNBxAvt/7Yr9w0Q+zWbsI05/3iNX8/eOrWWdTg3ZrI3w1eD36RuvULNXi31hBC3AcPc7khfz+2U/dFjN16Q0PGbsXhY4xX/pe6NYeGjN2qQ0PGft3hV/48Hhlzv5rRjrFfI/kI46Xn5n7lpR1jx55T9hfebuLc2B9/bF/wixg79pxmjB17zkcYr/bH3LHnNGPs2HOaMXbsOb/u5/HIOHfsOc0YO/acDzBeOsDcsec0Y+zXczY/2RmX4+B51MH7NZL3g6/1MHi/miEG79cdUtgfFJr+/lvlgw449+sO7Rj7dYdmjEu/7vAhxisHXPp1h3aM/bpDO8Z+3eFX/jyeMGYAY79G8hHGS89d+pWXdoz9ek6ewv7C+c6/WF369Zx2jP16TjPGtV/P+RDj1f649us57Rj79Zx2jP16zq/8eTxhzADGfj3nI4yXDrD26zntGDv2nPrKx4R5mQ6Ddywv14P3ayQ1vv3E58O3SulXM8Tg/bqDGLxfIRCD97vL13l929UOt7d/bGa15eD97sdi8H43WTF4vzunGLzfnVMM3vHOeTl4v7lTNXjHO+f14B3vnNeDj7pz9psSVYN3u3PGadqz4NPx6NZv+FMN3u3OqQbvdudUg3e7c14PnvqNaqrBu9051eDd7pxq8G53TjV4tzunGnzQnTPdz0vmtN/+yO//SO50mPD2dI843QjEpfvRyC+auww6d+137osP2dL9GOQXzR0GnTuO8P19MncadO7c7dxXH7al++nEL5r7x+6XcX/CVYzrdOP3d1gHnbsMOnftd+6r399xGnTuMOjccYTv75O506Bz527nvtx34jzo3D92v8zx9UfPMdd6GGbtaZjyVcPMeToMUzsaJk1fNsy6HoYJPQ3zY3eLJezWvOQ7dw9SGnTuPOjcc79zX9lQWgadex107jLC9/fJ3HXMufPU7dyXFpfDoHP/4P1yff11RVzDjU58ymnQufOgc8/9zn31+zsvg869Djp3GeH7+2TuOubc89Tt3Jf7zhwGnfvH7pdryvvccz4Mk3oaJn/ZMOthu5rnnob5sXtQmfZhSio39vx5HXTuMujctd+5r/b8ZRp07jDo3HGE7++TudOgc+du5750lWUedO4fvF/uf1ca63QjB52WddC5y6Bz137nvvr9vU6Dzh0GnTuO8P19MncadO7c7dyX+846Dzr3j90v6/6oj3isOaR17WmY8mXDzIc/Z1lrR8Pc77Pkuqef52l5P8zfXj988uvHT379279757BXl+b3pfhvr58/+fXnT379+79zanp7/Xx4/du/Rtawh5W223PX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","file_map":{"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"63":{"source":"use common::{calculate_scoped_nullifier, hash_salt_dg1_private_nullifier};\n\n/*\n############################################################\n# Circuit D\n############################################################\n# Generates a scoped nullifier that is scoped by service\n# Allows selective disclosure of dg1 via a reveal bitmask\n############################################################\n\n# Inputs/Outputs\n############################################################\ncomm_in             `assert comm_in == H(salt, dg1, private_nullifier)`\nsalt\ndg1\nprivate_nullifier\nservice_scope       `H(<domain_name>)`\nservice_subscope    `H(<purpose>)` (Service-specific subscope)\nscoped_nullifier    `H(private_nullifier, service_scope, service_subscope)`\n\n# Checks\n############################################################\n- Checks that dg1_reveal is the correct reveal of dg1 for the given dg1_mask\n- Constrains scoped_nullifier to be `H(private_nullifier, service_scope, service_subscope)`\n*/\npub fn nullify(\n    comm_in: Field,\n    salt: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    assert(comm_in == hash_salt_dg1_private_nullifier(salt, dg1, private_nullifier));\n    // println(f\"comm_in: {comm_in}\");\n    let scoped_nullifier =\n        calculate_scoped_nullifier(private_nullifier, service_scope, service_subscope);\n    // println(f\"scoped_nullifier: {scoped_nullifier}\");\n    scoped_nullifier\n}\n\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/commitment/scoped-nullifier/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n\n// Returns the merkle root of the tree from the provided leaf, index and hash_path, using the Poseidon2 hash function\n// Arity is expected to be 2 and the the tree depth is equal to the hash_path array length\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let index_bits: [u1; N] = index.to_le_bits();\n    let mut current = leaf;\n    for i in 0..N {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = Poseidon2::hash([hash_left, hash_right], 2);\n    }\n    current\n}\n\n#[test]\nfn test_compute_merkle_root1() {\n    let leaf = 0x2fe190f39de3fcf4cbc2eb334d0dc76e4d06f2350aa6056c91ff5f11ded9fb4a;\n    let index = 0;\n    let hash_path = [\n        0x00,\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1,\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290,\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20,\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e,\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf,\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76,\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b,\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1,\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972,\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686,\n        0x0f320b0703439a8114f81593de99cd0b8f3b9bf854601abb5b2ea0e8a3dda4a7,\n        0x0d07f6e7a8a0e9199d6d92801fff867002ff5b4808962f9da2ba5ce1bdd26a73,\n        0x1c4954081e324939350febc2b918a293ebcdaead01be95ec02fcbe8d2c1635d1\n    ];\n    let root = compute_merkle_root(leaf, index, hash_path);\n    assert(root == 0x0742857aba0058b2167c4ac94fede8ec480600911aa871153b988c3f71095449);\n}\n\n#[test]\nfn test_compute_merkle_root2() {\n    let e00 = Poseidon2::hash([1], 1);\n    let e01 = Poseidon2::hash([1], 1);\n    let e02 = Poseidon2::hash([1], 1);\n    let e03 = Poseidon2::hash([1], 1);\n    assert(e00 == 0x168758332d5b3e2d13be8048c8011b454590e06c44bce7f702f09103eef5a373);\n\n    let e10 = Poseidon2::hash([e00, e01], 2);\n    let e11 = Poseidon2::hash([e02, e03], 2);\n    assert(e10 == 0x113d8ff59c2e15d711241797c380264e39dc1b9e00f2713e707d8d7773b6d912);\n\n    let expected_root = Poseidon2::hash([e10, e11], 2);\n    assert(expected_root == 0x0f4f16b234c1d5054b15d408282cb45ba6c10a629fe068e7f3cc253ceae4f08d);\n\n    let hash_path = [e01, e10];\n    assert(hash_path == [\n        0x168758332d5b3e2d13be8048c8011b454590e06c44bce7f702f09103eef5a373,\n        0x113d8ff59c2e15d711241797c380264e39dc1b9e00f2713e707d8d7773b6d912\n    ]);\n\n    let leaf = Poseidon2::hash([1], 1);\n    let index = 0;\n    let root = compute_merkle_root(leaf, index, hash_path);\n    assert(root == 0x0f4f16b234c1d5054b15d408282cb45ba6c10a629fe068e7f3cc253ceae4f08d);\n}\n\npub fn get_vkey_hash<let N: u32>(vkey: [Field; N]) -> Field {\n    Poseidon2::hash(vkey, N)\n}\n\n#[test]\nfn test_get_vkey_hash() {\n    let vkey = [\n        0x0000000000000000000000000000000000000000000000000000000000004000,\n        0x000000000000000000000000000000000000000000000000000000000000001e,\n        0x0000000000000000000000000000000000000000000000000000000000000001,\n        0x0000000000000000000000000000000000000000000000000000000000000001,\n        0x000000000000000000000000000000000000000000000000000000000000000e,\n        0x000000000000000000000000000000000000000000000000000000000000000f,\n        0x0000000000000000000000000000000000000000000000000000000000000010,\n        0x0000000000000000000000000000000000000000000000000000000000000011,\n        0x0000000000000000000000000000000000000000000000000000000000000012,\n        0x0000000000000000000000000000000000000000000000000000000000000013,\n        0x0000000000000000000000000000000000000000000000000000000000000014,\n        0x0000000000000000000000000000000000000000000000000000000000000015,\n        0x0000000000000000000000000000000000000000000000000000000000000016,\n        0x0000000000000000000000000000000000000000000000000000000000000017,\n        0x0000000000000000000000000000000000000000000000000000000000000018,\n        0x0000000000000000000000000000000000000000000000000000000000000019,\n        0x000000000000000000000000000000000000000000000000000000000000001a,\n        0x000000000000000000000000000000000000000000000000000000000000001b,\n        0x000000000000000000000000000000000000000000000000000000000000001c,\n        0x000000000000000000000000000000000000000000000000000000000000001d,\n        0x000000000000000000000000000000014d18053025847e890b73d1bd851d8010,\n        0x00000000000000000000000000000000001604875484cd0af6333f892d9db03c,\n        0x0000000000000000000000000000001aa505665b96ff23e66c8cc50617d912dd,\n        0x000000000000000000000000000000000023761d0fc8b989dd96889c0e1dd500,\n        0x0000000000000000000000000000005ec6b7adcaad33a31d00c481cada512ff2,\n        0x00000000000000000000000000000000000619dc9f99c6e6318f58a3cd578e03,\n        0x000000000000000000000000000000ca65a4903d4105e8ffb945a804fe5e758b,\n        0x0000000000000000000000000000000000013d6fe1a9ccad8cf0da0cbb325a50,\n        0x000000000000000000000000000000c3d521df3cd944a41cc6c93814e4bfb108,\n        0x00000000000000000000000000000000002967d970e732ce06f745a1676e907a,\n        0x000000000000000000000000000000bea006927efee453f22d7e5001156d8236,\n        0x000000000000000000000000000000000003da37e3170387f7fc7fe67f3fd02d,\n        0x0000000000000000000000000000007ecadab7d0191e9b27b8c118bcf63e39d7,\n        0x00000000000000000000000000000000001aceee76600298bda7debc2a13e65f,\n        0x00000000000000000000000000000094109ace5115b62b817510419b345bafb3,\n        0x000000000000000000000000000000000007478caa1879b0d66eafb700c8eaff,\n        0x000000000000000000000000000000c66580c6bd58511b6f734408a36072b4cb,\n        0x000000000000000000000000000000000012a966c244f2d7aef31bf501d4c7b3,\n        0x00000000000000000000000000000066953254478df3e72cd967c81f9d7520dd,\n        0x000000000000000000000000000000000012836bbc2291cc1a76e191beeeff55,\n        0x00000000000000000000000000000085f16f224863af3a2eb1640916d6e2f661,\n        0x00000000000000000000000000000000001d2c4076e8dcb9be0e997d8c5715d9,\n        0x000000000000000000000000000000e7e736564c69478322d60bf28db04d2180,\n        0x000000000000000000000000000000000001bac3d335ee7aece9c8e8b83c4a0a,\n        0x000000000000000000000000000000418412d57fe3f9d88befaf72e3f049aed6,\n        0x00000000000000000000000000000000002640a81c852ebd44791d208778e3d4,\n        0x0000000000000000000000000000003f0de2660faefec496cddfcf172d70f88a,\n        0x000000000000000000000000000000000023f365597e5a0fe284fe40ba6df049,\n        0x0000000000000000000000000000001ff3fdb800a12685d0225869a709c59ea1,\n        0x000000000000000000000000000000000010485496ac517ce4626468b80c20d1,\n        0x000000000000000000000000000000eae802a6cf93d2041722bcc7b827850d9c,\n        0x00000000000000000000000000000000002c3eb537afd8670ec12382677e9dfd,\n        0x000000000000000000000000000000da72208a8ea7aa2e70b8fc00cf95fbe413,\n        0x00000000000000000000000000000000001994c139d6d63fbb02a95416dd2057,\n        0x0000000000000000000000000000000c243e99da3df894bd68564c1f2189c436,\n        0x000000000000000000000000000000000004714d9481f6dbd276728639c54996,\n        0x0000000000000000000000000000007ffd262875ae684deba001fcc5fdea3bbf,\n        0x000000000000000000000000000000000026c3846eed3340f6f2e861943f6f27,\n        0x0000000000000000000000000000009e45b69b687387629e72688f33382df553,\n        0x000000000000000000000000000000000017612f582a3500568851ebdcb62e72,\n        0x000000000000000000000000000000898a13479bd1c1e27a6e0681a5d43985af,\n        0x000000000000000000000000000000000002f9352d7ab76f7b9eda17515fd7b8,\n        0x0000000000000000000000000000003c13860bb6a8f804652839fa9abe19bb7b,\n        0x00000000000000000000000000000000000ea81714a4cd7294ac6300617eb610,\n        0x000000000000000000000000000000dc6620bff3175f56800f1e44c3e79b256e,\n        0x000000000000000000000000000000000003c53e0fb2f68008220ac57a71c7f4,\n        0x000000000000000000000000000000ab9926a5dd872d669530c99c7d9be65720,\n        0x00000000000000000000000000000000002ea70327e45061f95597e2ccf26540,\n        0x00000000000000000000000000000032d9d845b89a70f07980c48344f7a599e6,\n        0x000000000000000000000000000000000020828423a9331f84edb915eeb4733d,\n        0x000000000000000000000000000000f020304aa06e327c9294f1254859db8ab6,\n        0x00000000000000000000000000000000001f5964632befb3e8707483b77e7881,\n        0x0000000000000000000000000000004d882ed48ddc17fda49a2e3c07bfa0b4a7,\n        0x0000000000000000000000000000000000238a9bda3f2d414f43b6d68db016da,\n        0x000000000000000000000000000000871bf5d454ed7a84525d3d52325dfb377c,\n        0x000000000000000000000000000000000007584c1032621909192d308449ced1,\n        0x0000000000000000000000000000005b72000fb18ad1bd936839038a2bc2b9e5,\n        0x0000000000000000000000000000000000268cfce53a1c077c835540eb73a23c,\n        0x00000000000000000000000000000000c747ae5e9a310b1d8baa8c34f92e8d0e,\n        0x00000000000000000000000000000000002701e27eec246967ec650bbe990bab,\n        0x000000000000000000000000000000a6783a604d35e125327e5fe8cf22398fdd,\n        0x00000000000000000000000000000000002309c7ceac11535749dab8c9f4d851,\n        0x00000000000000000000000000000065720cd086bae46f673f548239ceafb0b4,\n        0x00000000000000000000000000000000000a8ac00f8a2042f8f81c554dc404f6,\n        0x000000000000000000000000000000907c095579b757be6b50e41dc3692a224c,\n        0x00000000000000000000000000000000000a45377f92a8d6d44afe54e3717f8a,\n        0x000000000000000000000000000000d8642735ec11ef526dcffa791f1ad641ab,\n        0x00000000000000000000000000000000001e4fbc154b0c6b4c559f58a7d19ac0,\n        0x000000000000000000000000000000eff01a355a79835cc29ccf88cd9e3ca07f,\n        0x00000000000000000000000000000000002af5e29ca00459725e2680c6a78a6f,\n        0x000000000000000000000000000000da6c16f1483ae4228c68cc091f40d39aad,\n        0x00000000000000000000000000000000000ea734a85cf7a6d1d775a08afc61e0,\n        0x000000000000000000000000000000fd722ec69b8a01085785be11e41f873afe,\n        0x000000000000000000000000000000000006b8a63c9cf273d4724fbb10d5f57a,\n        0x000000000000000000000000000000f7d9fd5e858349061430d351c45499dfad,\n        0x0000000000000000000000000000000000046edaae51ba84f2dabcd56e9eed5b,\n        0x0000000000000000000000000000002f225a95524043ea68cc704f77ef4f6045,\n        0x0000000000000000000000000000000000038d07b151361621e074699b374a85,\n        0x000000000000000000000000000000da6a36c7ae48c4791868c3d10c8533fe6e,\n        0x000000000000000000000000000000000014ce118be5ef951902f6e84a561e88,\n        0x000000000000000000000000000000beabc4f9b42059a77a1b15b98856b48453,\n        0x00000000000000000000000000000000002114644c4953246a959f25a4bf2052,\n        0x0000000000000000000000000000009d10f2f38322da8ecb0b296bc729ff1c4e,\n        0x000000000000000000000000000000000027f1245b7ec2b0cb360bb134218ed1,\n        0x00000000000000000000000000000032957a466beb19e0675e0f739616187ecd,\n        0x0000000000000000000000000000000000235e20011670e41d045fd8446ae100,\n        0x000000000000000000000000000000691d28ce28c9ae3f7e8d3220cbfdb0fd36,\n        0x000000000000000000000000000000000004d8e62001cadc95344edcfd429fed,\n        0x0000000000000000000000000000008a34b9ab23bd2cd471701a5a76de4076b8,\n        0x00000000000000000000000000000000002c853787226778520baf3c5f0ed65e,\n        0x000000000000000000000000000000f357d89b0302e34eac204bc55974f0c37b,\n        0x00000000000000000000000000000000001a04dfa8543c150c4f07b768f1752d,\n        0x000000000000000000000000000000709f2727a8adda78f9cd125c85fc061557,\n        0x0000000000000000000000000000000000180b5e9b2901b08360c598f18581d0,\n        0x0000000000000000000000000000003f99f9fd98707c98fd62328a676c38bb38,\n        0x000000000000000000000000000000000004880ff78661543813929232e5c4db,\n        0x0000000000000000000000000000003fb3d6fdb1fe407fc26479a67309987378,\n        0x0000000000000000000000000000000000152830347b8e35a842ea020f557635,\n        0x0000000000000000000000000000004aed3df71695a6a5295e2117cc6c0a80df,\n        0x0000000000000000000000000000000000007ee2c78519eb92faa04d10b2ae9e,\n        0x0000000000000000000000000000000000000000000000000000000000000001,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000002,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x000000000000000000000000000000feb33855ac28e08d8b02991fb3f3c211cf,\n        0x000000000000000000000000000000000007d8476506cdef23b023ca072ed709,\n        0x000000000000000000000000000000e985e0b015edca55f69192bdb7139b7224,\n        0x000000000000000000000000000000000020470f3258600e780b46d6c7db1bc6\n    ];\n    let vkey_hash = get_vkey_hash(vkey);\n    assert(vkey_hash == 0x159c7f9777839c2449c0a0f90b411569ed72aaa9d090c82c9c028adf5419d3d6);\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/commitment/common/src/lib.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(15 - (N * 15 - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\npub unconstrained fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/utils/src/lib.nr"},"67":{"source":"use commitment::nullify;\nuse compare_age::compare_age;\n\nfn main(\n    comm_in: pub Field,\n    salt: Field,\n    private_nullifier: Field,\n    dg1: [u8; 95],\n    // The current date is public so verifiers can check the date\n    // provided to the proof is correct\n    current_date: pub str<8>,\n    // The minimum age required is public so verifiers can check\n    // the age provided to the proof is correct\n    min_age_required: pub u8,\n    // The maximum age required is public so verifiers can check\n    // the age provided to the proof is correct\n    // If the maximum age is 0, it is not checked\n    max_age_required: pub u8,\n    service_scope: pub Field,\n    service_subscope: pub Field,\n) -> pub Field {\n    // Verify the age of the ID holder\n    compare_age(\n        dg1,\n        min_age_required,\n        max_age_required,\n        current_date.as_bytes(),\n    );\n    let nullifier = nullify(\n        comm_in,\n        salt,\n        dg1,\n        private_nullifier,\n        service_scope,\n        service_subscope,\n    );\n    nullifier\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/bin/compare/age/src/main.nr"},"68":{"source":"use date::Date;\nuse utils::{\n    get_array_slice, get_mrz_from_dg1, ID_CARD_MRZ_BIRTHDATE_INDEX, is_id_card,\n    PASSPORT_MRZ_BIRTHDATE_INDEX,\n};\n\nfn get_birthdate(dg1: [u8; 95], current_date: [u8; 8]) -> Date {\n    let mut birthdate_bytes = [0 as u8; 6];\n    let mrz = get_mrz_from_dg1(dg1);\n\n    // Get the slice of the MRZ representing the birthdate\n    if is_id_card(dg1) {\n        birthdate_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_BIRTHDATE_INDEX,\n            ID_CARD_MRZ_BIRTHDATE_INDEX + 6,\n        );\n    } else {\n        // Otherwise it's an ID card\n        birthdate_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_BIRTHDATE_INDEX,\n            PASSPORT_MRZ_BIRTHDATE_INDEX + 6,\n        );\n    }\n\n    // Create a Date object from the birthdate using the current date as\n    // the pivot year to differentiate between 20th and 21st centuries\n    // as the format is \"YYMMDD\"\n    Date::from_bytes_short_year(birthdate_bytes, [current_date[2], current_date[3]])\n}\n\npub fn compare_age(dg1: [u8; 95], min_age: u8, max_age: u8, current_date_bytes: [u8; 8]) {\n    // Restrict the age to be less than 100 as the dg1 birthdate only encodes\n    // two digits for the year\n    // TODO: Add support for dg11 to support 100+\n    assert((max_age < 100) & (min_age < 100), \"Age must be less than 100\");\n\n    let birthdate: Date = get_birthdate(dg1, current_date_bytes);\n\n    let current_date = Date::from_bytes_long_year(current_date_bytes);\n\n    assert((min_age != 0) | (max_age != 0));\n\n    if (min_age != 0) & (max_age == 0) {\n        // Check if age is above min age\n        // The minimum age is more likely to be inclusive, so we use gte\n        assert(current_date.gte(birthdate.add_years(min_age as u32)));\n    } else if (max_age != 0) & (min_age == 0) {\n        // Check if age is below max age\n        // The maximum age is more likely to be exclusive, so we use lt\n        assert(current_date.lt(birthdate.add_years(max_age as u32)));\n    } else {\n        assert(min_age <= max_age);\n\n        assert(current_date.gte(birthdate.add_years(min_age as u32)));\n        // This way if max_age = min_age, the proof will be valid whenever the age\n        // is equal to min_age = max_age\n        assert(current_date.lt(birthdate.add_years((max_age + 1) as u32)));\n    }\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/compare/age/src/lib.nr"},"69":{"source":"use dep::std::{field::bn254::assert_gt, println};\n\npub struct Date {\n    day: u8,\n    month: u8,\n    year: u32,\n}\n\nfn get_number_from_utf8_code(code: u8) -> u8 {\n    assert(code >= 48 & code <= 57);\n    code - 48\n}\n\nfn number_to_utf8_code(number: u8) -> u8 {\n    assert(number >= 0 & number <= 9);\n    number + 48\n}\n\nimpl Date {\n    pub fn new(year: u32, month: u8, day: u8) -> Self {\n        assert(month >= 1 & month <= 12);\n        assert(day >= 1 & day <= 31);\n        let date = Self { day: day, month: month, year: year };\n        assert(day <= date.get_days_in_month(month));\n        date\n    }\n\n    pub fn from_bytes_short_year(date: [u8; 6], threshold_year: [u8; 2]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n\n        let mut year: u32 = firstYearDigit as u32 * 10 + secondYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[2]);\n        let secondMonthDigit = get_number_from_utf8_code(date[3]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[4]);\n        let secondDayDigit = get_number_from_utf8_code(date[5]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        let currentYearFirstDigit = get_number_from_utf8_code(threshold_year[0]);\n        let currentYearSecondDigit = get_number_from_utf8_code(threshold_year[1]);\n\n        let mut currentYear: u32 =\n            currentYearFirstDigit as u32 * 10 + currentYearSecondDigit as u32;\n\n        // This way we have a smooth 100 years period according to a threshold year\n        // Taking the current year as threshold year (for birthdates for example)\n        // if the current year is 2023, then 24 will be interpreted as 1924\n        // while 22 will be interpreted as 2022\n        // A bit problematic for people over 100 years old\n        if year <= currentYear {\n            year += 2000;\n        } else {\n            year += 1900;\n        }\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_bytes_long_year(date: [u8; 8]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n        let thirdYearDigit = get_number_from_utf8_code(date[2]);\n        let fourthYearDigit = get_number_from_utf8_code(date[3]);\n\n        let year: u32 = firstYearDigit as u32 * 1000\n            + secondYearDigit as u32 * 100\n            + thirdYearDigit as u32 * 10\n            + fourthYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[4]);\n        let secondMonthDigit = get_number_from_utf8_code(date[5]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[6]);\n        let secondDayDigit = get_number_from_utf8_code(date[7]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_str_short_year(date: str<6>, threshold_year: str<2>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_short_year(date_bytes, threshold_year.as_bytes())\n    }\n\n    pub fn from_str_long_year(date: str<8>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_long_year(date_bytes)\n    }\n\n    pub fn get_duration_in_days(self: Self, other: Self, absolute: bool) -> i32 {\n        let totalDuration: i32 = self.get_duration_between_years(other) as i32\n            + self.get_duration_between_months(other) as i32\n            + (self.day as i32 - other.day as i32);\n\n        if (totalDuration < 0) & absolute {\n            -1 * totalDuration\n        }\n\n        totalDuration\n    }\n\n    pub fn gt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) > 0\n    }\n\n    pub fn lt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) < 0\n    }\n\n    pub fn eq(self: Self, other: Self) -> bool {\n        (self.day == other.day) & (self.month == other.month) & (self.year == other.year)\n    }\n\n    pub fn ne(self: Self, other: Self) -> bool {\n        !self.eq(other)\n    }\n\n    pub fn gte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) >= 0\n    }\n\n    pub fn lte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) <= 0\n    }\n\n    pub fn println(self: Self) {\n        let year = self.year;\n        let month = self.month;\n        let day = self.day;\n        // Let's write the date in the YYYY-MM-DD format\n        // since people don't agree on which format is best\n        // between MM/DD/YYYY and DD/MM/YYYY\n        if (month < 10) & (day < 10) {\n            println(f\"Date: {year}-0{month}-0{day}\");\n        } else if month < 10 {\n            println(f\"Date: {year}-0{month}-{day}\");\n        } else if day < 10 {\n            println(f\"Date: {year}-{month}-0{day}\");\n        } else {\n            println(f\"Date: {year}-{month}-{day}\");\n        }\n    }\n\n    pub fn to_bytes(self: Self) -> [u8; 8] {\n        let mut date: [u8; 8] = [0; 8];\n\n        let firstYearDigit = self.year / 1000;\n        let secondYearDigit = (self.year - firstYearDigit * 1000) / 100;\n        let thirdYearDigit = (self.year - firstYearDigit * 1000 - secondYearDigit * 100) / 10;\n        let fourthYearDigit =\n            self.year - firstYearDigit * 1000 - secondYearDigit * 100 - thirdYearDigit * 10;\n\n        date[0] = number_to_utf8_code(firstYearDigit as u8);\n        date[1] = number_to_utf8_code(secondYearDigit as u8);\n        date[2] = number_to_utf8_code(thirdYearDigit as u8);\n        date[3] = number_to_utf8_code(fourthYearDigit as u8);\n\n        let firstMonthDigit = self.month / 10;\n        let secondMonthDigit = self.month - firstMonthDigit * 10;\n\n        date[4] = number_to_utf8_code(firstMonthDigit as u8);\n        date[5] = number_to_utf8_code(secondMonthDigit as u8);\n\n        let firstDayDigit = self.day / 10;\n        let secondDayDigit = self.day - firstDayDigit * 10;\n\n        date[6] = number_to_utf8_code(firstDayDigit as u8);\n        date[7] = number_to_utf8_code(secondDayDigit as u8);\n\n        date\n    }\n\n    pub fn is_leap_year(self: Self) -> bool {\n        self.year % 4 == 0\n    }\n\n    pub fn get_days_in_month(self: Self, month: u8) -> u8 {\n        assert(month >= 1 & month <= 12);\n        if month == 2 {\n            if self.is_leap_year() {\n                29\n            } else {\n                28\n            }\n        } else {\n            if (month == 1)\n                | (month == 3)\n                | (month == 5)\n                | (month == 7)\n                | (month == 8)\n                | (month == 10)\n                | (month == 12) {\n                31\n            } else {\n                30\n            }\n        }\n    }\n\n    pub fn get_duration_between_months(self: Self, other: Self) -> i32 {\n        assert(self.month >= 1 & self.month <= 12);\n        assert(other.month >= 1 & other.month <= 12);\n        let mut duration: i32 = 0;\n        if (self.month < other.month) {\n            for month in 1..13 {\n                if month >= self.month & month < other.month {\n                    duration -= other.get_days_in_month(month) as i32;\n                }\n            }\n        } else {\n            for month in 1..13 {\n                if month >= other.month & month < self.month {\n                    duration += self.get_days_in_month(month) as i32;\n                }\n            }\n        }\n        duration\n    }\n\n    pub fn get_duration_between_years(self: Self, other: Self) -> i32 {\n        let mut duration: i32 = 0;\n        if (self.year < other.year) {\n            let previous_leap_year: u32 = other.year - (other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year <= previous_leap_year {\n                leap_year_count = (previous_leap_year - self.year) / 4 + 1;\n            }\n            duration -= leap_year_count as i32 * 366;\n            duration -=\n                (other.year as i32 - self.year as i32 - leap_year_count as i32) as i32 * 365;\n        } else if (self.year > other.year) {\n            let next_leap_year: u32 = other.year + (4 - other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year > next_leap_year {\n                // Fixes a weird bug where the line below triggers a fail constraint\n                // while self.year is greater than next_leap_year\n                assert_gt(self.year as Field, next_leap_year as Field);\n                leap_year_count = ((self.year - 1) - next_leap_year) / 4 + 1;\n            }\n            duration += leap_year_count as i32 * 366;\n            duration +=\n                (self.year as i32 - other.year as i32 - leap_year_count as i32) as i32 * 365;\n        }\n        duration\n    }\n\n    pub fn add_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year + years }\n    }\n\n    pub fn sub_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year - years }\n    }\n\n    pub fn add_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as u32 + months;\n        let mut newYear = self.year;\n        let yearToAdd = (newMonth - 1) / 12;\n        if newMonth > 12 {\n            newYear += yearToAdd as u32;\n            newMonth -= 12 * yearToAdd;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn sub_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as i32 - months as i32;\n        let mut newYear = self.year;\n        if newMonth < 1 {\n            let yearToSub = ((newMonth as i32 - 12 as i32) * -1) / 12;\n            newYear -= yearToSub as u32;\n            newMonth += 12 * yearToSub;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn add_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as u32 + days;\n        let mut newMonth = self.month as u32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay > self.get_days_in_month(self.month) as u32 {\n            let max_months = (newDay / 30) + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as u32;\n                if newDay > days_in_month {\n                    newDay -= days_in_month;\n                    newMonth += 1;\n                    if newMonth > 12 {\n                        newYear += 1;\n                        newMonth = 1;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n\n    // Performance could be improved\n    pub fn sub_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as i32 - days as i32;\n        let mut newMonth = self.month as i32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay < 1 {\n            let max_months = (self.day as u32 + days) / 30 + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as i32;\n                if newDay < 1 {\n                    newDay += days_in_month;\n                    newMonth -= 1;\n                    if newMonth < 1 {\n                        newYear -= 1;\n                        newMonth = 12;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n}\n\n#[test]\nfn test_date_init() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_short_year() {\n    let date = Date::from_bytes_short_year([50, 51, 49, 50, 49, 57], [50, 52]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_long_year() {\n    let date = Date::from_bytes_long_year([50, 48, 50, 51, 49, 50, 49, 57]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_short_year() {\n    let date = Date::from_str_short_year(\"231219\", \"24\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_long_year() {\n    let date = Date::from_str_long_year(\"20231219\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_to_bytes() {\n    let date = Date::new(2023, 12, 19);\n\n    let date_bytes = date.to_bytes();\n\n    assert(date_bytes[0] == 50);\n    assert(date_bytes[1] == 48);\n    assert(date_bytes[2] == 50);\n    assert(date_bytes[3] == 51);\n    assert(date_bytes[4] == 49);\n    assert(date_bytes[5] == 50);\n    assert(date_bytes[6] == 49);\n    assert(date_bytes[7] == 57);\n}\n\n#[test]\nfn test_date_is_leap_year() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.is_leap_year() == false);\n\n    let date = Date::new(2024, 12, 19);\n\n    assert(date.is_leap_year() == true);\n}\n\n#[test]\nfn test_date_get_days_in_month() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 28);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n\n    let date = Date::new(2024, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 29);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n}\n\n#[test]\nfn test_date_get_duration_between_months() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_between_months(date) == 0);\n    assert(Date::new(2023, 2, 1).get_duration_between_months(date) == 31);\n    assert(Date::new(2023, 3, 1).get_duration_between_months(date) == 59);\n    assert(Date::new(2023, 4, 1).get_duration_between_months(date) == 90);\n    assert(Date::new(2023, 5, 1).get_duration_between_months(date) == 120);\n    assert(Date::new(2023, 6, 1).get_duration_between_months(date) == 151);\n    assert(Date::new(2023, 7, 1).get_duration_between_months(date) == 181);\n    assert(Date::new(2023, 8, 1).get_duration_between_months(date) == 212);\n    assert(Date::new(2023, 9, 1).get_duration_between_months(date) == 243);\n    assert(Date::new(2023, 10, 1).get_duration_between_months(date) == 273);\n    assert(Date::new(2023, 11, 1).get_duration_between_months(date) == 304);\n    assert(Date::new(2023, 12, 1).get_duration_between_months(date) == 334);\n}\n\n#[test]\nfn test_date_get_duration_between_years() {\n    let date = Date::new(2023, 1, 1);\n\n    // Positive duration\n    assert(Date::new(2023, 1, 1).get_duration_between_years(date) == 0);\n    assert(Date::new(2024, 1, 1).get_duration_between_years(date) == 365);\n    assert(Date::new(2025, 1, 1).get_duration_between_years(date) == 731);\n    assert(Date::new(2026, 1, 1).get_duration_between_years(date) == 1096);\n    assert(Date::new(2027, 1, 1).get_duration_between_years(date) == 1461);\n    assert(Date::new(2028, 1, 1).get_duration_between_years(date) == 1826);\n    assert(Date::new(2029, 1, 1).get_duration_between_years(date) == 2192);\n    assert(Date::new(2030, 1, 1).get_duration_between_years(date) == 2557);\n    assert(Date::new(2031, 1, 1).get_duration_between_years(date) == 2922);\n    assert(Date::new(2032, 1, 1).get_duration_between_years(date) == 3287);\n    assert(Date::new(2033, 1, 1).get_duration_between_years(date) == 3653);\n    assert(Date::new(2034, 1, 1).get_duration_between_years(date) == 4018);\n\n    // Negative duration\n    assert(Date::new(2022, 1, 1).get_duration_between_years(date) == -365);\n    assert(Date::new(2021, 1, 1).get_duration_between_years(date) == -730);\n    assert(Date::new(2020, 1, 1).get_duration_between_years(date) == -1096);\n    assert(Date::new(2019, 1, 1).get_duration_between_years(date) == -1461);\n    assert(Date::new(2018, 1, 1).get_duration_between_years(date) == -1826);\n    assert(Date::new(2017, 1, 1).get_duration_between_years(date) == -2191);\n    assert(Date::new(2016, 1, 1).get_duration_between_years(date) == -2557);\n    assert(Date::new(2015, 1, 1).get_duration_between_years(date) == -2922);\n    assert(Date::new(2014, 1, 1).get_duration_between_years(date) == -3287);\n    assert(Date::new(2013, 1, 1).get_duration_between_years(date) == -3652);\n    assert(Date::new(2012, 1, 1).get_duration_between_years(date) == -4018);\n}\n\n#[test]\nfn test_date_get_duration_in_days() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_in_days(date, false) == 0);\n    assert(Date::new(2023, 1, 15).get_duration_in_days(date, false) == 14);\n    assert(Date::new(2023, 2, 1).get_duration_in_days(date, false) == 31);\n    assert(Date::new(2023, 2, 15).get_duration_in_days(date, false) == 45);\n    assert(Date::new(2023, 3, 1).get_duration_in_days(date, false) == 59);\n    assert(Date::new(2023, 12, 31).get_duration_in_days(date, false) == 364);\n    assert(Date::new(2024, 1, 1).get_duration_in_days(date, false) == 365);\n    assert(Date::new(2024, 12, 31).get_duration_in_days(date, false) == 365 + 365);\n    assert(Date::new(2025, 1, 1).get_duration_in_days(date, false) == 365 + 366);\n}\n\n#[test]\nfn test_date_eq() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.eq(Date::new(2023, 1, 1)));\n    assert(!date.eq(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_ne() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.ne(Date::new(2023, 1, 1)));\n    assert(date.ne(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.gt(Date::new(2023, 1, 1)));\n    assert(!date.gt(Date::new(2023, 1, 2)));\n    assert(date.gt(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.lt(Date::new(2023, 1, 1)));\n    assert(!date.lt(Date::new(2022, 12, 31)));\n    assert(date.lt(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.gte(Date::new(2023, 1, 1)));\n    assert(!date.gte(Date::new(2023, 1, 2)));\n    assert(date.gte(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.lte(Date::new(2023, 1, 1)));\n    assert(!date.lte(Date::new(2022, 12, 31)));\n    assert(date.lte(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_add_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_years(1).eq(Date::new(2024, 7, 14)));\n    assert(date.add_years(2).eq(Date::new(2025, 7, 14)));\n    assert(date.add_years(3).eq(Date::new(2026, 7, 14)));\n    assert(date.add_years(4).eq(Date::new(2027, 7, 14)));\n    assert(date.add_years(5).eq(Date::new(2028, 7, 14)));\n}\n\n#[test]\nfn test_date_sub_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_years(1).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_years(2).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_years(3).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_years(4).eq(Date::new(2019, 7, 14)));\n    assert(date.sub_years(5).eq(Date::new(2018, 7, 14)));\n}\n\n#[test]\nfn test_date_add_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_months(1).eq(Date::new(2023, 8, 14)));\n    assert(date.add_months(2).eq(Date::new(2023, 9, 14)));\n\n    assert(date.add_months(6).eq(Date::new(2024, 1, 14)));\n    assert(date.add_months(7).eq(Date::new(2024, 2, 14)));\n    assert(date.add_months(8).eq(Date::new(2024, 3, 14)));\n\n    assert(date.add_months(17).eq(Date::new(2024, 12, 14)));\n    assert(date.add_months(18).eq(Date::new(2025, 1, 14)));\n\n    assert(date.add_months(29).eq(Date::new(2025, 12, 14)));\n    assert(date.add_months(30).eq(Date::new(2026, 1, 14)));\n}\n\n#[test]\nfn test_date_sub_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_months(1).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_months(2).eq(Date::new(2023, 5, 14)));\n\n    assert(date.sub_months(6).eq(Date::new(2023, 1, 14)));\n    assert(date.sub_months(7).eq(Date::new(2022, 12, 14)));\n    assert(date.sub_months(8).eq(Date::new(2022, 11, 14)));\n\n    assert(date.sub_months(17).eq(Date::new(2022, 2, 14)));\n    assert(date.sub_months(18).eq(Date::new(2022, 1, 14)));\n    assert(date.sub_months(19).eq(Date::new(2021, 12, 14)));\n\n    assert(date.sub_months(30).eq(Date::new(2021, 1, 14)));\n    assert(date.sub_months(31).eq(Date::new(2020, 12, 14)));\n\n    assert(date.sub_months(41).eq(Date::new(2020, 2, 14)));\n    assert(date.sub_months(42).eq(Date::new(2020, 1, 14)));\n    assert(date.sub_months(43).eq(Date::new(2019, 12, 14)));\n}\n\n#[test]\nfn test_date_add_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_days(1).eq(Date::new(2023, 7, 15)));\n    assert(date.add_days(2).eq(Date::new(2023, 7, 16)));\n\n    assert(date.add_days(17).eq(Date::new(2023, 7, 31)));\n    assert(date.add_days(18).eq(Date::new(2023, 8, 1)));\n    assert(date.add_days(19).eq(Date::new(2023, 8, 2)));\n\n    assert(date.add_days(31).eq(Date::new(2023, 8, 14)));\n    assert(date.add_days(32).eq(Date::new(2023, 8, 15)));\n    assert(date.add_days(33).eq(Date::new(2023, 8, 16)));\n\n    assert(date.add_days(365).eq(Date::new(2024, 7, 13)));\n    assert(date.add_days(366).eq(Date::new(2024, 7, 14)));\n    assert(date.add_days(367).eq(Date::new(2024, 7, 15)));\n\n    assert(date.add_days(365 + 365).eq(Date::new(2025, 7, 13)));\n    assert(date.add_days(365 + 366).eq(Date::new(2025, 7, 14)));\n    assert(date.add_days(365 + 367).eq(Date::new(2025, 7, 15)));\n\n    assert(date.add_days(365 + 366 + 364).eq(Date::new(2026, 7, 13)));\n    assert(date.add_days(365 + 366 + 365).eq(Date::new(2026, 7, 14)));\n    assert(date.add_days(365 + 366 + 366).eq(Date::new(2026, 7, 15)));\n\n    // After 4 regular years and 2 leap years\n    assert(date.add_days(365 * 4 + 366 * 2 - 1).eq(Date::new(2029, 7, 13)));\n    assert(date.add_days(365 * 4 + 366 * 2).eq(Date::new(2029, 7, 14)));\n    assert(date.add_days(365 * 4 + 366 * 2 + 1).eq(Date::new(2029, 7, 15)));\n}\n\n#[test]\nfn test_date_sub_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_days(1).eq(Date::new(2023, 7, 13)));\n    assert(date.sub_days(2).eq(Date::new(2023, 7, 12)));\n\n    assert(date.sub_days(17).eq(Date::new(2023, 6, 28)));\n    assert(date.sub_days(18).eq(Date::new(2023, 6, 27)));\n    assert(date.sub_days(19).eq(Date::new(2023, 6, 26)));\n\n    assert(date.sub_days(31).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_days(32).eq(Date::new(2023, 6, 13)));\n    assert(date.sub_days(33).eq(Date::new(2023, 6, 12)));\n\n    assert(date.sub_days(365).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_days(366).eq(Date::new(2022, 7, 13)));\n    assert(date.sub_days(367).eq(Date::new(2022, 7, 12)));\n\n    assert(date.sub_days(365 + 365).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_days(365 + 366).eq(Date::new(2021, 7, 13)));\n    assert(date.sub_days(365 + 367).eq(Date::new(2021, 7, 12)));\n\n    assert(date.sub_days(365 + 365 + 365).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_days(365 + 365 + 366).eq(Date::new(2020, 7, 13)));\n    assert(date.sub_days(365 + 365 + 367).eq(Date::new(2020, 7, 12)));\n\n    // After 5 regular years and 1 leap year\n    assert(date.sub_days(365 * 5 + 366 - 1).eq(Date::new(2017, 7, 15)));\n    assert(date.sub_days(365 * 5 + 366).eq(Date::new(2017, 7, 14)));\n    assert(date.sub_days(365 * 5 + 366 + 1).eq(Date::new(2017, 7, 13)));\n\n    // After 6 regular years and 2 leap years\n    assert(date.sub_days(365 * 6 + 366 * 2 - 1).eq(Date::new(2015, 7, 15)));\n    assert(date.sub_days(365 * 6 + 366 * 2).eq(Date::new(2015, 7, 14)));\n    assert(date.sub_days(365 * 6 + 366 * 2 + 1).eq(Date::new(2015, 7, 13)));\n}\n\n#[test]\nfn test_date_age() {\n    let birthdate = Date::new(1995, 4, 13);\n\n    // Add 18 years to the birthdate\n    // to get the date when the person is 18 years old\n    let majority_date = birthdate.add_years(18);\n\n    // Make sure the majority date is correct\n    assert(majority_date.eq(Date::new(2013, 4, 13)));\n\n    // Compare the majority date to the current date\n    // to see if the person is 18 years old\n    assert(majority_date.lte(Date::new(2023, 12, 20)));\n}\n","path":"/Users/ryan.cao/nargo/github.com/madztheo/noir-date.git/0.4.3/src/lib.nr"}},"names":["main"],"brillig_names":["decompose_hint","lte_hint","directive_integer_quotient","directive_invert"]}