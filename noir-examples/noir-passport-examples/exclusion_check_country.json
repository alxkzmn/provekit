{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":14411434554713602077,"abi":{"parameters":[{"name":"comm_in","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"private_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"country_list","type":{"kind":"array","length":200,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"public"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3dbuJIEIXfhWsuuqur//Iqq9WIJMwICUFEyEqrKO++JosNir1E1kmvpmbOTRQnXYfiM+7yJyR4XTyu719+fNvsvu+fF3d/vC62+4fVcbPfdUevC6np/Y/PT6vd6fj5uDocF3fZh+VivXvsfovxbbn4vtmuF3dJ3pajpd7lfF7rvUuXxWlicdUg58VVNV8Wx4nFOcnQRQrxevGfy67zbLbzYrbz+hN3rm7oPMqHzoNzZjv3ZjuX/7XzEGPfecjpduclhnReXKKmUefBbOdqtvNotvNktvNstvNitvNqtXPvzHbuzXZudoZ6szPUm52h3uwM9WZnqDc7Q73ZGerNzlAxO0PF7AwVszNUzM5QMTtDxewMFbMzVMzOUDE7Q8XsDA1mZ2gwO0OD2RkazM7QYHaGBrMzNJidoQGeoT7UvnMRue78Pb80zq9fmZ/cx3x1jfPhvV1D6fO1pFG+NM6H98nLe8c+qR/la+P82Dgf3hmyDvk5j18/uXF++cr8Ukb5tW1+dI3zfeN8aZwPX79Vhv2hahzla+N8+PqtPl7yR/tbTI3z81fmJx3ll8b5tW1+co3z0etXXOrvr8TVMMqXxvmhcb5+Yb73o/mYYuP81Dg/N84vjfPR61e6qTLkl9HrJ09ev922eq5RudxyyJTsiNT+/lm697VvL/bdezz9xd6pxyeLnfRddPoVby/Og5/Va4jTd/zFDXf813eEYRrfcHrkWvz0X3ye+BB8QnwIvkB8CD4lPgRfJD4EXyI+BF8mPgRfIT4EXyU+AF+hdUD4aB0QPloHhI/WAeFT4kPw0TogfLQOCB+tA8JH64Dw0ToQfJXWAeGjdUD4aB0QPloHhE+JD8FH64Dw0TogfLQOCB+tA8JH6wDwqaN1QPhoHRA+WgeEj9YB4VPiQ/DROiB8tA4IH60DwkfrgPDROhB8ntYB4aN1QPhoHRA+WgeET4kPwUfrgPDROiB8tA4IH60DwkfrQPAJrQPCR+uA8NE6IHy0DgifEh+Cj9YB4aN1QPhoHRA+WgeEj9aB4Au0DggfrQPCR+uA8NE6IHxKfAg+WgeEj9YB4aN1QPhoHRA+WgeCT2kdED5aB4SP1gHho3VA+JT4EHy0DggfrQPCR+uA8NE6IHy0DgRfpHVA+GgdED5aB4SP1gHhU+JD8NE6IHy0DggfrQPCR+uA8NE6EHyJ1gHho3VA+GgdED5aB4RPiQ/BR+uA8NE6IHy0DggfrQPCR+tA8PG7yTF8tA4IH60DwkfrgPAp8SH4aB0QPloHhI/WAeGjdUD4aB0IPn43OYaP1gHho3VA+GgdED4lPgQfrQPCR+uA8NE6IHy0DggfrQPBx+8mx/DROiB8tA4IH60DwqfEh+CjdUD4YOvIw5OUrJ8s9rmEvvPi5BfAl4kPwTdpHbOaSfU/mnnPr7/f6Qm+DDtUTbdPTxB/Xhtq+HByIv7V3b8rvO7g/rDZbjc/vm33D6vjZr97PhW60w+Z/tw7H7V/5Hh5QimdToVMf9bb7ZI6u2T6M71ul0xOX5+HU5l1VDL9XEoPXq5Ofl9SZ5dMf1LA7RI/v0Tml4T5JTq/JH5S4t2opMwvqbNLkptf4ueX6PySNK/krTv6a3XYrO6369PFffrny+6hv9a7w+PfT/1/+t3g6bB/WD++HNanfeGyJZxeEiJxKSF2rbx/eamkspQcToenpy/dHia5do/aPfI/","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use commitment::nullify;\nuse exclusion_check_country::check_country_exclusion;\n\nfn main(\n    comm_in: pub Field,\n    salt: Field,\n    private_nullifier: Field,\n    dg1: [u8; 95],\n    // There are roughly 200 countries in the world\n    // so we can safely pad it to 200\n    // The list must be sorted in ascending order\n    // For efficieny, no sorting is done in the circuit\n    // since the fact that the list is already sorted can checked\n    // by any verifier passing the public inputs to verify the proof\n    country_list: pub [u32; 200],\n    service_scope: pub Field,\n    service_subscope: pub Field,\n) -> pub Field {\n    // Check that nationality of the passport holder is not in the list of countries\n    check_country_exclusion(dg1, country_list);\n    let nullifier = nullify(\n        comm_in,\n        salt,\n        dg1,\n        private_nullifier,\n        service_scope,\n        service_subscope,\n    );\n    nullifier\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/bin/exclusion-check/country/src/main.nr"},"63":{"source":"use common::{calculate_scoped_nullifier, hash_salt_dg1_private_nullifier};\n\n/*\n############################################################\n# Circuit D\n############################################################\n# Generates a scoped nullifier that is scoped by service\n# Allows selective disclosure of dg1 via a reveal bitmask\n############################################################\n\n# Inputs/Outputs\n############################################################\ncomm_in             `assert comm_in == H(salt, dg1, private_nullifier)`\nsalt\ndg1\nprivate_nullifier\nservice_scope       `H(<domain_name>)`\nservice_subscope    `H(<purpose>)` (Service-specific subscope)\nscoped_nullifier    `H(private_nullifier, service_scope, service_subscope)`\n\n# Checks\n############################################################\n- Checks that dg1_reveal is the correct reveal of dg1 for the given dg1_mask\n- Constrains scoped_nullifier to be `H(private_nullifier, service_scope, service_subscope)`\n*/\npub fn nullify(\n    comm_in: Field,\n    salt: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    assert(comm_in == hash_salt_dg1_private_nullifier(salt, dg1, private_nullifier));\n    // println(f\"comm_in: {comm_in}\");\n    let scoped_nullifier =\n        calculate_scoped_nullifier(private_nullifier, service_scope, service_subscope);\n    // println(f\"scoped_nullifier: {scoped_nullifier}\");\n    scoped_nullifier\n}\n\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/commitment/scoped-nullifier/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n\n// Returns the merkle root of the tree from the provided leaf, index and hash_path, using the Poseidon2 hash function\n// Arity is expected to be 2 and the the tree depth is equal to the hash_path array length\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let index_bits: [u1; N] = index.to_le_bits();\n    let mut current = leaf;\n    for i in 0..N {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = Poseidon2::hash([hash_left, hash_right], 2);\n    }\n    current\n}\n\n#[test]\nfn test_compute_merkle_root1() {\n    let leaf = 0x2fe190f39de3fcf4cbc2eb334d0dc76e4d06f2350aa6056c91ff5f11ded9fb4a;\n    let index = 0;\n    let hash_path = [\n        0x00,\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1,\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290,\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20,\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e,\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf,\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76,\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b,\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1,\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972,\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686,\n        0x0f320b0703439a8114f81593de99cd0b8f3b9bf854601abb5b2ea0e8a3dda4a7,\n        0x0d07f6e7a8a0e9199d6d92801fff867002ff5b4808962f9da2ba5ce1bdd26a73,\n        0x1c4954081e324939350febc2b918a293ebcdaead01be95ec02fcbe8d2c1635d1\n    ];\n    let root = compute_merkle_root(leaf, index, hash_path);\n    assert(root == 0x0742857aba0058b2167c4ac94fede8ec480600911aa871153b988c3f71095449);\n}\n\n#[test]\nfn test_compute_merkle_root2() {\n    let e00 = Poseidon2::hash([1], 1);\n    let e01 = Poseidon2::hash([1], 1);\n    let e02 = Poseidon2::hash([1], 1);\n    let e03 = Poseidon2::hash([1], 1);\n    assert(e00 == 0x168758332d5b3e2d13be8048c8011b454590e06c44bce7f702f09103eef5a373);\n\n    let e10 = Poseidon2::hash([e00, e01], 2);\n    let e11 = Poseidon2::hash([e02, e03], 2);\n    assert(e10 == 0x113d8ff59c2e15d711241797c380264e39dc1b9e00f2713e707d8d7773b6d912);\n\n    let expected_root = Poseidon2::hash([e10, e11], 2);\n    assert(expected_root == 0x0f4f16b234c1d5054b15d408282cb45ba6c10a629fe068e7f3cc253ceae4f08d);\n\n    let hash_path = [e01, e10];\n    assert(hash_path == [\n        0x168758332d5b3e2d13be8048c8011b454590e06c44bce7f702f09103eef5a373,\n        0x113d8ff59c2e15d711241797c380264e39dc1b9e00f2713e707d8d7773b6d912\n    ]);\n\n    let leaf = Poseidon2::hash([1], 1);\n    let index = 0;\n    let root = compute_merkle_root(leaf, index, hash_path);\n    assert(root == 0x0f4f16b234c1d5054b15d408282cb45ba6c10a629fe068e7f3cc253ceae4f08d);\n}\n\npub fn get_vkey_hash<let N: u32>(vkey: [Field; N]) -> Field {\n    Poseidon2::hash(vkey, N)\n}\n\n#[test]\nfn test_get_vkey_hash() {\n    let vkey = [\n        0x0000000000000000000000000000000000000000000000000000000000004000,\n        0x000000000000000000000000000000000000000000000000000000000000001e,\n        0x0000000000000000000000000000000000000000000000000000000000000001,\n        0x0000000000000000000000000000000000000000000000000000000000000001,\n        0x000000000000000000000000000000000000000000000000000000000000000e,\n        0x000000000000000000000000000000000000000000000000000000000000000f,\n        0x0000000000000000000000000000000000000000000000000000000000000010,\n        0x0000000000000000000000000000000000000000000000000000000000000011,\n        0x0000000000000000000000000000000000000000000000000000000000000012,\n        0x0000000000000000000000000000000000000000000000000000000000000013,\n        0x0000000000000000000000000000000000000000000000000000000000000014,\n        0x0000000000000000000000000000000000000000000000000000000000000015,\n        0x0000000000000000000000000000000000000000000000000000000000000016,\n        0x0000000000000000000000000000000000000000000000000000000000000017,\n        0x0000000000000000000000000000000000000000000000000000000000000018,\n        0x0000000000000000000000000000000000000000000000000000000000000019,\n        0x000000000000000000000000000000000000000000000000000000000000001a,\n        0x000000000000000000000000000000000000000000000000000000000000001b,\n        0x000000000000000000000000000000000000000000000000000000000000001c,\n        0x000000000000000000000000000000000000000000000000000000000000001d,\n        0x000000000000000000000000000000014d18053025847e890b73d1bd851d8010,\n        0x00000000000000000000000000000000001604875484cd0af6333f892d9db03c,\n        0x0000000000000000000000000000001aa505665b96ff23e66c8cc50617d912dd,\n        0x000000000000000000000000000000000023761d0fc8b989dd96889c0e1dd500,\n        0x0000000000000000000000000000005ec6b7adcaad33a31d00c481cada512ff2,\n        0x00000000000000000000000000000000000619dc9f99c6e6318f58a3cd578e03,\n        0x000000000000000000000000000000ca65a4903d4105e8ffb945a804fe5e758b,\n        0x0000000000000000000000000000000000013d6fe1a9ccad8cf0da0cbb325a50,\n        0x000000000000000000000000000000c3d521df3cd944a41cc6c93814e4bfb108,\n        0x00000000000000000000000000000000002967d970e732ce06f745a1676e907a,\n        0x000000000000000000000000000000bea006927efee453f22d7e5001156d8236,\n        0x000000000000000000000000000000000003da37e3170387f7fc7fe67f3fd02d,\n        0x0000000000000000000000000000007ecadab7d0191e9b27b8c118bcf63e39d7,\n        0x00000000000000000000000000000000001aceee76600298bda7debc2a13e65f,\n        0x00000000000000000000000000000094109ace5115b62b817510419b345bafb3,\n        0x000000000000000000000000000000000007478caa1879b0d66eafb700c8eaff,\n        0x000000000000000000000000000000c66580c6bd58511b6f734408a36072b4cb,\n        0x000000000000000000000000000000000012a966c244f2d7aef31bf501d4c7b3,\n        0x00000000000000000000000000000066953254478df3e72cd967c81f9d7520dd,\n        0x000000000000000000000000000000000012836bbc2291cc1a76e191beeeff55,\n        0x00000000000000000000000000000085f16f224863af3a2eb1640916d6e2f661,\n        0x00000000000000000000000000000000001d2c4076e8dcb9be0e997d8c5715d9,\n        0x000000000000000000000000000000e7e736564c69478322d60bf28db04d2180,\n        0x000000000000000000000000000000000001bac3d335ee7aece9c8e8b83c4a0a,\n        0x000000000000000000000000000000418412d57fe3f9d88befaf72e3f049aed6,\n        0x00000000000000000000000000000000002640a81c852ebd44791d208778e3d4,\n        0x0000000000000000000000000000003f0de2660faefec496cddfcf172d70f88a,\n        0x000000000000000000000000000000000023f365597e5a0fe284fe40ba6df049,\n        0x0000000000000000000000000000001ff3fdb800a12685d0225869a709c59ea1,\n        0x000000000000000000000000000000000010485496ac517ce4626468b80c20d1,\n        0x000000000000000000000000000000eae802a6cf93d2041722bcc7b827850d9c,\n        0x00000000000000000000000000000000002c3eb537afd8670ec12382677e9dfd,\n        0x000000000000000000000000000000da72208a8ea7aa2e70b8fc00cf95fbe413,\n        0x00000000000000000000000000000000001994c139d6d63fbb02a95416dd2057,\n        0x0000000000000000000000000000000c243e99da3df894bd68564c1f2189c436,\n        0x000000000000000000000000000000000004714d9481f6dbd276728639c54996,\n        0x0000000000000000000000000000007ffd262875ae684deba001fcc5fdea3bbf,\n        0x000000000000000000000000000000000026c3846eed3340f6f2e861943f6f27,\n        0x0000000000000000000000000000009e45b69b687387629e72688f33382df553,\n        0x000000000000000000000000000000000017612f582a3500568851ebdcb62e72,\n        0x000000000000000000000000000000898a13479bd1c1e27a6e0681a5d43985af,\n        0x000000000000000000000000000000000002f9352d7ab76f7b9eda17515fd7b8,\n        0x0000000000000000000000000000003c13860bb6a8f804652839fa9abe19bb7b,\n        0x00000000000000000000000000000000000ea81714a4cd7294ac6300617eb610,\n        0x000000000000000000000000000000dc6620bff3175f56800f1e44c3e79b256e,\n        0x000000000000000000000000000000000003c53e0fb2f68008220ac57a71c7f4,\n        0x000000000000000000000000000000ab9926a5dd872d669530c99c7d9be65720,\n        0x00000000000000000000000000000000002ea70327e45061f95597e2ccf26540,\n        0x00000000000000000000000000000032d9d845b89a70f07980c48344f7a599e6,\n        0x000000000000000000000000000000000020828423a9331f84edb915eeb4733d,\n        0x000000000000000000000000000000f020304aa06e327c9294f1254859db8ab6,\n        0x00000000000000000000000000000000001f5964632befb3e8707483b77e7881,\n        0x0000000000000000000000000000004d882ed48ddc17fda49a2e3c07bfa0b4a7,\n        0x0000000000000000000000000000000000238a9bda3f2d414f43b6d68db016da,\n        0x000000000000000000000000000000871bf5d454ed7a84525d3d52325dfb377c,\n        0x000000000000000000000000000000000007584c1032621909192d308449ced1,\n        0x0000000000000000000000000000005b72000fb18ad1bd936839038a2bc2b9e5,\n        0x0000000000000000000000000000000000268cfce53a1c077c835540eb73a23c,\n        0x00000000000000000000000000000000c747ae5e9a310b1d8baa8c34f92e8d0e,\n        0x00000000000000000000000000000000002701e27eec246967ec650bbe990bab,\n        0x000000000000000000000000000000a6783a604d35e125327e5fe8cf22398fdd,\n        0x00000000000000000000000000000000002309c7ceac11535749dab8c9f4d851,\n        0x00000000000000000000000000000065720cd086bae46f673f548239ceafb0b4,\n        0x00000000000000000000000000000000000a8ac00f8a2042f8f81c554dc404f6,\n        0x000000000000000000000000000000907c095579b757be6b50e41dc3692a224c,\n        0x00000000000000000000000000000000000a45377f92a8d6d44afe54e3717f8a,\n        0x000000000000000000000000000000d8642735ec11ef526dcffa791f1ad641ab,\n        0x00000000000000000000000000000000001e4fbc154b0c6b4c559f58a7d19ac0,\n        0x000000000000000000000000000000eff01a355a79835cc29ccf88cd9e3ca07f,\n        0x00000000000000000000000000000000002af5e29ca00459725e2680c6a78a6f,\n        0x000000000000000000000000000000da6c16f1483ae4228c68cc091f40d39aad,\n        0x00000000000000000000000000000000000ea734a85cf7a6d1d775a08afc61e0,\n        0x000000000000000000000000000000fd722ec69b8a01085785be11e41f873afe,\n        0x000000000000000000000000000000000006b8a63c9cf273d4724fbb10d5f57a,\n        0x000000000000000000000000000000f7d9fd5e858349061430d351c45499dfad,\n        0x0000000000000000000000000000000000046edaae51ba84f2dabcd56e9eed5b,\n        0x0000000000000000000000000000002f225a95524043ea68cc704f77ef4f6045,\n        0x0000000000000000000000000000000000038d07b151361621e074699b374a85,\n        0x000000000000000000000000000000da6a36c7ae48c4791868c3d10c8533fe6e,\n        0x000000000000000000000000000000000014ce118be5ef951902f6e84a561e88,\n        0x000000000000000000000000000000beabc4f9b42059a77a1b15b98856b48453,\n        0x00000000000000000000000000000000002114644c4953246a959f25a4bf2052,\n        0x0000000000000000000000000000009d10f2f38322da8ecb0b296bc729ff1c4e,\n        0x000000000000000000000000000000000027f1245b7ec2b0cb360bb134218ed1,\n        0x00000000000000000000000000000032957a466beb19e0675e0f739616187ecd,\n        0x0000000000000000000000000000000000235e20011670e41d045fd8446ae100,\n        0x000000000000000000000000000000691d28ce28c9ae3f7e8d3220cbfdb0fd36,\n        0x000000000000000000000000000000000004d8e62001cadc95344edcfd429fed,\n        0x0000000000000000000000000000008a34b9ab23bd2cd471701a5a76de4076b8,\n        0x00000000000000000000000000000000002c853787226778520baf3c5f0ed65e,\n        0x000000000000000000000000000000f357d89b0302e34eac204bc55974f0c37b,\n        0x00000000000000000000000000000000001a04dfa8543c150c4f07b768f1752d,\n        0x000000000000000000000000000000709f2727a8adda78f9cd125c85fc061557,\n        0x0000000000000000000000000000000000180b5e9b2901b08360c598f18581d0,\n        0x0000000000000000000000000000003f99f9fd98707c98fd62328a676c38bb38,\n        0x000000000000000000000000000000000004880ff78661543813929232e5c4db,\n        0x0000000000000000000000000000003fb3d6fdb1fe407fc26479a67309987378,\n        0x0000000000000000000000000000000000152830347b8e35a842ea020f557635,\n        0x0000000000000000000000000000004aed3df71695a6a5295e2117cc6c0a80df,\n        0x0000000000000000000000000000000000007ee2c78519eb92faa04d10b2ae9e,\n        0x0000000000000000000000000000000000000000000000000000000000000001,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x0000000000000000000000000000000000000000000000000000000000000002,\n        0x0000000000000000000000000000000000000000000000000000000000000000,\n        0x000000000000000000000000000000feb33855ac28e08d8b02991fb3f3c211cf,\n        0x000000000000000000000000000000000007d8476506cdef23b023ca072ed709,\n        0x000000000000000000000000000000e985e0b015edca55f69192bdb7139b7224,\n        0x000000000000000000000000000000000020470f3258600e780b46d6c7db1bc6\n    ];\n    let vkey_hash = get_vkey_hash(vkey);\n    assert(vkey_hash == 0x159c7f9777839c2449c0a0f90b411569ed72aaa9d090c82c9c028adf5419d3d6);\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/commitment/common/src/lib.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(15 - (N * 15 - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\npub unconstrained fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/utils/src/lib.nr"},"66":{"source":"use utils::get_nationality_from_mrz;\n\nunconstrained fn get_closest_index<let N: u32>(sorted_list: [u32; N], value: u32) -> u32 {\n    let mut index: u32 = 0;\n    for i in 0..N {\n        if sorted_list[i] > value {\n            index = i;\n            break;\n        }\n    }\n    index\n}\n\n/// Check if the nationality from the MRZ is not in the country list\n/// The list of countries is assumed to be sorted in ascending order\n/// So it must come either from a public input that can be independently checked\n/// or from a previous in-circuit check that the list is sorted\n///\n/// # Arguments\n///\n/// * `dg1` - The DG1 of the passport or ID card\n/// * `country_list` - The sorted list of countries to check against, must be formatted as a list of u32\n/// which are the Alpha-3 codes of the countries with each letter ASCII code put together using a weighted sum.\n/// e.g. for \"FRA\", the sum is 70 * 2^16 (0x10000) + 82 * 2^8 (0x100) + 65 = 4587520 + 20992 + 65 = 4608577\npub fn check_country_exclusion<let N: u32>(dg1: [u8; 95], country_list: [u32; N]) {\n    let nationality_bytes = get_nationality_from_mrz(dg1);\n    let nationality_sum: u32 = nationality_bytes[0] as u32 * 0x10000\n        + nationality_bytes[1] as u32 * 0x100\n        + nationality_bytes[2] as u32;\n\n    // Since the list is assumed to be sorted in ascending order, we can get the index to check against\n    // from an unconstrained function\n    let closest_index = unsafe { get_closest_index(country_list, nationality_sum) };\n    // Assert that either the index is the first element of the list or the previous element is less than the nationality sum\n    if closest_index == 0 {\n        // Assert that the country at the index is greater than the nationality sum\n        assert(country_list[closest_index] > nationality_sum);\n    }\n    // Cannot be done in a single if statement otherwise the second check will fail if closest_index is 0\n    else if country_list[closest_index - 1] < nationality_sum {\n        // Assert that the country at the index is greater than the nationality sum\n        assert(country_list[closest_index] > nationality_sum);\n    } else {\n        // Otherwise it should fail\n        assert(false);\n    }\n    // If those two checks pass, then the nationality is not in the country list\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/exclusion-check/country/src/lib.nr"}},"names":["main"],"brillig_names":["get_closest_index","directive_invert","directive_integer_quotient"]}