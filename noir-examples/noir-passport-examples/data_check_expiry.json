{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":13230741840915955453,"abi":{"parameters":[{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"current_date","type":{"kind":"string","length":8},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(15 - (N * 15 - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\npub unconstrained fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/utils/src/lib.nr"},"69":{"source":"use dep::std::{field::bn254::assert_gt, println};\n\npub struct Date {\n    day: u8,\n    month: u8,\n    year: u32,\n}\n\nfn get_number_from_utf8_code(code: u8) -> u8 {\n    assert(code >= 48 & code <= 57);\n    code - 48\n}\n\nfn number_to_utf8_code(number: u8) -> u8 {\n    assert(number >= 0 & number <= 9);\n    number + 48\n}\n\nimpl Date {\n    pub fn new(year: u32, month: u8, day: u8) -> Self {\n        assert(month >= 1 & month <= 12);\n        assert(day >= 1 & day <= 31);\n        let date = Self { day: day, month: month, year: year };\n        assert(day <= date.get_days_in_month(month));\n        date\n    }\n\n    pub fn from_bytes_short_year(date: [u8; 6], threshold_year: [u8; 2]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n\n        let mut year: u32 = firstYearDigit as u32 * 10 + secondYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[2]);\n        let secondMonthDigit = get_number_from_utf8_code(date[3]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[4]);\n        let secondDayDigit = get_number_from_utf8_code(date[5]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        let currentYearFirstDigit = get_number_from_utf8_code(threshold_year[0]);\n        let currentYearSecondDigit = get_number_from_utf8_code(threshold_year[1]);\n\n        let mut currentYear: u32 =\n            currentYearFirstDigit as u32 * 10 + currentYearSecondDigit as u32;\n\n        // This way we have a smooth 100 years period according to a threshold year\n        // Taking the current year as threshold year (for birthdates for example)\n        // if the current year is 2023, then 24 will be interpreted as 1924\n        // while 22 will be interpreted as 2022\n        // A bit problematic for people over 100 years old\n        if year <= currentYear {\n            year += 2000;\n        } else {\n            year += 1900;\n        }\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_bytes_long_year(date: [u8; 8]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n        let thirdYearDigit = get_number_from_utf8_code(date[2]);\n        let fourthYearDigit = get_number_from_utf8_code(date[3]);\n\n        let year: u32 = firstYearDigit as u32 * 1000\n            + secondYearDigit as u32 * 100\n            + thirdYearDigit as u32 * 10\n            + fourthYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[4]);\n        let secondMonthDigit = get_number_from_utf8_code(date[5]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[6]);\n        let secondDayDigit = get_number_from_utf8_code(date[7]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_str_short_year(date: str<6>, threshold_year: str<2>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_short_year(date_bytes, threshold_year.as_bytes())\n    }\n\n    pub fn from_str_long_year(date: str<8>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_long_year(date_bytes)\n    }\n\n    pub fn get_duration_in_days(self: Self, other: Self, absolute: bool) -> i32 {\n        let totalDuration: i32 = self.get_duration_between_years(other) as i32\n            + self.get_duration_between_months(other) as i32\n            + (self.day as i32 - other.day as i32);\n\n        if (totalDuration < 0) & absolute {\n            -1 * totalDuration\n        }\n\n        totalDuration\n    }\n\n    pub fn gt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) > 0\n    }\n\n    pub fn lt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) < 0\n    }\n\n    pub fn eq(self: Self, other: Self) -> bool {\n        (self.day == other.day) & (self.month == other.month) & (self.year == other.year)\n    }\n\n    pub fn ne(self: Self, other: Self) -> bool {\n        !self.eq(other)\n    }\n\n    pub fn gte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) >= 0\n    }\n\n    pub fn lte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) <= 0\n    }\n\n    pub fn println(self: Self) {\n        let year = self.year;\n        let month = self.month;\n        let day = self.day;\n        // Let's write the date in the YYYY-MM-DD format\n        // since people don't agree on which format is best\n        // between MM/DD/YYYY and DD/MM/YYYY\n        if (month < 10) & (day < 10) {\n            println(f\"Date: {year}-0{month}-0{day}\");\n        } else if month < 10 {\n            println(f\"Date: {year}-0{month}-{day}\");\n        } else if day < 10 {\n            println(f\"Date: {year}-{month}-0{day}\");\n        } else {\n            println(f\"Date: {year}-{month}-{day}\");\n        }\n    }\n\n    pub fn to_bytes(self: Self) -> [u8; 8] {\n        let mut date: [u8; 8] = [0; 8];\n\n        let firstYearDigit = self.year / 1000;\n        let secondYearDigit = (self.year - firstYearDigit * 1000) / 100;\n        let thirdYearDigit = (self.year - firstYearDigit * 1000 - secondYearDigit * 100) / 10;\n        let fourthYearDigit =\n            self.year - firstYearDigit * 1000 - secondYearDigit * 100 - thirdYearDigit * 10;\n\n        date[0] = number_to_utf8_code(firstYearDigit as u8);\n        date[1] = number_to_utf8_code(secondYearDigit as u8);\n        date[2] = number_to_utf8_code(thirdYearDigit as u8);\n        date[3] = number_to_utf8_code(fourthYearDigit as u8);\n\n        let firstMonthDigit = self.month / 10;\n        let secondMonthDigit = self.month - firstMonthDigit * 10;\n\n        date[4] = number_to_utf8_code(firstMonthDigit as u8);\n        date[5] = number_to_utf8_code(secondMonthDigit as u8);\n\n        let firstDayDigit = self.day / 10;\n        let secondDayDigit = self.day - firstDayDigit * 10;\n\n        date[6] = number_to_utf8_code(firstDayDigit as u8);\n        date[7] = number_to_utf8_code(secondDayDigit as u8);\n\n        date\n    }\n\n    pub fn is_leap_year(self: Self) -> bool {\n        self.year % 4 == 0\n    }\n\n    pub fn get_days_in_month(self: Self, month: u8) -> u8 {\n        assert(month >= 1 & month <= 12);\n        if month == 2 {\n            if self.is_leap_year() {\n                29\n            } else {\n                28\n            }\n        } else {\n            if (month == 1)\n                | (month == 3)\n                | (month == 5)\n                | (month == 7)\n                | (month == 8)\n                | (month == 10)\n                | (month == 12) {\n                31\n            } else {\n                30\n            }\n        }\n    }\n\n    pub fn get_duration_between_months(self: Self, other: Self) -> i32 {\n        assert(self.month >= 1 & self.month <= 12);\n        assert(other.month >= 1 & other.month <= 12);\n        let mut duration: i32 = 0;\n        if (self.month < other.month) {\n            for month in 1..13 {\n                if month >= self.month & month < other.month {\n                    duration -= other.get_days_in_month(month) as i32;\n                }\n            }\n        } else {\n            for month in 1..13 {\n                if month >= other.month & month < self.month {\n                    duration += self.get_days_in_month(month) as i32;\n                }\n            }\n        }\n        duration\n    }\n\n    pub fn get_duration_between_years(self: Self, other: Self) -> i32 {\n        let mut duration: i32 = 0;\n        if (self.year < other.year) {\n            let previous_leap_year: u32 = other.year - (other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year <= previous_leap_year {\n                leap_year_count = (previous_leap_year - self.year) / 4 + 1;\n            }\n            duration -= leap_year_count as i32 * 366;\n            duration -=\n                (other.year as i32 - self.year as i32 - leap_year_count as i32) as i32 * 365;\n        } else if (self.year > other.year) {\n            let next_leap_year: u32 = other.year + (4 - other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year > next_leap_year {\n                // Fixes a weird bug where the line below triggers a fail constraint\n                // while self.year is greater than next_leap_year\n                assert_gt(self.year as Field, next_leap_year as Field);\n                leap_year_count = ((self.year - 1) - next_leap_year) / 4 + 1;\n            }\n            duration += leap_year_count as i32 * 366;\n            duration +=\n                (self.year as i32 - other.year as i32 - leap_year_count as i32) as i32 * 365;\n        }\n        duration\n    }\n\n    pub fn add_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year + years }\n    }\n\n    pub fn sub_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year - years }\n    }\n\n    pub fn add_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as u32 + months;\n        let mut newYear = self.year;\n        let yearToAdd = (newMonth - 1) / 12;\n        if newMonth > 12 {\n            newYear += yearToAdd as u32;\n            newMonth -= 12 * yearToAdd;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn sub_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as i32 - months as i32;\n        let mut newYear = self.year;\n        if newMonth < 1 {\n            let yearToSub = ((newMonth as i32 - 12 as i32) * -1) / 12;\n            newYear -= yearToSub as u32;\n            newMonth += 12 * yearToSub;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn add_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as u32 + days;\n        let mut newMonth = self.month as u32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay > self.get_days_in_month(self.month) as u32 {\n            let max_months = (newDay / 30) + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as u32;\n                if newDay > days_in_month {\n                    newDay -= days_in_month;\n                    newMonth += 1;\n                    if newMonth > 12 {\n                        newYear += 1;\n                        newMonth = 1;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n\n    // Performance could be improved\n    pub fn sub_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as i32 - days as i32;\n        let mut newMonth = self.month as i32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay < 1 {\n            let max_months = (self.day as u32 + days) / 30 + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as i32;\n                if newDay < 1 {\n                    newDay += days_in_month;\n                    newMonth -= 1;\n                    if newMonth < 1 {\n                        newYear -= 1;\n                        newMonth = 12;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n}\n\n#[test]\nfn test_date_init() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_short_year() {\n    let date = Date::from_bytes_short_year([50, 51, 49, 50, 49, 57], [50, 52]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_long_year() {\n    let date = Date::from_bytes_long_year([50, 48, 50, 51, 49, 50, 49, 57]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_short_year() {\n    let date = Date::from_str_short_year(\"231219\", \"24\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_long_year() {\n    let date = Date::from_str_long_year(\"20231219\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_to_bytes() {\n    let date = Date::new(2023, 12, 19);\n\n    let date_bytes = date.to_bytes();\n\n    assert(date_bytes[0] == 50);\n    assert(date_bytes[1] == 48);\n    assert(date_bytes[2] == 50);\n    assert(date_bytes[3] == 51);\n    assert(date_bytes[4] == 49);\n    assert(date_bytes[5] == 50);\n    assert(date_bytes[6] == 49);\n    assert(date_bytes[7] == 57);\n}\n\n#[test]\nfn test_date_is_leap_year() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.is_leap_year() == false);\n\n    let date = Date::new(2024, 12, 19);\n\n    assert(date.is_leap_year() == true);\n}\n\n#[test]\nfn test_date_get_days_in_month() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 28);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n\n    let date = Date::new(2024, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 29);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n}\n\n#[test]\nfn test_date_get_duration_between_months() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_between_months(date) == 0);\n    assert(Date::new(2023, 2, 1).get_duration_between_months(date) == 31);\n    assert(Date::new(2023, 3, 1).get_duration_between_months(date) == 59);\n    assert(Date::new(2023, 4, 1).get_duration_between_months(date) == 90);\n    assert(Date::new(2023, 5, 1).get_duration_between_months(date) == 120);\n    assert(Date::new(2023, 6, 1).get_duration_between_months(date) == 151);\n    assert(Date::new(2023, 7, 1).get_duration_between_months(date) == 181);\n    assert(Date::new(2023, 8, 1).get_duration_between_months(date) == 212);\n    assert(Date::new(2023, 9, 1).get_duration_between_months(date) == 243);\n    assert(Date::new(2023, 10, 1).get_duration_between_months(date) == 273);\n    assert(Date::new(2023, 11, 1).get_duration_between_months(date) == 304);\n    assert(Date::new(2023, 12, 1).get_duration_between_months(date) == 334);\n}\n\n#[test]\nfn test_date_get_duration_between_years() {\n    let date = Date::new(2023, 1, 1);\n\n    // Positive duration\n    assert(Date::new(2023, 1, 1).get_duration_between_years(date) == 0);\n    assert(Date::new(2024, 1, 1).get_duration_between_years(date) == 365);\n    assert(Date::new(2025, 1, 1).get_duration_between_years(date) == 731);\n    assert(Date::new(2026, 1, 1).get_duration_between_years(date) == 1096);\n    assert(Date::new(2027, 1, 1).get_duration_between_years(date) == 1461);\n    assert(Date::new(2028, 1, 1).get_duration_between_years(date) == 1826);\n    assert(Date::new(2029, 1, 1).get_duration_between_years(date) == 2192);\n    assert(Date::new(2030, 1, 1).get_duration_between_years(date) == 2557);\n    assert(Date::new(2031, 1, 1).get_duration_between_years(date) == 2922);\n    assert(Date::new(2032, 1, 1).get_duration_between_years(date) == 3287);\n    assert(Date::new(2033, 1, 1).get_duration_between_years(date) == 3653);\n    assert(Date::new(2034, 1, 1).get_duration_between_years(date) == 4018);\n\n    // Negative duration\n    assert(Date::new(2022, 1, 1).get_duration_between_years(date) == -365);\n    assert(Date::new(2021, 1, 1).get_duration_between_years(date) == -730);\n    assert(Date::new(2020, 1, 1).get_duration_between_years(date) == -1096);\n    assert(Date::new(2019, 1, 1).get_duration_between_years(date) == -1461);\n    assert(Date::new(2018, 1, 1).get_duration_between_years(date) == -1826);\n    assert(Date::new(2017, 1, 1).get_duration_between_years(date) == -2191);\n    assert(Date::new(2016, 1, 1).get_duration_between_years(date) == -2557);\n    assert(Date::new(2015, 1, 1).get_duration_between_years(date) == -2922);\n    assert(Date::new(2014, 1, 1).get_duration_between_years(date) == -3287);\n    assert(Date::new(2013, 1, 1).get_duration_between_years(date) == -3652);\n    assert(Date::new(2012, 1, 1).get_duration_between_years(date) == -4018);\n}\n\n#[test]\nfn test_date_get_duration_in_days() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_in_days(date, false) == 0);\n    assert(Date::new(2023, 1, 15).get_duration_in_days(date, false) == 14);\n    assert(Date::new(2023, 2, 1).get_duration_in_days(date, false) == 31);\n    assert(Date::new(2023, 2, 15).get_duration_in_days(date, false) == 45);\n    assert(Date::new(2023, 3, 1).get_duration_in_days(date, false) == 59);\n    assert(Date::new(2023, 12, 31).get_duration_in_days(date, false) == 364);\n    assert(Date::new(2024, 1, 1).get_duration_in_days(date, false) == 365);\n    assert(Date::new(2024, 12, 31).get_duration_in_days(date, false) == 365 + 365);\n    assert(Date::new(2025, 1, 1).get_duration_in_days(date, false) == 365 + 366);\n}\n\n#[test]\nfn test_date_eq() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.eq(Date::new(2023, 1, 1)));\n    assert(!date.eq(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_ne() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.ne(Date::new(2023, 1, 1)));\n    assert(date.ne(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.gt(Date::new(2023, 1, 1)));\n    assert(!date.gt(Date::new(2023, 1, 2)));\n    assert(date.gt(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.lt(Date::new(2023, 1, 1)));\n    assert(!date.lt(Date::new(2022, 12, 31)));\n    assert(date.lt(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.gte(Date::new(2023, 1, 1)));\n    assert(!date.gte(Date::new(2023, 1, 2)));\n    assert(date.gte(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.lte(Date::new(2023, 1, 1)));\n    assert(!date.lte(Date::new(2022, 12, 31)));\n    assert(date.lte(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_add_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_years(1).eq(Date::new(2024, 7, 14)));\n    assert(date.add_years(2).eq(Date::new(2025, 7, 14)));\n    assert(date.add_years(3).eq(Date::new(2026, 7, 14)));\n    assert(date.add_years(4).eq(Date::new(2027, 7, 14)));\n    assert(date.add_years(5).eq(Date::new(2028, 7, 14)));\n}\n\n#[test]\nfn test_date_sub_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_years(1).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_years(2).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_years(3).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_years(4).eq(Date::new(2019, 7, 14)));\n    assert(date.sub_years(5).eq(Date::new(2018, 7, 14)));\n}\n\n#[test]\nfn test_date_add_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_months(1).eq(Date::new(2023, 8, 14)));\n    assert(date.add_months(2).eq(Date::new(2023, 9, 14)));\n\n    assert(date.add_months(6).eq(Date::new(2024, 1, 14)));\n    assert(date.add_months(7).eq(Date::new(2024, 2, 14)));\n    assert(date.add_months(8).eq(Date::new(2024, 3, 14)));\n\n    assert(date.add_months(17).eq(Date::new(2024, 12, 14)));\n    assert(date.add_months(18).eq(Date::new(2025, 1, 14)));\n\n    assert(date.add_months(29).eq(Date::new(2025, 12, 14)));\n    assert(date.add_months(30).eq(Date::new(2026, 1, 14)));\n}\n\n#[test]\nfn test_date_sub_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_months(1).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_months(2).eq(Date::new(2023, 5, 14)));\n\n    assert(date.sub_months(6).eq(Date::new(2023, 1, 14)));\n    assert(date.sub_months(7).eq(Date::new(2022, 12, 14)));\n    assert(date.sub_months(8).eq(Date::new(2022, 11, 14)));\n\n    assert(date.sub_months(17).eq(Date::new(2022, 2, 14)));\n    assert(date.sub_months(18).eq(Date::new(2022, 1, 14)));\n    assert(date.sub_months(19).eq(Date::new(2021, 12, 14)));\n\n    assert(date.sub_months(30).eq(Date::new(2021, 1, 14)));\n    assert(date.sub_months(31).eq(Date::new(2020, 12, 14)));\n\n    assert(date.sub_months(41).eq(Date::new(2020, 2, 14)));\n    assert(date.sub_months(42).eq(Date::new(2020, 1, 14)));\n    assert(date.sub_months(43).eq(Date::new(2019, 12, 14)));\n}\n\n#[test]\nfn test_date_add_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_days(1).eq(Date::new(2023, 7, 15)));\n    assert(date.add_days(2).eq(Date::new(2023, 7, 16)));\n\n    assert(date.add_days(17).eq(Date::new(2023, 7, 31)));\n    assert(date.add_days(18).eq(Date::new(2023, 8, 1)));\n    assert(date.add_days(19).eq(Date::new(2023, 8, 2)));\n\n    assert(date.add_days(31).eq(Date::new(2023, 8, 14)));\n    assert(date.add_days(32).eq(Date::new(2023, 8, 15)));\n    assert(date.add_days(33).eq(Date::new(2023, 8, 16)));\n\n    assert(date.add_days(365).eq(Date::new(2024, 7, 13)));\n    assert(date.add_days(366).eq(Date::new(2024, 7, 14)));\n    assert(date.add_days(367).eq(Date::new(2024, 7, 15)));\n\n    assert(date.add_days(365 + 365).eq(Date::new(2025, 7, 13)));\n    assert(date.add_days(365 + 366).eq(Date::new(2025, 7, 14)));\n    assert(date.add_days(365 + 367).eq(Date::new(2025, 7, 15)));\n\n    assert(date.add_days(365 + 366 + 364).eq(Date::new(2026, 7, 13)));\n    assert(date.add_days(365 + 366 + 365).eq(Date::new(2026, 7, 14)));\n    assert(date.add_days(365 + 366 + 366).eq(Date::new(2026, 7, 15)));\n\n    // After 4 regular years and 2 leap years\n    assert(date.add_days(365 * 4 + 366 * 2 - 1).eq(Date::new(2029, 7, 13)));\n    assert(date.add_days(365 * 4 + 366 * 2).eq(Date::new(2029, 7, 14)));\n    assert(date.add_days(365 * 4 + 366 * 2 + 1).eq(Date::new(2029, 7, 15)));\n}\n\n#[test]\nfn test_date_sub_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_days(1).eq(Date::new(2023, 7, 13)));\n    assert(date.sub_days(2).eq(Date::new(2023, 7, 12)));\n\n    assert(date.sub_days(17).eq(Date::new(2023, 6, 28)));\n    assert(date.sub_days(18).eq(Date::new(2023, 6, 27)));\n    assert(date.sub_days(19).eq(Date::new(2023, 6, 26)));\n\n    assert(date.sub_days(31).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_days(32).eq(Date::new(2023, 6, 13)));\n    assert(date.sub_days(33).eq(Date::new(2023, 6, 12)));\n\n    assert(date.sub_days(365).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_days(366).eq(Date::new(2022, 7, 13)));\n    assert(date.sub_days(367).eq(Date::new(2022, 7, 12)));\n\n    assert(date.sub_days(365 + 365).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_days(365 + 366).eq(Date::new(2021, 7, 13)));\n    assert(date.sub_days(365 + 367).eq(Date::new(2021, 7, 12)));\n\n    assert(date.sub_days(365 + 365 + 365).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_days(365 + 365 + 366).eq(Date::new(2020, 7, 13)));\n    assert(date.sub_days(365 + 365 + 367).eq(Date::new(2020, 7, 12)));\n\n    // After 5 regular years and 1 leap year\n    assert(date.sub_days(365 * 5 + 366 - 1).eq(Date::new(2017, 7, 15)));\n    assert(date.sub_days(365 * 5 + 366).eq(Date::new(2017, 7, 14)));\n    assert(date.sub_days(365 * 5 + 366 + 1).eq(Date::new(2017, 7, 13)));\n\n    // After 6 regular years and 2 leap years\n    assert(date.sub_days(365 * 6 + 366 * 2 - 1).eq(Date::new(2015, 7, 15)));\n    assert(date.sub_days(365 * 6 + 366 * 2).eq(Date::new(2015, 7, 14)));\n    assert(date.sub_days(365 * 6 + 366 * 2 + 1).eq(Date::new(2015, 7, 13)));\n}\n\n#[test]\nfn test_date_age() {\n    let birthdate = Date::new(1995, 4, 13);\n\n    // Add 18 years to the birthdate\n    // to get the date when the person is 18 years old\n    let majority_date = birthdate.add_years(18);\n\n    // Make sure the majority date is correct\n    assert(majority_date.eq(Date::new(2013, 4, 13)));\n\n    // Compare the majority date to the current date\n    // to see if the person is 18 years old\n    assert(majority_date.lte(Date::new(2023, 12, 20)));\n}\n","path":"/Users/ryan.cao/nargo/github.com/madztheo/noir-date.git/0.4.3/src/lib.nr"},"77":{"source":"use data_check_expiry::check_expiry;\n\nfn main(dg1: [u8; 95], current_date: pub str<8>) {\n    // Check the ID is not expired first\n    check_expiry(dg1, current_date.as_bytes());\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/bin/data-check/expiry/src/main.nr"},"78":{"source":"use date::Date;\nuse utils::{\n    get_array_slice, get_mrz_from_dg1, ID_CARD_MRZ_EXPIRY_DATE_INDEX, is_id_card,\n    PASSPORT_MRZ_EXPIRY_DATE_INDEX,\n};\n\npub fn check_expiry(dg1: [u8; 95], current_date_bytes: [u8; 8]) {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    // We base the threshold year for the expiry date on the current date plus 20 years\n    // As most documents will have a 10 year validity (and some maybe 15 years?)\n    // So with 20 years we should be safe\n    let threshold_year = Date::from_bytes_long_year(current_date_bytes).add_years(20);\n    let threshold_year_bytes = threshold_year.to_bytes();\n\n    let current_date = Date::from_bytes_long_year(current_date_bytes);\n\n    let mut expiry_date_bytes = [0 as u8; 6];\n\n    if is_id_card(dg1) {\n        expiry_date_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_EXPIRY_DATE_INDEX,\n            ID_CARD_MRZ_EXPIRY_DATE_INDEX + 6,\n        );\n    } else {\n        expiry_date_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_EXPIRY_DATE_INDEX,\n            PASSPORT_MRZ_EXPIRY_DATE_INDEX + 6,\n        );\n    }\n\n    let expiry_date = Date::from_bytes_short_year(\n        expiry_date_bytes,\n        [threshold_year_bytes[2], threshold_year_bytes[3]],\n    );\n\n    assert(current_date.lt(expiry_date));\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/lib/data-check/expiry/src/lib.nr"}},"names":["main"],"brillig_names":["decompose_hint","lte_hint","directive_integer_quotient","directive_invert"]}