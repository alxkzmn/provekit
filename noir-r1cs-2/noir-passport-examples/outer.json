{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":4444353091139366266,"abi":{"parameters":[{"name":"circuit_registry_root","type":{"kind":"field"},"visibility":"private"},{"name":"certificate_registry_root","type":{"kind":"field"},"visibility":"private"},{"name":"current_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"dg1_mask","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"dg1_reveal","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"},{"name":"scoped_nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"proof_a","type":{"kind":"struct","path":"SubCircuitA","fields":[{"name":"vkey","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"proof","type":{"kind":"array","length":439,"type":{"kind":"field"}}},{"name":"key_hash","type":{"kind":"field"}},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}}},{"name":"tree_hash_path","type":{"kind":"array","length":12,"type":{"kind":"field"}}},{"name":"tree_index","type":{"kind":"field"}}]},"visibility":"private"},{"name":"proof_b","type":{"kind":"struct","path":"SubCircuitB","fields":[{"name":"vkey","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"proof","type":{"kind":"array","length":439,"type":{"kind":"field"}}},{"name":"public_inputs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"key_hash","type":{"kind":"field"}},{"name":"tree_hash_path","type":{"kind":"array","length":12,"type":{"kind":"field"}}},{"name":"tree_index","type":{"kind":"field"}}]},"visibility":"private"},{"name":"proof_c","type":{"kind":"struct","path":"SubCircuitC","fields":[{"name":"vkey","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"proof","type":{"kind":"array","length":439,"type":{"kind":"field"}}},{"name":"public_inputs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"key_hash","type":{"kind":"field"}},{"name":"tree_hash_path","type":{"kind":"array","length":12,"type":{"kind":"field"}}},{"name":"tree_index","type":{"kind":"field"}}]},"visibility":"private"},{"name":"proof_d","type":{"kind":"struct","path":"SubCircuitD","fields":[{"name":"vkey","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"proof","type":{"kind":"array","length":439,"type":{"kind":"field"}}},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}}},{"name":"key_hash","type":{"kind":"field"}},{"name":"tree_hash_path","type":{"kind":"array","length":12,"type":{"kind":"field"}}},{"name":"tree_index","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        //@safety : xlo and xhi decomposition is checked below\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"32":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let index_bits: [u1; N] = index.to_le_bits();\n    let mut current = leaf;\n    for i in 0..N {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"76":{"source":"/*\n############################################################\n# Outer Circuit\n############################################################\n# Wraps 4 inner proofs (from circuits A, B, C and D)\n############################################################\n\n# Inputs/Outputs\n############################################################\n\n# Outstanding Questions\n############################################################\n- Outer circuit interface: single multiparam commitment output, for uniform interface? e.g. `H(dg1_bitmask, dg1_reveal, service_scope, nullifier)`\nCan be verified outside of circuit proof with correct pre-image\n*/\n\nuse std::verify_proof;\n\nfn prepare_proof_c_inputs<let DATE_LEN: u32>(\n    current_date: str<DATE_LEN>,\n    f1: Field,\n    f2: Field,\n) -> [Field; DATE_LEN + 2] {\n    let date_bytes: [u8; DATE_LEN] = current_date.as_bytes();\n    let mut result: [Field; 2 + DATE_LEN] = [0; 2 + DATE_LEN];\n    for i in 0..DATE_LEN {\n        result[i] = date_bytes[i] as Field;\n    }\n    result[DATE_LEN] = f1;\n    result[DATE_LEN + 1] = f2;\n    result\n}\n\nfn prepare_proof_d_inputs<let DG1: u32>(\n    comm_in: Field,\n    dg1_mask: [u8; DG1],\n    service_scope: Field,\n    service_subscope: Field,\n    dg1_reveal: [u8; DG1],\n    scoped_nullifier: Field,\n) -> [Field; 1 + DG1 + DG1 + 3] {\n    let mut result: [Field; 1 + DG1 + DG1 + 3] = [0; 1 + DG1 + DG1 + 3];\n    result[0] = comm_in;\n    for i in 0..DG1 {\n        result[1 + i] = dg1_mask[i] as Field;\n    }\n    result[1 + DG1] = service_scope;\n    result[1 + DG1 + 1] = service_subscope;\n    for i in 0..DG1 {\n        result[1 + DG1 + 2 + i] = dg1_reveal[i] as Field;\n    }\n    result[1 + DG1 + 2 + DG1] = scoped_nullifier;\n    result\n}\n\nstruct SubCircuitA {\n    vkey: [Field; 128],\n    proof: [Field; 439],\n    key_hash: Field,\n    public_inputs: [Field; 1],\n    // Hash path for circuit A key hash in the sub-circuit merkle tree\n    // Allows for up to 4,096 leaves\n    tree_hash_path: [Field; 12],\n    // Index of circuit A key hash in the sub-circuit merkle tree\n    tree_index: Field,\n}\nstruct SubCircuitB {\n    vkey: [Field; 128],\n    proof: [Field; 439],\n    public_inputs: [Field; 2],\n    key_hash: Field,\n    // Hash path for circuit B key hash in the sub-circuit merkle tree\n    tree_hash_path: [Field; 12],\n    // Index of circuit B key hash in the sub-circuit merkle tree\n    tree_index: Field,\n}\nstruct SubCircuitC {\n    vkey: [Field; 128],\n    proof: [Field; 439],\n    public_inputs: [Field; 2],\n    key_hash: Field,\n    // Hash path for circuit C key hash in the sub-circuit merkle tree\n    tree_hash_path: [Field; 12],\n    // Index of circuit C key hash in the sub-circuit merkle tree\n    tree_index: Field,\n}\nstruct SubCircuitD {\n    vkey: [Field; 128],\n    proof: [Field; 439],\n    public_inputs: [Field; 1],\n    key_hash: Field,\n    // Hash path for circuit D key hash in the sub-circuit merkle tree\n    tree_hash_path: [Field; 12],\n    // Index of circuit D key hash in the sub-circuit merkle tree\n    tree_index: Field,\n}\n\nfn verify_subproofs(\n    // Root of the sub-circuit merkle tree\n    circuit_registry_root: Field,\n    // Root of the certificate merkle tree\n    certificate_registry_root: Field,\n    // Current date as a string, e.g. 20241103\n    current_date: str<8>,\n    // A mask representing which bytes of DG1 to reveal\n    dg1_mask: [u8; 95],\n    // The revealed bytes of DG1\n    dg1_reveal: [u8; 95],\n    // The nullifier service scope (a Pederson hash of the domain)\n    service_scope: Field,\n    // The service sub-scope\n    service_subscope: Field,\n    // The scoped nullifier: H(private_nullifier,service_scope,service_subscope)\n    scoped_nullifier: Field,\n    proof_a: SubCircuitA,\n    proof_b: SubCircuitB,\n    proof_c: SubCircuitC,\n    proof_d: SubCircuitD,\n) {\n    // Verify that sub-circuit a, b, c, and d vkey hashes exist in the circuit tree\n    let root = std::merkle::compute_merkle_root(\n        proof_a.key_hash,\n        proof_a.tree_index,\n        proof_a.tree_hash_path,\n    );\n    assert(root == circuit_registry_root);\n    let root = std::merkle::compute_merkle_root(\n        proof_b.key_hash,\n        proof_b.tree_index,\n        proof_b.tree_hash_path,\n    );\n    assert(root == circuit_registry_root);\n    let root = std::merkle::compute_merkle_root(\n        proof_c.key_hash,\n        proof_c.tree_index,\n        proof_c.tree_hash_path,\n    );\n    assert(root == circuit_registry_root);\n    let root = std::merkle::compute_merkle_root(\n        proof_d.key_hash,\n        proof_d.tree_index,\n        proof_d.tree_hash_path,\n    );\n    assert(root == circuit_registry_root);\n\n    verify_proof(\n        proof_a.vkey,\n        proof_a.proof,\n        [\n            certificate_registry_root,\n            proof_a.public_inputs[0], // comm_out\n        ],\n        proof_a.key_hash,\n    );\n    verify_proof(\n        proof_b.vkey,\n        proof_b.proof,\n        [\n            proof_b.public_inputs[0], // comm_in\n            proof_b.public_inputs[1], // comm_out\n        ],\n        proof_b.key_hash,\n    );\n\n    verify_proof(\n        proof_c.vkey,\n        proof_c.proof,\n        prepare_proof_c_inputs(\n            current_date,\n            proof_c.public_inputs[0],\n            proof_c.public_inputs[1],\n        ),\n        proof_c.key_hash,\n    );\n\n    verify_proof(\n        proof_d.vkey,\n        proof_d.proof,\n        prepare_proof_d_inputs(\n            proof_d.public_inputs[0], // comm_in\n            dg1_mask,\n            service_scope,\n            service_subscope,\n            dg1_reveal,\n            scoped_nullifier,\n        ),\n        proof_d.key_hash,\n    );\n}\n\nfn main(\n    circuit_registry_root: Field,\n    certificate_registry_root: Field,\n    current_date: pub str<8>,\n    dg1_mask: pub [u8; 95],\n    dg1_reveal: pub [u8; 95],\n    service_scope: pub Field,\n    service_subscope: pub Field,\n    scoped_nullifier: pub Field,\n    proof_a: SubCircuitA,\n    proof_b: SubCircuitB,\n    proof_c: SubCircuitC,\n    proof_d: SubCircuitD,\n) {\n    verify_subproofs(\n        circuit_registry_root,\n        certificate_registry_root,\n        current_date,\n        dg1_mask,\n        dg1_reveal,\n        service_scope,\n        service_subscope,\n        scoped_nullifier,\n        proof_a,\n        proof_b,\n        proof_c,\n        proof_d,\n    );\n    // verify_subproofs_unconstrained(circuit_registry_root, proof_a, proof_b, proof_c, proof_d);\n}\n","path":"/Users/ryan.cao/ryan_tfh/Client_Side_Proving/noir_passport_circuits/src/noir/bin/main/outer/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_to_radix"]}