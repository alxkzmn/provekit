{
  "noir_version": "0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab",
  "hash": 12845801014874054885,
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "result",
        "type": {
          "kind": "array",
          "length": 32,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "toggle",
        "type": {
          "kind": "boolean"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "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USyeKJaRKJY8+65tifbdlmjfbYn23ZZo322J9t2WaN9tifbdlmjfbYn23ZZo322J9l1JtO9Kon1XEu27kmjflUT7riTadyXRviuJ9l1JtO9Kon1XE+27mmjf1UT7ribadzXRvquJ9l1NtO9qon1XE+27mmjf7Yn23Z5o3+2J9t2eaN/tifbdnmjf7Yn23Z5o3+2J9t2eaN+1RPuuJdp3LdG+a4n2XUu071qifdcS7buWaN+1RPuuJdp3PdG+64n2XU+073qifdcT7bueaN/1RPuuJ9p3PdG+64n23ZFo3x2J9t2RaN8difbdkWjfHYn23ZFo3x2J9t2RaN8difbdmWjfnYn23Zlo352J9t2ZaN+difbdmWjfnYn23Zlo352J9t1ItO9Gon03Eu27kWjfjUT7biTadyPRvhuJ9t1E59Us0Xk1T3RezROdV/NE59U80Xk13/Lsu57ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJonOq/mic6reaLzap7ovJp/wHk1lZ9jiXsH8N9w8OG0g0E7mLSDgB2cP621ctBoB0I7UNpBpx3QJE+a5EmTPGmSJ01y0CQHTXLQJAdNMv13lZz+u0pO/10lp/+ukgdNcsAkj22jHTTagdAOlHbQaQdGO3DawaAdTNoBTXKjSW40yY0m+fwRAdns5kA2v3fQaQenSZa+3RzoJvcOnHYwaAeTdhCwg/NV7ysHjXYgtAOlHXTaAU2y0CQLTbLQJAtNstIkK02y0iQrTbLSJCtNstIkK02y0iQrTXKnSe40yZ0mudMkd5rkTpPcaZI7TXKnSe40yUaTbDTJRpNsNMlGk2w0yUaTbDTJRpNsNMlOk+w0yU6T7DTJTpPsNMlOk+w0yU6T7DTJgyZ50CQPmuRBkzxokgdN8qBJHjTJ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",
  "file_map": {
    "26": {
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n",
      "path": "std/field/mod.nr"
    },
    "35": {
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n",
      "path": "std/hash/sha256.nr"
    },
    "70": {
      "source": "// Sha256 example\n//\n// Calls Sha256 from the standard library.\n//\n// The Compiler sees this special function and creates an ACIR gate\n//\n// The ACIR SHA256 gate is passed to PLONK who should\n// know how to create the necessary constraints.\n//\n// Not yet here: For R1CS, it is more about manipulating arithmetic gates to get performance\n// This can be done in ACIR!\nfn main(x: Field, result: [u8; 32], input: [u8; 2], toggle: bool) {\n    // We use the `as` keyword here to denote the fact that we want to take just the first byte from the x Field\n    // The padding is taken care of by the program\n    // docs:start:sha256_var\n    let digest = std::hash::sha256_var([x as u8], 1);\n    // docs:end:sha256_var\n    assert(digest == result);\n\n    let digest = std::hash::sha256([x as u8]);\n    assert(digest == result);\n\n    // variable size\n    let size: Field = 1 + toggle as Field;\n    let var_sha = std::hash::sha256_var(input, size as u64);\n    assert(var_sha == std::hash::sha256_var(input, 1));\n}\n",
      "path": "/Users/remcobloemen/github/worldfnd/ProveKit/noir-r1cs/noir-examples/sha256/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "build_msg_block_iter",
    "pad_msg_block",
    "attach_len_to_msg_block",
    "build_msg_block_iter",
    "directive_integer_quotient",
    "directive_invert"
  ]
}
